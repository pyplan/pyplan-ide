{"modelProp": {}, "nodeList": [{"color": null, "definition": "result = 0", "description": null, "errorInDef": false, "extraData": null, "h": "50", "identifier": "creating_my_first_app", "moduleId": "_model_", "nodeClass": "model", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Creating my first app", "units": null, "w": "100", "x": 100, "y": 100, "z": 1}, {"color": null, "definition": "import numpy, pandas, cubepy, xarray\n#fill the following dict keys with the alias you need to import in each node\nresult = {\n    \"np\":numpy,\n    \"pd\":pandas,\n    \"cubepy\":cubepy,\n    \"xr\":xarray\n}", "description": null, "errorInDef": false, "extraData": null, "h": "50", "identifier": "imports", "moduleId": "creating_my_first_app", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Default imports", "units": null, "w": "100", "x": 50, "y": 500, "z": 1}, {"color": "#4CBCFF", "definition": "a = 4\r\nb = 5\r\nprint('parameters: ' + str(a) + ',' + str(b))\r\nresult = a+b", "description": null, "errorInDef": false, "extraData": null, "h": "48", "identifier": "my_first_node", "moduleId": "first_nodes", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "My first node", "units": null, "w": "96", "x": 221, "y": 146, "z": 1}, {"color": "#a5ff4b", "definition": "result = pd.read_csv('http://web.stanford.edu/class/archive/cs/cs109/cs109.1166/stuff/titanic.csv', sep=None)", "description": null, "errorInDef": false, "extraData": null, "h": "48", "identifier": "csv", "moduleId": "first_nodes", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "csv", "units": null, "w": "96", "x": 221, "y": 213, "z": 1}, {"color": "#9999ff", "definition": "result = pd.Index([\"Item 1\",\"Item 2\",\"Item 3\"])", "description": null, "errorInDef": false, "extraData": null, "h": "48", "identifier": "my_first_index", "moduleId": "creating_my_first_app", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "my first index", "units": null, "w": "96", "x": 63, "y": 116, "z": 1}, {"color": "#9999ff", "definition": "result = pd.Index([\"Second Index Item 1\",\"Second Index Item 2\",\"Second Index Item 3\"])", "description": null, "errorInDef": false, "extraData": null, "h": "48", "identifier": "my_second_index", "moduleId": "creating_my_first_app", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "my second index", "units": null, "w": "96", "x": 49, "y": 182, "z": 1}, {"color": "#ffff4b", "definition": "result = xr.DataArray([[15.0,20.0,25.0], [6.0,5.0,0.0], [0.0,0.0,25.0]],[my_first_index, my_second_index])", "description": null, "errorInDef": false, "extraData": null, "h": "48", "identifier": "my_first_matrix", "moduleId": "creating_my_first_app", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "my first matrix", "units": null, "w": "96", "x": 243, "y": 137, "z": 1}, {"color": "#ffff4b", "definition": "result = create_dataarray( 1.,[my_first_index])", "description": null, "errorInDef": false, "extraData": null, "h": "48", "identifier": "my_second_matrix", "moduleId": "creating_my_first_app", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "My second matrix", "units": null, "w": "96", "x": 356, "y": 72, "z": 1}, {"color": "#4CBCFF", "definition": "result = my_first_matrix*my_second_matrix", "description": null, "errorInDef": false, "extraData": null, "h": "48", "identifier": "my_multiplication", "moduleId": "creating_my_first_app", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "my multiplication", "units": null, "w": "96", "x": 354, "y": 136, "z": 1}, {"color": "#9FC5E8", "definition": "", "description": null, "errorInDef": false, "extraData": null, "h": "50", "identifier": "first_nodes", "moduleId": "creating_my_first_app", "nodeClass": "module", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "first nodes", "units": null, "w": "100", "x": 351, "y": 229, "z": 1}, {"color": "#EEEEEE", "definition": "", "description": "My example", "errorInDef": false, "extraData": null, "h": "263", "identifier": "ae28667d08a6b4e9da366ae573c514c58", "moduleId": "creating_my_first_app", "nodeClass": "text", "nodeFont": "Helvetica,21", "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 0, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 1, "__dict__": {}}, "originalId": null, "picture": null, "title": null, "units": null, "w": "497", "x": 15, "y": 29, "z": -1}, {"color": "#F3F3F3", "definition": "", "description": null, "errorInDef": false, "extraData": null, "h": 32, "identifier": "pyplan_xarray_extensions", "moduleId": "creating_my_first_app", "nodeClass": "module", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 0, "showBorder": 0, "showInputs": 0, "showLabel": 0, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Pyplan XArray Extensions", "units": null, "w": 76, "x": -204, "y": 49, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(pypi_name,import_name=None):\n    \"\"\" Install library from pypi or .libs dir\n    pypi_name : Library name in pypi\n    import_name: library name for use in import\n    \"\"\"\n    import importlib\n    \n    def _exists_module(import_name):\n        try:\n            importlib.import_module(import_name)\n            return True\n        except ImportError:\n            return False\n\n    if import_name is None:\n        import_name = pypi_name\n        \n    if not _exists_module(import_name):\n        #check in lib folder\n        import os  \n        _lib_path = current_path + \"libs\"\n        \n        if not os.path.isdir(_lib_path):\n            os.mkdir(_lib_path) \n\n        #install lib to libs folder    \n        os.system(f\"pip install -t \\\"{_lib_path}\\\" {pypi_name}\")\n        \n        importlib.invalidate_caches()\n        \n        if not _exists_module(import_name):\n            raise ValueError(f\"Can't install the module '{import_name}'\")\n    return True\n    \n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "install_library", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Install Library", "units": null, "w": 179, "x": 306, "y": 497, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(dataArray,domainDic, defaultValue=None):\n    _da = dataArray\n    for key in domainDic:\n        _da = _da.reindex({key:domainDic[key].values})\n        _da = _da.rename({key:domainDic[key].name})\n    if not defaultValue is None:\n        _da = _da.fillna(defaultValue)\n    return _da\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "set_domain", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Set domain", "units": null, "w": 179, "x": 107, "y": 90, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(values,name=\"Report\"):\n    _titles = [str(xx.name) for xx in values]\n    _index = pd.Index( _titles, name=name)\n    \n    return xr.concat(values,_index)\n\n\nresult = _fn\n", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "build_report", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Build Report", "units": null, "w": 179, "x": 107, "y": 127, "z": 1}, {"color": null, "definition": "def _fn(filepath, useOpenpyxl=False, dataOnly=True, readOnly=True ):\r\n    \"\"\" Create excel object from filepath.\r\n    filepath: path to excel file\r\n    useOpenpyxl: True for use custom \r\n    dataOnly: True for view only the values, not formula\r\n    readOnly: True for read only, False for write options\r\n    Ex.\r\n            excel_connection(\"\\path\\to\\the\\excelfile.xlsx\")\r\n    \"\"\"\r\n    import os\r\n    \r\n\r\n    if self.model.isLinux():\r\n        filepath = filepath.replace(\"\\\\\",\"/\")        \r\n\r\n    fullFilename=filepath\r\n    \r\n    if not os.path.isfile(fullFilename):\r\n        fullFilename = self.node.model.getNode(\"current_path\").result + filepath     \r\n        \r\n\r\n    if os.path.isfile(fullFilename):\r\n        if useOpenpyxl:\r\n            from openpyxl import load_workbook\r\n            return load_workbook(fullFilename, data_only=dataOnly, read_only=readOnly)\r\n        else:\r\n            return filepath\r\n    else:\r\n        raise ValueError(\"File not found\") \r\n        \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "excel_connection", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Excel connection", "units": null, "w": 179, "x": 306, "y": 90, "z": 1}, {"color": null, "definition": "def _fn(value,coords,dtype=None):\n    _data = np.full( tuple([(len(x)) for x in coords]),value, dtype=dtype )\n    return xr.DataArray( _data, coords )\n\nresult = _fn\n", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "create_dataarray", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Create dataArray", "units": null, "w": 179, "x": 107, "y": 164, "z": 1}, {"color": null, "definition": "def _fn(excel,sheetName=None,namedRange=None,cellRange=None, indexes=None, driver=\"Driver={Microsoft Excel Driver (*.xls, *.xlsx, *.xlsm, *.xlsb)};DBQ=%s;READONLY=TRUE\"):\r\n    \"\"\" return a pandas dataframe from excel.\r\n    excel: path to excel file or cp.excel object\r\n    sheetName: sheet name to be read\r\n    namedRange: name of the range to be read\r\n    cellRange: used with sheetname, for read from a simple range\r\n    indexes: Listo of columns names for convert to index of dataframe\r\n        Ex.\r\n            pandas_from_excel(excelNode,\"Sheet 1\")\r\n            pandas_from_excel(excelNode,namedRange=\"name_range\")\r\n            pandas_from_excel(excelNode,\"Sheet 1\",cellRange=\"A1:H10\")\r\n\r\n    \"\"\"\r\n\r\n    if isinstance(excel,str):\r\n        import os\r\n        \r\n        \r\n        if not os.path.isfile(excel):\r\n            excel = os.path.join(self.model.getNode(\"current_path\").result,excel)\r\n            \r\n            \r\n        if self.model.isLinux():\r\n            filename=excel\r\n            target_dir = os.path.dirname(filename)\r\n            file_name, file_extension = os.path.splitext(filename)\r\n            target_dir = os.path.join(target_dir, file_name)\r\n\r\n            file_to_read = os.path.join(target_dir, (namedRange if namedRange else \"\")  +\".pkl\")\r\n            if os.path.isfile(file_to_read):\r\n                df = pd.read_pickle(file_to_read,compression='gzip')\r\n                if not indexes is None:\r\n                    df.set_index(indexes,inplace=True)\r\n                return df\r\n            else:\r\n                from openpyxl import load_workbook\r\n                _wb = load_workbook(filename, data_only=True, read_only=True)\r\n                return _fn(_wb,sheetName,namedRange,cellRange,indexes)\r\n        else:\r\n            \r\n\r\n            import pyodbc\r\n    \r\n            cnxn = pyodbc.connect(driver % excel, autocommit=True)\r\n            cursor = cnxn.cursor()\r\n            table = \"\"\r\n            if not sheetName is None: \r\n                table = \"[\"+sheetName+\"$]\"\r\n            if not namedRange is None:\r\n                table = \"[\"+namedRange+\"]\"\r\n            if not cellRange is None:\r\n                table = \"[\"+sheetName+\"$\"+cellRange+\"]\"\r\n    \r\n            cursor.execute(\"SELECT * FROM \" + table)\r\n            rows = cursor.fetchall()\r\n            columnNames = [str(x[0]) for x in cursor.description]\r\n            cnxn.close()\r\n    \r\n            _df = pd.DataFrame.from_records(rows,None,None,columnNames)\r\n            _df = _df.dropna(how =\"all\")\r\n            if not indexes is None:\r\n                _df.set_index(indexes,inplace=True)\r\n            return _df\r\n    else:\r\n        \r\n        if \"openpyxl.workbook\" in str(type(excel)):\r\n            rangeToRead = None\r\n            if not namedRange is None:\r\n                the_range = excel.defined_names[namedRange]\r\n                dests = the_range.destinations\r\n                for title, coord in dests:\r\n                    ws = excel[title]\r\n                    rangeToRead=ws[coord]\r\n            elif not cellRange is None:\r\n                ws = excel[sheetName]\r\n                rangeToRead = ws[cellRange]\r\n            else: \r\n                rangeToRead = excel[sheetName]\r\n\r\n            nn=0\r\n            cols=[]\r\n            values = []\r\n            for row in rangeToRead:\r\n                if nn==0:\r\n                    cols = [str(c.value) for c in row]\r\n                else:\r\n                    values.append([c.value for c in row]) \r\n                nn+=1\r\n            df = pd.DataFrame(values,None,cols)\r\n            if not indexes is None:\r\n                if isinstance(indexes,str):\r\n                    indexes=[indexes]\r\n                toIndex = []\r\n                for indexColumn in indexes:\r\n                    if indexColumn in df.columns.values:\r\n                        toIndex.append(indexColumn)\r\n                if len(toIndex)>0:\r\n                    df.set_index(toIndex, inplace=True)\r\n\r\n            return df.dropna(how =\"all\")\r\n        else:\r\n            raise ValueError(\"excel can be cp.excel object\") \r\n            \r\n            \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "pandas_from_excel", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Pandas from excel", "units": null, "w": 179, "x": 304, "y": 238, "z": 1}, {"color": null, "definition": "def _fn(dataframe, columnName=None, removeEmpty=True):\r\n    \"\"\" Return a pd.Index from an column of a pandas dataframe.\r\n    dataframe: pandas dataframe\r\n    columnName: dataframe column name used for create cp.index. By default is created using the first column\r\n    removeEmpty: True for remove empty rows\r\n        Ex.\r\n            index_from_pandas(df)\r\n            index_from_pandas(df,\"column10\")\r\n    \"\"\"                \r\n    \r\n    _serie= None\r\n    if columnName is None:\r\n        _serie=dataframe[dataframe.columns[0]]\r\n    else:\r\n        _serie=dataframe[columnName]\r\n\r\n    if removeEmpty:\r\n        _serie.dropna(inplace=True)\r\n        if kind_to_string( _serie.dtype.kind )==\"string\" or kind_to_string(_serie.dtype.kind )==\"object\":\r\n            _serie = _serie[_serie!=\"\"]\r\n\r\n    return pd.Index(_serie.unique())\r\n\r\n            \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "index_from_pandas", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Index from Pandas", "units": null, "w": 179, "x": 304, "y": 275, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(kind):\n    \"\"\"Returns the data type on human-readable string\n    \"\"\"\n    if kind in {'U', 'S'}:\n        return \"string\"\n    elif kind in {'b'}:\n        return \"boolean\"\n    elif kind in {'i','u','f','c'}:\n        return \"numeric\"\n    elif kind in {'m','M'}:\n        return \"date\"\n    elif kind in {'O'}:\n        return \"object\"\n    elif kind in {'V'}:\n        return \"void\"\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "kind_to_string", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Kind to String", "units": null, "w": 179, "x": 304, "y": 201, "z": 1}, {"color": null, "definition": "def _fn(excel, sheetName=None,namedRange=None,cellRange=None, columnName=None, removeEmpty=True):\r\n    \"\"\" Return a pd.Index from an excel file.\r\n    excel: pp.excel object\r\n    sheetName: sheet name to be read\r\n    namedRange: name of the range to be read\r\n    cellRange: used with sheetname, for read from a simple range\r\n    columnName: dataframe column name used for create pp.index. By default is created using the first column\r\n    removeEmpty: True for remove empty rows\r\n        Ex.\r\n            index_from_excel(excelNode,\"Sheet 1\")\r\n            index_from_excel(excelNode,namedRange=\"name_range\")\r\n            index_from_excel(excelNode,namedRange=\"name_range\", columnName=\"indicadores\")\r\n    \"\"\"                \r\n    if isinstance(excel,str) or \"openpyxl.workbook\" in str(type(excel)):\r\n        _df = pandas_from_excel(excel,sheetName,namedRange,cellRange)\r\n        return index_from_pandas(_df,columnName,removeEmpty)\r\n    else:\r\n        raise ValueError(\"excel can be excel_connection object or a str path to the filename\")\r\n\r\n            \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "index_from_excel", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Index from Excel", "units": null, "w": 179, "x": 304, "y": 312, "z": 1}, {"color": null, "definition": "def _fn(excel, sheetName=None,namedRange=None,cellRange=None, indexes=None, valueColumns=None, indexColumnHeaders=None, replaceByIndex=None, defaultValue=0):\r\n    \"\"\" Return a xr.DataArray from excel file.\r\n    excel: excel_connection object.\r\n    sheetName: sheet name to be read\r\n    namedRange: name of the range to be read.\r\n    cellRange: used with sheetName to read from a simple range.\r\n    indexes: pd.Index objects to perform a change_index operation.\r\n    valueColumns: string with the column name of the dataframe that contains the values.\r\n                pd.Index with column names to convert columns to index.\r\n    indexColumnHeaders: (optional) column names in pandas to parse with indexes. Used if header on dataframe is not equal to index identifiers.\r\n    replaceByIndex: (optional) replace index used in valueColumns by this index (using change_index).\r\n\r\n        Ex.\r\n            dataarray_from_excel(excelNode,\"Sheet 1\",indexes=[indicadores],valueColumns=\"descuentos\")\r\n            pp.dataarray_from_excel(excelNode,namedRange=\"nombre_rango\",indexes=[indicadores],valueColumns=time)\r\n    \"\"\"\r\n\r\n    dataframe = pandas_from_excel(excel,sheetName,namedRange,cellRange)\r\n    # Check size of dataframe. If it is empty, create empty dataArray. Else, proceed\r\n    if len(dataframe) == 0:\r\n        if not isinstance(indexes, list):\r\n            indexes = [indexes]\r\n        if isinstance(valueColumns, pd.Index):\r\n            indexes.append(valueColumns)\r\n        \r\n        _data = np.full(tuple([(len(x)) for x in indexes]), defaultValue)\r\n        return xr.DataArray(_data, indexes)\r\n    else:\r\n        valueIndex=None\r\n        if isinstance(valueColumns,pd.Index):\r\n            valueIndex = valueColumns\r\n            valueColumns = valueIndex.values\r\n        elif isinstance(valueColumns,str):\r\n            valueColumns = [valueColumns]\r\n    \r\n        if indexColumnHeaders is None:\r\n            indexColumnHeaders = [index.name for index in indexes]\r\n            \r\n        # Create total index and index names\r\n        _allindexes = indexes\r\n        _allIndexNames = indexColumnHeaders[:]\r\n        if not valueIndex is None:\r\n            _allindexes.append(valueIndex)\r\n            _allIndexNames.append(\"data_index\")    \r\n    \r\n        _full = dataframe.reset_index().melt(id_vars=indexColumnHeaders,value_vars=valueColumns, var_name=\"data_index\", value_name=\"data_value\")\r\n        \r\n        # sum for acum over duplicate records\r\n        _full = _full.groupby(_allIndexNames, as_index=False).sum()\r\n        _dtype = _full[\"data_value\"].dtype\r\n        \r\n        _dataType = kind_to_string(_dtype.kind )\r\n        if _dataType==\"string\":\r\n            _full = _full[ (_full[\"data_value\"]!=\"\") & (_full['data_value'].notna()) ]\r\n        else:\r\n            _full = _full[ (_full[\"data_value\"]!=0) & (_full['data_value'].notna()) ]\r\n    \r\n        _full.set_index(_allIndexNames, inplace=True)\r\n        _da = _full[\"data_value\"].to_xarray()  \r\n    \r\n        # If indexed, rename index\r\n        if not indexes is None and not indexColumnHeaders is None:\r\n            if not isinstance(indexes,list):\r\n                indexes = [indexes]\r\n            idxPos=0\r\n            for cubeIndex in indexes:\r\n                newIndexName=cubeIndex.name\r\n                if idxPos<= len(indexColumnHeaders)-1:\r\n                    oldIndexName=indexColumnHeaders[idxPos]\r\n                    if not newIndexName in _da.coords:\r\n                        _da.coords[newIndexName] = _da.coords[oldIndexName]\r\n                        _da = _da.swap_dims({oldIndexName:newIndexName}).drop(oldIndexName)\r\n                    idxPos+=1\r\n                    # Reindex to complete combinations\r\n                    _da = _da.reindex({newIndexName:cubeIndex.values})\r\n    \r\n        if not valueIndex is None:\r\n            newIndexName=valueIndex.name\r\n            oldIndexName=\"data_index\"\r\n            if not newIndexName in _da.coords:\r\n                _da.coords[newIndexName] = _da.coords[oldIndexName]\r\n                _da = _da.swap_dims({oldIndexName:newIndexName}).drop(oldIndexName)\r\n            # Reindex to complete combinations\r\n            _da = _da.reindex({newIndexName:valueIndex.values})\r\n    \r\n            if not replaceByIndex is None:\r\n                _da = change_index(_da,valueIndex,replaceByIndex, 2 )    \r\n                \r\n        return _da.fillna(defaultValue)\r\n\r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "dataarray_from_excel", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "DataArray from Excel", "units": null, "w": 179, "x": 306, "y": 386, "z": 1}, {"color": null, "definition": "def _fn(dataArray, indexes, values):\r\n    \"\"\"\r\n    Filter dataArray using the filterList filters. \r\n\r\n    dataArray: dataArray to be filtered\r\n    indexes: the index to filter \r\n    values: the value to filter \r\n        Ex.\r\n            subscript(dataArray, index, value)\r\n    \"\"\"\r\n    if not isinstance(dataArray,xr.DataArray):\r\n        raise ValueError(\"the 'dataArray' parameter must be of the type xr.DataArray\")\r\n\r\n    if not isinstance(indexes,list):\r\n        indexes = [indexes]\r\n    if not isinstance(values,list):\r\n        values = [values]\r\n        \r\n    res = dataArray\r\n    filterDic = {}\r\n    for _pos, indexItem in enumerate(indexes):\r\n        filterDic[indexItem.name] = values[_pos]\r\n\r\n    if len(filterDic)>0:\r\n        res = res.sel(filterDic, drop=True)\r\n\r\n    return res\r\n        \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "subscript", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Subscript", "units": null, "w": 179, "x": 306, "y": 127, "z": 1}, {"color": null, "definition": "def _fn(dataArray,oldIndex,newIndex,compareMode=1,defaultValue=None):\r\n    \"\"\" Change index of a dataArray object.\r\n    \"\"\"\r\n    _da = dataArray\r\n\r\n\r\n    if compareMode==1:\r\n        _temp = _da.reindex({oldIndex.name:newIndex.values})\r\n        _temp[newIndex.name] = _temp[oldIndex.name]\r\n        _temp = _temp.swap_dims({oldIndex.name:newIndex.name}).drop(oldIndex.name)\r\n        if not defaultValue is None:\r\n            _temp = _temp.fillna(defaultValue)\r\n        return _temp\r\n    else:\r\n\r\n        if len(oldIndex.values) == len(newIndex.values):\r\n            _tmp = _da.copy()\r\n            _tmp.coords[newIndex.name] = _tmp.coords[oldIndex.name]\r\n            _tmp.coords[newIndex.name].data = newIndex.values\r\n            _tmp = _tmp.swap_dims({oldIndex.name : newIndex.name}).drop(oldIndex.name)\r\n            return _tmp\r\n        elif len(oldIndex.values) > len(newIndex.values):\r\n            raise ValueError(\"Changeindex by pos for indices of different size is not implemented\")\r\n        else:\r\n            raise ValueError(\"Changeindex by pos for indices of different size is not implemented\")\r\n    \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "change_index", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Change index", "units": null, "w": 179, "x": 306, "y": 164, "z": 1}, {"color": null, "definition": "def _fn(date_start,date_end,freq='M',format='%Y.%m'):\r\n    \"\"\"Create time index usign start and end dates and freq. The result is formated to format parameter\r\n        Ex.\r\n            create_time('2016.01','2018.12')\r\n            create_time('2016.01.01','2016.12.31',freq='D',format='%d/%m/%Y')\r\n    \"\"\"\r\n    if \".\" in date_start:\r\n        date_start = date_start.replace('.', '-')\r\n    if \".\" in date_end:\r\n        date_end = date_end.replace('.', '-')\r\n    return pd.Index(pd.period_range(start=date_start, end=date_end, freq=freq).strftime(format))\r\n        \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "create_time", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "CreateTime", "units": null, "w": 179, "x": 505, "y": 90, "z": 1}, {"color": null, "definition": "def _fn(param1, param2, compareType=1, caseSensitive = True):\r\n    \"\"\"\r\n    param1: value or indexarray for compare\r\n    param2: index compare to\r\n    compareType: exact=1, start_with=2, end_with=3, contain=4  \r\n    caseSensitive: able to differentiate between uppercase and lowercase (by default True)\r\n\r\n    If param1 is a scalar (numeric or str) and param2 is an index:  return a dataArray indexed by param2 with True on ocurrences of param2\r\n        Ex. result = find(\"te\", region, cp.end_with)\r\n    If param1 is an index and param2 is an index too:  return a dataArray indexed by param1 and param2 with True on ocurrences of param1 on param2\r\n        Ex. result = find(subregion, region, cp.contain)\r\n\r\n    \"\"\"\r\n    def _internalFn(item,value):\r\n        if not isinstance(item,str):\r\n            item = str(item)\r\n        if not isinstance(value,str):\r\n            value = str(value)\r\n            \r\n        if compareType==1:\r\n            if caseSensitive:\r\n                return item == value\r\n            else:\r\n                return item.lower() == value.lower()\r\n        elif compareType==2:\r\n            if caseSensitive:\r\n                return item[:len(value)] == value\r\n            else:\r\n                return item[:len(value)].lower() == value.lower()                                    \r\n        elif compareType==3:\r\n            if caseSensitive:\r\n                return item[-len(value):] == value\r\n            else:\r\n                return item[-len(value):].lower() == value.lower()                    \r\n        elif compareType==4:\r\n            if caseSensitive:\r\n                return value in item\r\n            else:\r\n                return value.lower() in item.lower()\r\n\r\n    if (isinstance(param1,str) or str(param1).isnumeric()) and isinstance(param2,pd.Index):\r\n        vfn = np.vectorize(_internalFn)\r\n        return xr.DataArray(vfn(param2.values,param1),[param2])\r\n\r\n    if isinstance(param1,pd.Index) and isinstance(param2,pd.Index):\r\n        _res = create_dataarray(False, [param1,param2], dtype=bool)\r\n        for row in param1.values:\r\n            for col in param2.values:\r\n                _res.loc[ {param1.name:slice(row,row), param2.name:slice(col,col) }] = _internalFn(col,row)\r\n        return _res \r\n            \r\nresult = _fn\r\n", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "find", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Find", "units": null, "w": 179, "x": 107, "y": 201, "z": 1}, {"color": null, "definition": "def _fn(dataArray, dataMap, sharedIndex, defaultValue=0): \n    \"\"\"\n    Returns the value of dataArray indexed by the index of dataMap.\n    dataArray must be indexed by sharedIndex and dataArray values must correspond to elements of sharedIndex.\n    For example: Let's say you have a cube with an estimated inflation rate by Country (\"inflation_rate\" is the name of the cube; \"country\" is the name of the index) and you want to assign it to the corresponding Company depending on its location. On the other hand, there's a many-to-one map where each Company is allocated to a single Country (\"country_to_company_allocation\"). The sharedIndex, in this case, is Country (\"country\").\n    As a result, \n        lookup( inflation_rate , country_to_company_allocation , country )\n    will return the estimated inflation rate by Company.\n    \"\"\"\n\n    try:\n        return dataArray.sel({sharedIndex.name: dataMap }, drop=True) \n    except Exception as ex:\n        filtro =  dataMap.isin(sharedIndex.values)\n        valuesOk =  dataMap[dataMap.isin(sharedIndex.values)]\n        lookOk =  dataArray.sel({sharedIndex.name: valuesOk }, drop=True) \n        final = lookOk.reindex({dataMap.dims[0]:dataMap.coords[dataMap.dims[0]].values})\n        return final.fillna(defaultValue)\n    \nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "lookup", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Lookup", "units": null, "w": 179, "x": 505, "y": 127, "z": 1}, {"color": null, "definition": "def _fn(dataArray, mapInfo, sourceIndex, targetIndex, aggregationFunction='sum'):\n    \"\"\" Aggregates the values in DataArray to generate the result indexed by  targetIndex.\n        mapInfo gives the value of targetIndex for each element of sourceIndex (If the map does not match then the element will not be set into target index and information will be lost)\n        aggregationFuction (optional) especifies the function to be used when grouping data (sum, mean, min, max, median)\n\n        Example for aggregating time information into annual index the syntax is:\n            aggregate(dataArray, map, time, years)\n    \"\"\"\n    _map = pd.DataFrame({targetIndex.name:mapInfo.to_series()})\n    _serie = dataArray.to_series()\n    _df = pd.DataFrame({\"value\":_serie})\n    _df = _df[ _df[\"value\"]!=0 ]\n    _df = _df.join(_map).reset_index()\n    _df.drop(columns=[sourceIndex.name],inplace=True)\n    _newDimList = [xx for xx in dataArray.dims if xx not in [sourceIndex.name]]\n    _newDimList.append(targetIndex.name)\n    _df = _df.groupby(_newDimList).agg(aggregationFunction)\n    _da = _df[\"value\"].to_xarray()\n\n    #reindex\n    _reindexDic={targetIndex.name:targetIndex.values}\n    for coord in dataArray.coords:\n        if coord!=sourceIndex.name:\n            _reindexDic[ coord] = dataArray.coords[coord].values\n    _da = _da.reindex(_reindexDic)\n    # fin reindex\n    return _da.fillna(0)\n    \nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "aggregate", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Aggregate", "units": null, "w": 179, "x": 505, "y": 164, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(cube):\n    \"\"\"Returns a list of all the elements of the index for which cube is true. The function is used to create a new index that is a subset of an existing index.\n        Ex. subset(sales>0)\n    \"\"\"\n    cond = cube>0\n    values = cond.coords[cond.dims[0]].values[cond.values]\n    return pd.Index(values)\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "subset", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Subset", "units": null, "w": 179, "x": 107, "y": 275, "z": 1}, {"color": "#cb98ff", "definition": "def _fn( param1, separator, part=None ): \n    \"\"\"\n    Description: Returns a DataArray object with text values formed by splitting the elements of param1 text values at each occurrence of separator \"separator\". \n    The DataArray will have the original dimension plus a new dimension 'Parts' of length (number of separators + 1). \n    All text values must have the same number of separators separator.        \n    \"\"\"\n    if isinstance(param1, pd.Index) : \n        param1 = xr.DataArray(param1.values, [param1]) \n\n    _q_separators = apply_fn( param1, lambda x: x.count(separator) ) \n    _max_q_separators = np.asscalar( _q_separators.max().values ) \n    _result_coords = ['Part ' + str(i) for i in range( 1, _max_q_separators + 2)] \n    _result_dim = pd.Index( _result_coords ) \n    _result_dim.name = \"Parts\" \n\n    _results = [] \n\n    for _part in range( _max_q_separators + 1 ): \n        _dataarray = apply_fn( param1, lambda x: x.split(separator)[_part] ) \n        _results.append(_dataarray) \n\n    _res = xr.concat( _results, dim = _result_dim )\n\n    if not part is None:\n        _res = _res.sel(Parts=\"Part \" + str(part),drop=True)\n\n    return _res\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "split_text", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Split Text", "units": null, "w": 179, "x": 107, "y": 312, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(index): \n    \"\"\"\n    Return datarray with pd.index and yours positions as values\n    \"\"\"\n    return xr.DataArray(range(0,len(index)), [index] )\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "get_pos", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Get pos", "units": null, "w": 179, "x": 107, "y": 349, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(*args):\n    \"\"\"\n    Concatenates two or more indexes and/or atomic values into a single new index\n    Return: new index\n        Ex.\n            cp.concatIndex(index1,index2,index3,value1,value2)\n    \"\"\"\n    _list = []\n    for arg in args:\n        if isinstance(arg,pd.Index):\n            values = (arg.values).tolist()\n            _list.extend(values)\n        else:\n            _list.append(arg)\n\n    seripandas = pd.Series(_list)\n    return pd.Index(seripandas.unique())\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "concat_index", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Concat Index", "units": null, "w": 179, "x": 107, "y": 386, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(index,selection,includeAll=False):\n    \"\"\"Return the element in the \"selection\" position of the index. \n    \"\"\"\n    if selection==0 and includeAll==1:\n        return \"All\"\n    else:\n        values = None\n        if isinstance(index,pd.Index):\n            values = (index.values[:1000]).tolist()\n        elif isinstance(index,np.ndarray):\n            values = (index[:1000]).tolist()\n        else:\n            values = list(index)[:1000]\n        if not values is None and len(values)>=selection:\n            return values[selection-1]\n    return \"\"\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "choice", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Choice", "units": null, "w": 179, "x": 505, "y": 201, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(dataArray,index,shift, initialValues=None):\n    \"\"\"\n    Perform cyclic calculations betwwen nodes.\n    cube: cp.cube to evaluate\n    index: Index to shift \n    shift: amount of elemnts to shift. Can be positive or negative\n    initialValues: (optional), initial values to apply to first \"shift\" elemnts\n    \"\"\"\n    _da = dataArray.shift({index.name:(shift*-1)})\n    if not initialValues is None:\n        _da = _da.fillna(initialValues)\n    return _da\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "dynamic", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Dynamic", "units": null, "w": 179, "x": 505, "y": 238, "z": 1}, {"color": "#EEEEEE", "definition": null, "description": "Pyplan XArray Extensions - 25-Jun-2019", "errorInDef": false, "extraData": null, "h": 521, "identifier": "a46ff2bbf32b248e9abbbeed6c482547b", "moduleId": "pyplan_xarray_extensions", "nodeClass": "text", "nodeFont": "Helvetica,15", "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 0, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 1, "__dict__": {}}, "originalId": null, "picture": null, "title": null, "units": null, "w": 851, "x": 46, "y": 53, "z": -1}, {"color": null, "definition": "def _fn(dataArray, index, position):\r\n    \"\"\"\r\n    Filter dataArray by integer position along the specified index.\r\n    \r\n    dataArray: dataArray to be filtered\r\n    index: pp.index \r\n    position: int \r\n        Ex.\r\n            pp.isel(dataArray1, index1, 0)\r\n    \"\"\"\r\n    if not isinstance(dataArray,xr.DataArray):\r\n        raise ValueError(\"the 'dataArray' parameter must be of the type xr.DataArray\")\r\n    return dataArray.isel({index.name:position},drop=True)\r\n    \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "slice_dataarray", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Slice", "units": null, "w": 179, "x": 505, "y": 275, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(param):\n   return xr.DataArray(param.values,[param])\n   \n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "to_dataarray", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "To Dataarray", "units": null, "w": 179, "x": 306, "y": 423, "z": 1}, {"color": null, "definition": "def _fn(dataArray,value=0):\r\n    \"\"\"Fill np.inf values with default value\r\n        Ex.\r\n            fill_inf(dataArray,0)\r\n    \"\"\"\r\n    return apply_fn(dataArray,lambda x: value if np.isinf(x) else x)\r\n    \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "fill_inf", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Fill inf", "units": null, "w": 179, "x": 505, "y": 312, "z": 1}, {"color": null, "definition": "def _fn(dataArray,value=0):\r\n    \"\"\"Fill np.inf and np.nan with default value\r\n        Ex.\r\n            fill_all(dataArray,0)\r\n    \"\"\"\r\n    return fill_inf(dataArray.fillna(value),value)\r\n    \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "fill_all", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Fill all", "units": null, "w": 179, "x": 505, "y": 349, "z": 1}, {"color": "#cb98ff", "definition": "def _fn( obj, applyFn, *args):\n    \"\"\" Apply \"applyFn\" to \"obj\" where obj can be DataArray or Index\n    \"\"\"\n    vfn = np.vectorize(applyFn)\n    if isinstance(obj,pd.Index):\n        \n        return pd.Index(np.unique(vfn(obj.values,*args)))\n        \n    if isinstance(obj,xr.DataArray):\n        return xr.apply_ufunc(vfn,obj,*args)\n    return None\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "apply_fn", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Apply", "units": null, "w": 179, "x": 107, "y": 238, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(start, periods, freq='M', format='%Y.%m'):\n    \"\"\"Add periods to a date. Can set freq and output format \n        Ex.\n            pp.addPeriods('2016.01',6)\n            pp.apply( pp.addPeriods, inicio_de_proyectos , duracin_de_proyectos)\n    \"\"\"\n    if \".\" in start:\n        start = start.replace('.', '-')\n    if periods<0:\n        return pd.period_range(end=start, periods=-periods+1, freq=freq).strftime(format)[0] \n    else:\n        return pd.period_range(start=start, periods=periods+1, freq=freq).strftime(format)[-1] \n   \n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "add_periods", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Add Periods", "units": null, "w": 179, "x": 505, "y": 386, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(nodeIdX, nodeIdObjective, goal=0, startValue=1, matrixIndex=None ): \n    \"\"\" Finds the value of nodeIdX that makes nodeIdObjective equal to goal.\n    nodeIdX: String with id of node X\n    nodeIdObjective: String with id of node X\n    matrixIndex: Index for multidimensional goal seek\n    \"\"\"\n    _aa=subscript\n    _getNodeFn = globals()[\"getNode\"]\n    from scipy.optimize import newton\n    \n    if matrixIndex is None:\n    \n        def _f(x):\n            _getNodeFn(nodeIdX).definition = \"result = \" + str(x)\n            value = _getNodeFn(nodeIdObjective).result\n            return value - goal\n        \n        _res = newton(_f, x0=startValue)\n        return _res\n        \n    else:\n        _indexName=matrixIndex.name\n        for item in years:\n            def _f(x):\n                _values = _getNodeFn(nodeIdX).result\n                _values.loc[{_indexName: slice(item, item)}] = x\n                np.set_printoptions(threshold = np.prod(_values.values.shape))\n                data = np.array2string(_values.values, separator=\",\", precision=20 , formatter={'float_kind':lambda x: repr(x)}).replace('\\n','')\n                _getNodeFn(nodeIdX).definition = f\"result = xr.DataArray({data},[{_indexName}])\"\n                value = _getNodeFn(nodeIdObjective).result\n                return subscript(value,matrixIndex,item)\n            _res = newton(_f, x0=1)\n\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "goal_seek", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Goal Seek", "units": null, "w": 179, "x": 306, "y": 460, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(rate, flow, time_index, offset = 1): \n    \"\"\"\"Returns the Net Present Value (NPV) of a cash flow with equally spaced periods. The flow parameter must contain a series of periodic payments (negative values) and inflows (positive values), indexed by time_index.\n        The optional offset parameter especifies the offset of the first value relative to the current time period. By default, offset is set to 1, indicating that the first value is discounted as if it is one step in the future\n    \"\"\"\n    _number_of_periods = get_pos(time_index) + offset \n    _present_values = flow / ( 1 + rate ) ** _number_of_periods \n    _npv = _present_values.sum(time_index.name ) \n    return _npv\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "npv", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "NPV", "units": null, "w": 179, "x": 505, "y": 423, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(flow, time_index ):\n    \"\"\"Returns the Internal Rate of Return (IRR) of a series of periodic payments (negative values) and inflows (positive values). The IRR is the discount rate at which the Net Present Value (NPV) of the flows equals zero. \n        The variable flow must be indexed by time_index.\n\n    If the cash flow never changes sign, cp.irr() has no solution and returns NAN (Not A Number).\n    \"\"\"\n    import pandas as pd\n    _getNodeFn = globals()[\"getNode\"]\n    \n\n    _rest_of_indexes_labels = np.setdiff1d( flow.dims, [time_index.name])\n\n    _cube = None\n    if len( _rest_of_indexes_labels ) == 0: \n        _cube = np.irr( flow.values ) \n    else:\n        _rest_of_indexes = [_getNodeFn(xx).result for xx in _rest_of_indexes_labels]\n        _cube = create_dataarray(0.,_rest_of_indexes)\n        _multivalues = [idx.values for idx in _rest_of_indexes] \n        _values = pd.MultiIndex.from_product( _multivalues ).values \n        \n        for _item in _values: \n            _filter = {}\n\n            for _nn in range(len(_item)): \n                _filter[ _rest_of_indexes[_nn].name ] = _item[_nn]\n                \n            _toIrr = flow.sel(_filter).values\n            _irr = np.irr( _toIrr ) \n            _cube.loc[_filter] = _irr\n\n\n    return _cube\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "irr", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "IRR", "units": null, "w": 179, "x": 107, "y": 460, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(investments, usefulLife, timeIndex, includeInCurrentMonth=False):\n    \"\"\" TODO: comment\n        investments: investments\n        usefulLife: useful life in years\n    \n        Ex.\n            linear_depreciation(investments, usefulLife)\n    \"\"\"\n    \n    timeCoords = xr.DataArray(timeIndex.values, [timeIndex])\n    _cuota = investments/usefulLife/12\n    _newTime = xr.DataArray( timeCoords.values, [('new_time',timeCoords.values ) ] )\n    _ending = apply_fn(timeCoords, add_periods, usefulLife*12)\n    if includeInCurrentMonth:\n        _proy = xr.where( (_newTime >= timeCoords) & (_newTime < _ending), _cuota , 0  )\n    else:\n        _proy = xr.where( (_newTime > timeCoords) & (_newTime <= _ending), _cuota , 0  )\n    _final = _proy.sum(timeIndex.name)\n    _final = _final.rename({\"new_time\":timeIndex.name})\n    return _final\n   \n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "linear_depreciation", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Linear depreciation", "units": null, "w": 179, "x": 107, "y": 423, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(dataArray, sortValues=True):\n    \"\"\"Generates a pd.Index with the unique values of the dataArray.\n    \"\"\"\n    np_values = dataArray.values.flatten()\n    \n    # Numpy unique function automatically reorders. Pandas unique, does not. \n    if sortValues is True:\n        return pd.Index(np.unique(np_values))\n    else:\n        return pd.Index(np_values).unique()\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "copy_index", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Copy Index", "units": null, "w": 179, "x": 505, "y": 460, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(source, targetId):\n    \"\"\"Copy values of datArray \"source\" into dataArray with id 'targetId'. This function alter the definition of dataArray with 'targetId' identifier.\n            source: dataArray/index from copy values\n            targetId: identifier (string) of the target node \n    \"\"\"\n    \n    _getNodeFn = globals()[\"getNode\"]\n\n    if isinstance(source,str):\n        source = self.node.model._getNodeFn(source).result\n\n\n    if not isinstance(source,xr.DataArray) and not isinstance(source,pd.Index) and not isinstance(source,float) and not isinstance(source,int):\n        raise ValueError(\"The 'source' parameter must be a xr.DataArray, pd.Index, float or int\")\n\n    if not isinstance(targetId,str):\n        raise ValueError(\"The 'targetId' parameter must be a string (identifier of node)\")\n    \n        \n    newDef = \"\"\n    if isinstance(source,float) or isinstance(source,int):\n        newDef = f\"result = {str(source)}\" \n    elif isinstance(source,xr.DataArray):\n        _indexes = str(list(source.dims)).replace(\"'\",'')\n        np.set_printoptions(threshold = np.prod(source.values.shape))\n        _data = np.array2string(source.values, separator=\",\", precision=20 , formatter={'float_kind':lambda x: repr(x)}).replace('\\n','')\n        newDef = f\"result = xr.DataArray({_data},{_indexes})\"\n    elif isinstance(source,pd.Index):\n        np.set_printoptions(threshold = np.prod(source.values.shape))\n        _data = np.array2string(source.values, separator=\",\", precision=20 , formatter={'float_kind':lambda x: repr(x)}).replace('\\n','')\n        newDef = f\"result = pd.Index({_data})\"\n    \n    _getNodeFn(targetId).definition = newDef\n    return True\n\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "copy_as_values", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Copy as values", "units": null, "w": 179, "x": 106, "y": 497, "z": 1}, {"color": "#cb98ff", "definition": "def _sequence(_start, _end, _step=1):\n   \"\"\"\n   Returns a pd.Index with the sequence between 'start' and 'end' parameters. Both limits are inclusive. Values are converted to string.\n   \"\"\"\n   \n   try:\n       _start = int(_start)\n       _end = int(_end) + 1\n       _step = int(_step)\n   except:\n       raise ValueError(\"Only numbers are allowed as 'start', 'end' and 'step' parameters\")\n   \n   _list = [str(x) for x in range(_start, _end, _step)]\n   _index = pd.Index(_list)\n   return _index\n\nresult = _sequence", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "sequence_index", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Sequence Index", "units": null, "w": 179, "x": 505, "y": 497, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(dataframe, domainDic, valueColumns, defaultValue = None, valueColumnsAsDim = True):\n    \"\"\" Returns a DataArray (valueColumns is string or (valueColumns is pd.Index and valueColumnsAsDim is True)) or Dataset (valueColumns is a list or (valueColumns is a pd.Index and valueColumnsAsDim is False)) from a Pandas dataframe applying the set_domain function.\n    dataframe: Pandas dataframe with no index columns.\n    domainDic: Dictionary of column names and index names. Ex. {'Column Name': index_name}.\n    valueColumns: String, list or pd.Index. Dataframe's value columns.\n    defaultValue: Default value when applying set_domain function.\n    valueColumnsAsDim: If True, valueColumns becomes a dimension of resulting DataArray. If False, each value column becomes a variable of the resulting Dataset.\n    \n    Ex. pandas_to_dataarray(sales_dataframe, {'Sales Channel': sales_channels, 'Market Segment': market_segments, 'Month': time}, 'Sales', 0.)\n    \"\"\"\n    _index_value_columns = None\n    \n    # Check if valueColumns is string, list, np.ndarray or pd.Index (transform to list) and indexes is dict.\n    if isinstance(valueColumns, pd.Index):\n        _index_value_columns = valueColumns.copy()\n        _index_value_columns_name = _index_value_columns.name\n        valueColumns = valueColumns.values.tolist()\n    elif isinstance(valueColumns, np.ndarray):\n        valueColumns = valueColumns.tolist()\n    elif not isinstance(valueColumns, str) and not isinstance(valueColumns, list):\n        raise ValueError(\"valueColumns must be a string, a list or a pd.Index\")\n    if not isinstance(domainDic, dict):\n        raise ValueError(\"Indexes must be a dictionary\")\n    \n    \n    # Transform indexes into list and create list with all columns.\n    _index_cols = list(domainDic.keys())\n    _cols = _index_cols.copy()\n    \n    if isinstance(valueColumns, list):\n        _cols = _cols + valueColumns\n    else:\n        _cols.append(valueColumns)\n    \n    # If valueColumnsAsDim is True, check if every column is in dataframe and filter it.\n    if (valueColumnsAsDim is True) and isinstance(_index_value_columns, pd.Index):\n        _df_columns = dataframe.columns.values.tolist()\n        _cols = [value for value in _df_columns if value in _cols]\n    \n    # Filter dataframe by columns.\n    _df = dataframe[_cols]\n    \n    # Remove duplicate index values from dataframe.\n    _duplicate_rows =_df.duplicated(_index_cols)\n    _df = _df[~_duplicate_rows]\n    \n    # If valueColumnsAsDim is True, melt valueColumns.\n    if (valueColumnsAsDim is True) and isinstance(_index_value_columns, pd.Index):\n        # Unpivot dataframe from wide format to long format by valueColumns.\n        _df = pd.melt(_df, id_vars = _index_cols, value_vars = _index_value_columns, var_name = _index_value_columns_name, value_name = 'values')\n        _index_cols = _index_cols + [_index_value_columns_name]\n        domainDic[_index_value_columns_name] = _index_value_columns\n        \n        # Create DataArray\n        _data = _df.set_index(_index_cols)['values'].to_xarray()\n        \n        # Appy set_domain function to DataArray / Dataset.\n        _data = set_domain(_data, domainDic, defaultValue)\n    else:\n        # Create DataArray / Dataset.\n        _data = _df.set_index(_index_cols)[valueColumns].to_xarray()\n        \n        # Appy set_domain function to DataArray / Dataset.\n        _data = set_domain(_data, domainDic, defaultValue)\n        \n    return _data\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "dataarray_from_pandas", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "DataArray from Pandas", "units": null, "w": 179, "x": 306, "y": 349, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(dataArray, targetValue, targetIndex, method = 'Last'):\n    \"\"\" Returns a dataArray containing the value of targetIndex for which dataArray (indexed by targetIndex) is equal to targetValue.\n    dataArray: Xarray dataArray.\n    targetValue: Integer, Float or String.\n    targetIndex: Pandas Index.\n    method: There are two options: \"Last\" returns the last occurrence of targetIndex for which dataArray is equal to targetValue. \"First\" returns the first occurrence.\n    \"\"\"\n    \n    # Equals dataArray to targetValue and cumulates it along targetIndex.\n    _matriz_1_0 = xr.where(dataArray == targetValue, 1, 0)\n    _matriz_1_0_acum = xr.where(_matriz_1_0 == 1, _matriz_1_0.cumsum(targetIndex.name), 0)\n    \n    if method == 'Last':\n        # Get max cumulated value along targetIndex\n        _max = _matriz_1_0_acum.max(targetIndex.name)\n        _max = xr.where(_max == 0, np.nan, _max)\n        _matriz_max = xr.where(_matriz_1_0_acum == _max, to_dataarray(targetIndex), np.nan)\n        return _matriz_max.max(targetIndex.name)\n    elif method == 'First':\n        # Get min (1) cumulated value along targetIndex\n        _matriz_min = xr.where(_matriz_1_0_acum == 1, to_dataarray(targetIndex), np.nan)\n        return _matriz_min.max(targetIndex.name)\n    else:\n        raise ValueError(\"Insert a valid method\")\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "subindex", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Subindex", "units": null, "w": 179, "x": 700, "y": 90, "z": 1}, {"color": "#cb98ff", "definition": "def _concat_rows(array_param, index_param):\n   _index = pd.Index([])\n   for i in index_param.values:\n       _index = concat_index(_index , pd.Index(array_param.sel({index_param.name:i}, drop=True).values))\n   return _index\n\nresult = _concat_rows", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "concat_rows", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Concat Rows", "units": null, "w": 179, "x": 700, "y": 127, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(fig, **kwargs):\n    \"\"\"\n        Generate HTML with plotly chart\n        Params:\n            fig: Pandas Dataframe , DataArray, or plotly fig\n            x: column for the x axis\n            y: column for the y axis\n            series: column or list of columns for de series,\n\n            other params:  layout,kind='scatter', title='', xTitle='', yTitle='', zTitle='', theme=None, colors=None, colorscale=None, fill=False, width=None, mode='lines', symbol='dot', size=12, barmode='', sortbars=False, bargap=None, bargroupgap=None, bins=None, histnorm='', histfunc='count', orientation='v', boxpoints=False, annotations=None, keys=False, bestfit=False, bestfit_colors=None, categories='', x='', y='', z='', text='', gridcolor=None, zerolinecolor=None, margin=None, subplots=False, shape=None, asFrame=False, asDates=False, asFigure=False, asImage=False, dimensions=(1116, 587), asPlot=False, asUrl=False, online=None, **kwargs\n    \"\"\"\n    import plotly\n    import plotly.graph_objs as go\n    import cufflinks as cf\n\n    defaultLayout = go.Layout(\n                autosize=False,\n                margin={\n                    \"l\":30,\n                    \"r\":20,\n                    \"t\":20,\n                    \"b\":25\n                },\n    )\n\n    if isinstance(fig,pd.DataFrame):\n        if \"series\" in kwargs:\n            vals=None\n            if \"y\" in kwargs:\n                vals = kwargs[\"y\"]\n            elif \"value\" in fig.columns:\n                vals = \"value\"\n            xValues = None\n            if \"x\" in kwargs:\n                xValues = kwargs[\"x\"]\n                del kwargs[\"x\"]\n            fig = pd.pivot_table( fig.reset_index(), values=vals, index=xValues, columns=kwargs[\"series\"])\n            del kwargs[\"series\"]\n\n\n        if \"layout\" in kwargs:\n            kwargs[\"layout\"][\"autosize\"] = True\n            if not \"margin\" in kwargs[\"layout\"]:\n                kwargs[\"layout\"][\"margin\"] = defaultLayout[\"margin\"]\n        else:\n            kwargs[\"layout\"] = defaultLayout\n\n        fig = fig.iplot(asFigure=True,**kwargs)\n\n    elif isinstance(fig,xr.DataArray):\n        return _fn( fig.to_series(),**kwargs)\n    else:\n        if isinstance(fig,list):\n            fig = {\"data\":fig}\n\n        if \"layout\" in fig:\n            fig[\"layout\"][\"autosize\"] = True\n            fig[\"layout\"][\"margin\"] = defaultLayout[\"margin\"]\n        else:\n            fig[\"layout\"] = defaultLayout\n            \n\n\n    div = plotly.offline.plot(fig,\n                                    show_link=False,\n                                    link_text=\"\",\n                                    include_plotlyjs=False,\n                                    output_type=\"div\")\n    return div\n\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "plot", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Plot", "units": null, "w": 179, "x": 700, "y": 164, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(task_state=\"PROGRESS\",task_description=None,task_activity=None, task_info=None):\n    \"\"\"\n        Generate log entry. Used for schedule tasks\n        params:\n          task_state: PROGRESS, INFO, WARNING, FAILURE, RETRY, SUCCESS, REVOKED, STARTED, PENDING, RECEIVED\n          task_description: Shot description of task. example: start process\n          task_activity: other short description\n          task_info: json with more info \n    \"\"\"\n\n    import requests\n    from os import environ\n    import json\n    _params = {\n            \"state\": task_state,\n            \"description\": task_description,\n            \"activity\": task_activity,\n            \"info\": json.dumps(task_info)}\n    \n    res=None\n\n    if task_log_endpoint:\n        base_host = environ['PYPLAN_API_HOST'] + task_log_endpoint\n        res = requests.post(base_host, data=_params)\n    else:\n        print(str(_params))\n        \n    return res\n\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "log_task", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"py/object": "app.classes.NodeInfo.NodeInfo", "fill": 1, "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0, "__dict__": {}}, "originalId": null, "picture": null, "title": "Log Task", "units": null, "w": 179, "x": 700, "y": 201, "z": 1}]}