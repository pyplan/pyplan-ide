{"modelProp": {}, "nodeList": [{"color": null, "definition": "result = 0", "description": null, "errorInDef": false, "extraData": null, "h": "50", "identifier": "financial_planning_library", "moduleId": "_model_", "nodeClass": "model", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Financial Planning Library", "units": null, "w": "100", "x": 100, "y": 100, "z": 1}, {"color": null, "definition": "import numpy, pandas, cubepy, xarray\n#fill the following dict keys with the alias you want to define for each Library\nresult = {\n    \"np\":numpy,\n    \"pd\":pandas,\n    \"cubepy\":cubepy,\n    \"xr\":xarray\n}", "description": null, "errorInDef": false, "extraData": null, "h": "50", "identifier": "imports", "moduleId": "pyplan_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Default imports", "units": null, "w": "100", "x": 103, "y": 190, "z": 1}, {"color": "#9FC5E8", "definition": "", "description": null, "errorInDef": false, "extraData": null, "h": "35", "identifier": "novix_library", "moduleId": "financial_planning_library", "nodeClass": "module", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Novix Library", "units": null, "w": "168", "x": 32, "y": 433, "z": 1}, {"color": "#EEEEEE", "definition": "result = 0", "description": "Novix Library - 28.10.2019", "errorInDef": false, "extraData": null, "h": 706, "identifier": "node41_copy", "moduleId": "novix_library", "nodeClass": "text", "nodeFont": "Helvetica,21", "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 0, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 1}, "originalId": null, "picture": null, "title": null, "units": null, "w": 1016, "x": 39, "y": 58, "z": "-4"}, {"color": "#6FA8DC", "definition": "result = create_time( '2019.01', '2024.12', freq='M', format='%Y.%m' )", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "totaltime", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Totaltime", "units": null, "w": "154", "x": 76, "y": 175, "z": 1}, {"color": null, "definition": "result = choice( totaltime,1, includeAll=False ) ", "description": null, "errorInDef": false, "extraData": null, "h": "33", "identifier": "initial_modeling_year", "moduleId": "novix_library", "nodeClass": "decision", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Initial Modeling Year", "units": null, "w": "266", "x": 72, "y": 97, "z": 1}, {"color": null, "definition": "result = choice( decembers ,6)", "description": null, "errorInDef": false, "extraData": null, "h": "33", "identifier": "time_horizon", "moduleId": "novix_library", "nodeClass": "decision", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Time Horizon", "units": null, "w": "266", "x": 365, "y": 93, "z": 1}, {"color": "#6FA8DC", "definition": "_mes12 = totaltime.where( totaltime.str[5:]=='12')\nresult = _mes12.dropna()\n\n\"\"\"\n_array_totaltime = pp.cube( totaltime, totaltime.values )\n_mes = pp.apply( _array_totaltime, lambda x: x[5:] )\n\nresult = pp.subset( _mes == '12' )\n\"\"\"", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "decembers", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Decembers", "units": null, "w": "154", "x": 222, "y": 175, "z": 1}, {"color": "#6FA8DC", "definition": "result = pd.Index(create_time( initial_modeling_year, time_horizon, freq='M', format='%Y' ).unique())\n\n", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "years", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Years", "units": null, "w": "154", "x": 76, "y": 206, "z": 1}, {"color": "#4CBCFF", "definition": "result = month(time)", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "time_month", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Time Month", "units": null, "w": "184", "x": 372, "y": 455, "z": 1}, {"color": "#6FA8DC", "definition": "result = pd.Index( np.unique( split_text( totaltime,\".\")[0].values))\n", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "totalyears", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Total Years", "units": null, "w": "154", "x": 509, "y": 302, "z": 1}, {"color": "#6FA8DC", "definition": "result = pd.Index(['Base Case', 'New Product', 'Capacity Increase'])", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "scenarios", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Scenarios", "units": null, "w": "154", "x": 365, "y": 175, "z": 1}, {"color": "#6FA8DC", "definition": "result = time_horizon", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "max_time", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Max Time", "units": null, "w": "154", "x": 222, "y": 206, "z": 1}, {"color": "#6FA8DC", "definition": "result = initial_modeling_year", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "min_time", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Min Time", "units": null, "w": "154", "x": 365, "y": 206, "z": 1}, {"color": "#6FA8DC", "definition": "result = np.asscalar(\n    subset( get_pos(totaltime) == ( totaltime.values.size - 1 ) ).values\n    )", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "max_totaltime", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Max Totaltime", "units": null, "w": "154", "x": 509, "y": 270, "z": 1}, {"color": "#6FA8DC", "definition": "result = np.asscalar(\n    subset( get_pos(totaltime) == 0 ).values\n    )", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "min_totaltime", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Min Totaltime", "units": null, "w": "154", "x": 654, "y": 175, "z": 1}, {"color": "#4CBCFF", "definition": "result = time_month.astype(str)", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "season_to_time", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Season to Time", "units": null, "w": "184", "x": 372, "y": 496, "z": 1}, {"color": "#4CBCFF", "definition": "result = year_to_time.astype(int)", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "years_to_time_numeric", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Years to Time (numeric)", "units": null, "w": "184", "x": 372, "y": 417, "z": 1}, {"color": "#4CBCFF", "definition": "result = time_month.astype(str)", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "time_month_text", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Time Month (text)", "units": null, "w": "184", "x": 582, "y": 455, "z": 1}, {"color": "#6FA8DC", "definition": "_quarters = []\n\nfor year in years.values:\n    for quarter in range(1,5):\n        _quarters.append( year + '.Q' + str(quarter))\n\nif initial_modeling_year[5:] == '12':\n    _quarters_ok = _quarters[3:]\nelse:\n    _quarters_ok = _quarters\n    \nresult = pd.Index( _quarters_ok )", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "quarters", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Quarters", "units": null, "w": "154", "x": 222, "y": 302, "z": 1}, {"color": "#6FA8DC", "definition": "_semesters = []\n\nfor year in years.values:\n    for semester in range(1,3):\n        _semesters.append( year + '.S' + str(semester))\n\nif initial_modeling_year[5:] == '12':\n    _semesters_ok = _semesters[1:]\nelse:\n    _semesters_ok = _semesters\n    \nresult = pd.Index( _semesters_ok )", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "semesters", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Semesters", "units": null, "w": "154", "x": 76, "y": 302, "z": 1}, {"color": "#4CBCFF", "definition": "_time = xr.DataArray( time.values,[time] )\n\nresult = apply_fn(_time, lambda x: x[:4] + '.Q1' if int(x[5:]) <= 3 else x[:4] + '.Q2' if int(x[5:]) <= 6 else x[:4] + '.Q3' if int(x[5:]) <= 9 else x[:4] + '.Q4' )", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "time_to_quarter", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Time to Quarter", "units": null, "w": "184", "x": 582, "y": 372, "z": 1}, {"color": "#4CBCFF", "definition": "_time = xr.DataArray( time.values,[time] )\n\nresult = apply_fn(_time, lambda x: x[:4] + '.S1' if int(x[5:]) <= 6 else x[:4] + '.S2' )", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "time_to_semester", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Time to Semester", "units": null, "w": "184", "x": 372, "y": 614, "z": 1}, {"color": "#6FA8DC", "definition": "result = create_time( '2015.01', initial_modeling_year, freq='M', format='%Y.%m' )", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "historic_time", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Historic Time", "units": null, "w": "154", "x": 509, "y": 238, "z": 1}, {"color": "#6FA8DC", "definition": "result = concat_index( historic_time, time ) ", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "historic_projected_time", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Historic & Projected Time", "units": null, "w": "154", "x": 365, "y": 270, "z": 1}, {"color": "#6FA8DC", "definition": "result = subset( get_pos(time) > 0 )", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "projected_time", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Projected Time", "units": null, "w": "154", "x": 222, "y": 270, "z": 1}, {"color": "#4CBCFF", "definition": "result = np.asscalar( subset( get_pos(projected_time) == 0 ).values )", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "first_projected_month", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "First Projected Month", "units": null, "w": "184", "x": 582, "y": 577, "z": 1}, {"color": "#4CBCFF", "definition": "if pmk_per_capita_cons_method == 'Input':\n    if selected_scenario != 'All':\n        result = pp.cube( time )\n    else:\n        result = pp.cube( [time, scenarios] )\nelif selected_scenario != 'All':\n    result = pp.cube( [time, iterations] )\nelse:\n    result = pp.cube( [time, iterations, scenarios] )\n\n# Hago esto para evitar problemas con dynamic.", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "empty_cube_time_scenarios_iterations", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Empty Cube with Time, Scenarios and Iterations", "units": null, "w": "184", "x": 372, "y": 652, "z": 1}, {"color": "#4CBCFF", "definition": "result = max(historic_time.values)", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "last_historical_month", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Last Historical Month", "units": null, "w": "184", "x": 584, "y": 614, "z": 1}, {"color": "#cb98ff", "definition": "def Sea_to_timefunction(variable):\n    return lookup( variable, time_month.astype(str), season )\n\nresult = Sea_to_timefunction", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "sea_to_time", "moduleId": "novix_library", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Season to Time", "units": null, "w": "176", "x": 91, "y": 516, "z": 1}, {"color": "#cb98ff", "definition": "def _annualise(Variable, Time_Index ,Year_Index  ,Chosen_month_for_stock = 0):\n    \n    \n    # Convierte en texto y agrega el 0 delante de los menores de 10     \n    _month_to_find = str(Chosen_month_for_stock).zfill(2)\n    \n    # Marca el mes escogido    \n    _marks_the_month_to_find = find(_month_to_find, Time_Index,3)\n    \n    # Al aplicar Lambda se aplica la funci\u00f3n a cada elemento del indice. la segunda parte es quedarnos con el elemento de 0 hasta el 4 del indice totaltime y me quedo con el mapa total y luego uso parte de \u00e9l, lo construyo aca adentro para que dependa del los indices definidos en la funcion\n    _timearray = xr.DataArray( Time_Index.values, [Time_Index] )\n   \n    _total_map = apply_fn(_timearray, lambda x: x[:4]) \n    \n    # Marca solamente un mes en el mes escogido  \n    _map_for_sele_month = xr.where( _marks_the_month_to_find, _total_map, create_dataarray( 0., [Time_Index]))\n    \n    # Mapa final a aplicar dependiendo de si es suma o stock en el mes  indicado\n    _map = xr.where(Chosen_month_for_stock == 0 ,_total_map,_map_for_sele_month)\n    \n    \n    # Aggregate final resultante\n    return  aggregate( Variable, _map, Time_Index, Year_Index )\n    \nresult = _annualise", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "annualise", "moduleId": "novix_library", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Annualise", "units": null, "w": "176", "x": 91, "y": 483, "z": 1}, {"color": "#6FA8DC", "definition": "_list = list( range(1, 13) )\n\nresult = pd.Index( [str(item) for item in _list] )", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "season", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Season", "units": null, "w": "154", "x": 365, "y": 302, "z": 1}, {"color": "#cb98ff", "definition": "def evatimefunction(variable):\n    return change_index(variable,totaltime,time)\n\nresult = evatimefunction", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "evatime", "moduleId": "novix_library", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Evatime", "units": null, "w": "176", "x": 96, "y": 553, "z": 1}, {"color": "#cb98ff", "definition": "def evayearsfunction(variable):\n    return change_index(variable,totalyears,years)\n\nresult = evayearsfunction", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "evayears", "moduleId": "novix_library", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Evayears", "units": null, "w": "176", "x": 96, "y": 593, "z": 1}, {"color": "#cb98ff", "definition": "#Aggregates Days into time index\ndef _Days_to_time_function(Data_array_in_days,days_index,time_index):\n    _da = xr.DataArray( days_index.values, [days_index] )\n    _Days_to_time_maps=apply_fn(_da, lambda x: x[6:10]+\".\"+x[3:5]).astype(str)\n    return  aggregate(Data_array_in_days, _Days_to_time_maps, days_index, time_index )\n\nresult =_Days_to_time_function\n", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "days_to_time", "moduleId": "novix_library", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Days to time (or Totaltime)", "units": null, "w": "176", "x": 90, "y": 452, "z": 1}, {"color": "#4CBCFF", "definition": "result = get_pos( totaltime) + 1", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "pos_totaltime", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Pos Totaltime", "units": null, "w": "184", "x": 372, "y": 535, "z": 1}, {"color": "#6FA8DC", "definition": "# el apply y lambda lo que hace es aplicar a cada elemento la funcion de convertir en string por eso mantiene el orden el lamda se usa para eso muy efectivante\nresult =pd.Index(pos_totaltime.astype(str))", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "help_read_totaltime", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Help Read Totaltime", "units": null, "w": "154", "x": 509, "y": 206, "z": 1}, {"color": "#6FA8DC", "definition": "result = pd.Index(['Enero', 'Febrero', 'Marzo','Abril', 'Mayo', 'Junio','Julio', 'Agosto', 'Septiembre','Octubre', 'Noviembre', 'Diciembre'])", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "meses", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Meses", "units": null, "w": "154", "x": 654, "y": 206, "z": 1}, {"color": "#4CBCFF", "definition": "result = (meses.pos + 1)", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "meses_a_time_month", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Meses to Time_Month", "units": null, "w": "184", "x": 372, "y": 577, "z": 1}, {"color": "#cb98ff", "definition": "def _pandas_exp(Cube_with_data,NewColumn=None, DefaultValue=None):\n    _df = (Cube_with_data.to_dataframe( name='value' )).reset_index()\n    _df_sin_ceros = _df[_df['value'] != 0]\n    \n    if NewColumn==None:\n        _df_final = _df_sin_ceros\n    else:\n        _df_final = _df_sin_ceros.insert(0,NewColumn,DefaultValue)\n    \n    return  _df_sin_ceros\n     \nresult = _pandas_exp\n", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "nvx_smart_pandas", "moduleId": "novix_library", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Smart Pandas", "units": null, "w": "176", "x": 833, "y": 436, "z": 1}, {"color": "#cb98ff", "definition": "def _round(Cube,Decimals):\n    \n    _cube_rounded= Cube.apply(lambda x: round(x,Decimals))\n    return  _cube_rounded\n     \nresult = _round\n    ", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "nvx_round", "moduleId": "novix_library", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Round for Scalars", "units": null, "w": "176", "x": 833, "y": 477, "z": 1}, {"color": "#cb98ff", "definition": "def _safe_div(x,y):\n    if y == 0:\n        return 0\n    return x / y\n    \nresult = _safe_div", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "nvx_safe_int_div", "moduleId": "novix_library", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Safe Scalar Division", "units": null, "w": "176", "x": 833, "y": 516, "z": 1}, {"color": "#6FA8DC", "definition": "result =  create_time('2019.01.01','2024.12.31',freq='D',format='%d/%m/%Y')", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "days", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Days", "units": null, "w": "154", "x": 76, "y": 270, "z": 1}, {"color": "#cb98ff", "definition": "# Reads mutiple sheets from and Excel same structure\ndef _smart_lecture (Excel_dsn, sheet_list):\n    \n    _total_book =  pd.DataFrame()\n    for range_name_from_book in sheet_list.values:\n        _lectura = pp.pandasFromExcel(Excel_dsn, namedRange = range_name_from_book )\n        _total_book = _total_book.append(_lectura) # Append de hoja por hoja\n    return _total_book\nresult = _smart_lecture", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "nvx_read_multi_sheets", "moduleId": "novix_library", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Read Multiple Excel Spreadsheets", "units": null, "w": "176", "x": 833, "y": 394, "z": 1}, {"color": "#cb98ff", "definition": "#Opposite of days to time Repeates time infomration in day index\ndef _time_to_days(dayIndex,month_index, monthlyArray):\n  _da = xr.DataArray( dayIndex.values, [dayIndex]) \n  _mapa_dias_mes= apply_fn(_da, lambda x: x[6:10]+\".\"+x[3:5]).astype(str)\n  \n  return lookup( monthlyArray, _mapa_dias_mes, month_index )\nresult = _time_to_days\n", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "time_to_days", "moduleId": "novix_library", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Times to days", "units": null, "w": "176", "x": 96, "y": 628, "z": 1}, {"color": "#44BFE4", "definition": "result = 0", "description": null, "errorInDef": false, "extraData": null, "h": "80", "identifier": "aa8059087baa1497cb66f9bde84261fcf", "moduleId": "novix_library", "nodeClass": "text", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 0, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 0, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": "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", "title": null, "units": null, "w": "196", "x": 1042, "y": 51, "z": -1}, {"color": "#6FA8DC", "definition": "result = years.values[-1]", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "max_years", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Max Years", "units": null, "w": "154", "x": 76, "y": 238, "z": 1}, {"color": "#6FA8DC", "definition": "result = years.values[0]", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "min_years", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Min Years", "units": null, "w": "154", "x": 222, "y": 238, "z": 1}, {"color": "#6FA8DC", "definition": "#Trick for generating reg Years from Total Years automatically\n#_Tye_as_d_array =  totalyears.dataArray\n_Tye_as_d_array = xr.DataArray( totalyears.values, [totalyears]  )\n_shifted_year = dynamic(_Tye_as_d_array, totalyears, 1,_Tye_as_d_array[-1])\n\nresult = pd.Index(_Tye_as_d_array +\"/\"+ _shifted_year)", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "total_reg_years", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Total Regulatory Years", "units": null, "w": "154", "x": 365, "y": 238, "z": 1}, {"color": "#6FA8DC", "definition": "result = subset(split_text(total_reg_years, \"/\" )[0] <=max_years)", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "reg_years", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Regulatory Years", "units": null, "w": "154", "x": 509, "y": 175, "z": 1}, {"color": "#CCCCCC", "definition": "result = 0", "description": "Indexes (Only Indexes in Orange need to be defined when starting to build a model, the rest are going to be automatically calculated)", "errorInDef": false, "extraData": null, "h": "192", "identifier": "a4cd609dc4ebe4f53934887d372ee8c90", "moduleId": "novix_library", "nodeClass": "text", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 0, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": null, "units": null, "w": "998", "x": 49, "y": 149, "z": -1}, {"color": "#CCCCCC", "definition": "result = 0", "description": "Novix Functions - Other Functions", "errorInDef": false, "extraData": null, "h": 395, "identifier": "a4cd609dc4ebe4f53934887d372ee8c90_copy_copy", "moduleId": "novix_library", "nodeClass": "text", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 0, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": null, "units": null, "w": 241, "x": 805, "y": 347, "z": -1}, {"color": "#4CBCFF", "definition": "_array_time = xr.DataArray( time.values, [time]  )\nresult = apply_fn( _array_time, lambda x: x[:4] )\n", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "year_to_time", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Years to Time", "units": null, "w": "184", "x": 372, "y": 372, "z": 1}, {"color": "#6FA8DC", "definition": "result = create_time( initial_modeling_year, time_horizon, freq='M', format='%Y.%m' )\n\n\n", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "time", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Time", "units": null, "w": "154", "x": 654, "y": 238, "z": 1}, {"color": null, "definition": "def _fn(time_index):\n    \"\"\"Returns month of a time index as an Integer\n    \"\"\"\n    _function = lambda x: int(x[5:])\n    vfunc = np.vectorize(_function)\n\n    return xr.DataArray( vfunc(time_index.values), [time_index] ) \n    \nresult = _fn\n", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "month", "moduleId": "novix_library", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Month", "units": null, "w": "176", "x": 91, "y": 378, "z": 1}, {"color": null, "definition": "def _fn( dataArray, yearsIndex, timeIndex, div=1 ):\n        \"\"\" Convert dataArray indexed by anual index to a monthly index\n        dataArray are the dataArray with annual values to be converted\n        yearIndex: is the year index of the original matrix\n        timeIndex: is the monthly index of the result\n        div: is an optional parameter used as divisor of the annual values (the tipical value is 12)\n        \"\"\"\n        _array_time = to_dataarray(timeIndex)\n        _map = apply_fn( _array_time, lambda x: x[:4] )\n        _year_to_time = lookup( dataArray, _map, yearsIndex, defaultValue=0 ) / div\n        return _year_to_time\n        \nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "years_to_time", "moduleId": "novix_library", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Years to time", "units": null, "w": "176", "x": 91, "y": 415, "z": 1}, {"color": "#A5FF4B", "definition": "result = initial_modeling_year", "description": null, "errorInDef": false, "extraData": null, "h": "33", "identifier": "a7d812a21c0ec4cea845989fb5164a56c", "moduleId": "novix_library", "nodeClass": "formnode", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": "initial_modeling_year", "picture": null, "title": "Initial Modeling Year", "units": null, "w": "266", "x": 70, "y": 97, "z": 1}, {"color": "#A5FF4B", "definition": "result = time_horizon", "description": null, "errorInDef": false, "extraData": null, "h": "33", "identifier": "a02d17e74b4e54261ba7350d95b8374c3", "moduleId": "novix_library", "nodeClass": "formnode", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": "time_horizon", "picture": null, "title": "Time Horizon", "units": null, "w": "266", "x": 365, "y": 93, "z": 1}, {"color": "#CCCCCC", "definition": "result = 0", "description": "Novix Functions - Related with Time", "errorInDef": false, "extraData": null, "h": 395, "identifier": "a4cd609dc4ebe4f53934887d372ee8c90_copy_copy_copy_copy", "moduleId": "novix_library", "nodeClass": "text", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 0, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": null, "units": null, "w": 287, "x": 52, "y": 347, "z": -1}, {"color": "#CCCCCC", "definition": "result = 0", "description": "Novix Other Functions - Related with Time", "errorInDef": false, "extraData": null, "h": 395, "identifier": "a4cd609dc4ebe4f53934887d372ee8c90_copy_copy_copy_copy_copy", "moduleId": "novix_library", "nodeClass": "text", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 0, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": null, "units": null, "w": 437, "x": 351, "y": 347, "z": -1}, {"color": "#4CBCFF", "definition": "_help_days = xr.DataArray([31,28,31,30,31,30,31,31,30,31,30,31],[season])\n_condicion1 = time_month_text == '2'\n_condicion2 = ((years_to_time_numeric - 2000) / 4) == xr.ufuncs.ceil((years_to_time_numeric - 2000) / 4)\n\nresult = xr.where( _condicion1 & _condicion2, 29, lookup( _help_days, time_month_text, season) )", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "dem_rp_days_per_month", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Days per Month", "units": null, "w": "184", "x": 582, "y": 417, "z": 1}, {"color": "#CB98FF", "definition": "result = dem_rsgp_x_ti_fac_y_unidad", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "a7c4bea4a35d2492a9f52dcf31363be11", "moduleId": "novix_library", "nodeClass": "alias", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": "dem_rsgp_x_ti_fac_y_unidad", "picture": null, "title": "Venta Mensual R_SGP x  Unidad", "units": null, "w": "168", "x": "799", "y": "732", "z": 1}, {"color": "#4CBCFF", "definition": "result = get_pos( days) + 1", "description": null, "errorInDef": false, "extraData": null, "h": "34", "identifier": "get_pos_days", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Get Pos Days", "units": null, "w": "180", "x": 584, "y": 494, "z": 1}, {"color": "#9999ff", "definition": "result = pd.Index( [x for x in range(1, len(days)+1)]).astype(str) ", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "help_read_days", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": null, "units": null, "w": "154", "x": 656, "y": 302, "z": 1}, {"color": "#9999ff", "definition": "result =pd.Index(get_pos_years.astype(str))", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "help_read_years", "moduleId": "novix_library", "nodeClass": "index", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Help Read Years", "units": null, "w": "154", "x": 656, "y": 271, "z": 1}, {"color": "#4CBCFF", "definition": "result = get_pos(years) + 1", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "get_pos_years", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Get Pos Years", "units": null, "w": "184", "x": 584, "y": 652, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(demand,ranges,consumption_range_index=None):\n    \n    if consumption_range_index is None:\n        if ranges.ndim==1:\n            consumption_range_index = ranges.dims[0]\n        else:\n            raise ValueError(\"You must specify the consumption_range_index\")\n    elif isinstance(consumption_range_index,pd.Index):\n        consumption_range_index = consumption_range_index.name\n\n    vol_entre_lim = ranges - ranges.shift(shifts={consumption_range_index:1}).fillna(0)\n    ConsumoBajoLimite = (ranges<demand)*vol_entre_lim\n\n    ConsEnRangos = (demand>ranges)*1\n    ultrango = (ConsEnRangos - ConsEnRangos.shift({consumption_range_index:1}).fillna(1))==-1\n    ConsumoLimite = (demand - ConsumoBajoLimite.sum(consumption_range_index)) * ultrango\n    return ConsumoBajoLimite + ConsumoLimite\n    \n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "cascade_volume", "moduleId": "novix_library", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Cascade Volume", "units": null, "w": "176", "x": 833, "y": 606, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(contract_vol, contract_price, contract_index, demand):\n\n    _order_index = pd.Index(list(range(len(contract_index))), name=\"order\")\n    _da_order_index = to_dataarray(_order_index)\n    _index_position = contract_price.dims.index(contract_index.name)\n    _contract_order = (contract_price.argsort(axis=_index_position)).argsort(axis =_index_position)\n    _vol_by_dispatch_order = (_contract_order==_da_order_index)*contract_vol\n    _cum_vol = _vol_by_dispatch_order.cumsum(\"order\").sum(contract_index.name)\n    _cascade = cascade_volume(demand,_cum_vol,_order_index)\n    return (_cascade *  (_contract_order==_da_order_index)).sum(_order_index.name) \n\n    \nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 30, "identifier": "dispatch", "moduleId": "novix_library", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Dispatch", "units": null, "w": 176, "x": 832, "y": 699, "z": 1}, {"color": "#4CBCFF", "definition": "result = create_dataarray( 0., [time])", "description": null, "errorInDef": false, "extraData": null, "h": "32", "identifier": "nvx_example_using_create_table", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Example using Create table ", "units": null, "w": "166", "x": 837, "y": 557, "z": 1}, {"color": "#4CBCFF", "definition": "result = evatime(pos_totaltime)", "description": null, "errorInDef": false, "extraData": null, "h": "30", "identifier": "postime", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Postime", "units": null, "w": "184", "x": 582, "y": 535, "z": 1}, {"color": "#EEEEEE", "definition": "result = 0", "description": "Sandbox for your Financial Planning Model \n(Financial Planning Library incorporated)", "errorInDef": false, "extraData": null, "h": "374", "identifier": "node41_copy_1", "moduleId": "financial_planning_library", "nodeClass": "text", "nodeFont": "Helvetica,21", "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 0, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 1}, "originalId": null, "picture": null, "title": null, "units": null, "w": "1237", "x": 22, "y": 20, "z": "-4"}, {"color": "#d9ead3", "definition": "", "description": "Please change Model Name and Id before starting developing your own model", "errorInDef": false, "extraData": null, "h": "33", "identifier": "a21b9e7cfe629403f885a4e709a4b62d1", "moduleId": "financial_planning_library", "nodeClass": "text", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 0, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": null, "units": null, "w": "495", "x": 35, "y": 212, "z": -1}, {"color": "#ffffff", "definition": "", "description": null, "errorInDef": false, "extraData": null, "h": "357", "identifier": "a603716303948487bb517c96a7794c6d0", "moduleId": "financial_planning_library", "nodeClass": "text", "nodeFont": "", "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 0, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA1cAAAHGCAYAAACYZ3E/AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAIkYSURBVHhe7b0HvJVVeqg/997ckntvbpKbfyb1pkwyk0mbJDOZmWQmZXpmRqfaHdvYe+8gKlIEBQsoRZFeFEEUVEBARJAqgoD0Lr0X6fD+97P2+XC73cABDof9HZ+H3/s7e39lfesrh7Oe/a619qdCRKqaNWvWxO7du2veiYiIiEi1olyJVDnKlYiIiEg+UK5EqhzlSkRERCQfKFciVY5yJSIiIpIPlCuRKke5EhEREckHypVIlaNciYiIiOQD5UqkylGuRERERPKBciVS5ShXIiIiIvlAuRKpcpQrERERkXygXIlUOcqViIiISD5QrkSqHOVKREREJB8oVyJVzpHkauzYsXH11VenuOaaaw4Zl156aQwdOjT27dtXs2fErl274oMPPvjIsnImTpwYq1atigMHDtQsEREREZFKKFciVc6R5Oq+++6Lrl27xqJFi2LZsmUVY+XKldGoUaPo2LHjR8p66aWX4oorroj58+fXLPk4zz77bMyePTv2799fs0REREREKqFciVQ5R5Kriy66KBYuXHjEzNItt9wSb7755keyVKtXr47evXunZW+88UY8+eST0a5du9ixY0csXrw4WrZsGddee20St6VLl0bbtm1jwIABMWbMmBg3blxaNnLkyNizZ09NiSIiIiKfXJQrkSrncHK1ZMmSuOSSS1LXvsOxc+fO1G1w7ty5H5EwMlo9e/aMvXv3RqdOnWLChAnpffaTjBbyNWvWrCReDz30UNx0000xefLk6NatWzz++OOxYMECuwyKiIiIFFCuRKqcw8nVkCFDolmzZmns1OFYvnx5kqu1a9fWLCmybt261O2PLn89evRIssW4rNdff/1gF8KBAwcmmWrdunVaPnXq1LR88ODBqUsi4iYiIiIiypVI1XM4uaLbHvJD5ulwvPPOO3HjjTem7n6lDB8+PEkX47LIRCFhSBMy9dxzz0WbNm2iSZMmMW/evOjfv3/KVDG+a9iwYUnC+PnKK6/YLVBERESkgHIlUuUcTq5+8YtfpAwTY6kYA1Up6OLXuHHjePjhhz+W4VqxYkXMmDEjtm3bFhs3bkyStHnz5pSNoqsh6+h6yHLqMHPmzDS5BbMHbt++PS0nG2a3QBERERHlSqTqOZRcITRMLtGiRYto2rTpYaN58+Yp+1RJgg4nRuXreH+47UVEREQ+yShXIlXO4TJXiA7jpWoTSpGIiIjIiUW5EqlyDidXIiIiIlI9KFciVY5yJSIiIpIPlCuRKke5EhEREckHypVIlaNciYiIiOQD5UqkylGuRERERPKBciVS5ShXIiIiIvlAuRKpcpQrERERkXygXIlUOcqViIiISD5QrkSqHOVKREREJB8oVyJVjnIlIiIikg+UK5EqR7kSERERyQfKlUiVo1yJiIiI5APlSqTKUa5ERERE8oFyJVLlnEi52rVrV6xcuTKWLl2aXpezb9++2LlzZ+zfvz927NgRBw4cqFkjIiIiIuUoVyJVzuHkCuHp0aNHPPTQQ4eN1q1bx/Tp05MklfLyyy9H48aN44EHHoi+ffvG3r17a9YUmT9/frzwwguxcePG6NmzZ2zfvr1mjYiIiIiUo1yJVDmHk6unn3467r777nj11Vdj5MiRMWLEiI8Fy7t27RrXXHNNrF+/vmbPIkOGDImXXnopxo8fnyTq3XffjUmTJqVs1qhRo2LAgAFxwQUXRPv27ePcc8+NTp06pSxXixYt4sknn4wtW7bE4MGD45FHHom2bdum9yIiIiKfVJQrkSrncHJFxmns2LEp40SXvUoBZJyaNGkSK1asOLgMkCsyV4899lgSKWRs2LBhsXjx4ujTp0/MmDEj+vXrF6tWrYouXbokeSJTNnPmzHjxxRdj9OjRSazee++96Ny5c8yaNetj2TERERGRTwrKlUiVczi5atq0aZKhIwnNtm3b4rbbbksZqVLIOiFK0LFjxxg4cGASrEWLFh2Uq0GDBsXmzZuTVO3Zsye6d++eynnzzTfTsZEu6vjss88myVKuRERE5JOKciVS5RxOrujyd+aZZ8YNN9wQN910U8W4+eab47zzzksZKiSrFOTqjjvuiObNm8dzzz2XpOq+++6Lli1bpq6ESNQ999wTr7zySrRp0yZ69eoVb731VjRr1iztw/bPPPNMymyR4VKuRERE5JOMciVS5RxOrmD58uUxe/bsw8acOXMqTkbBhBjLli1L3QCzY3A8Itt+9erVsWHDhti0aVOSKLoV0r2QZbxmO2YV/OCDD1JmS0REROSTinIlUuUcSa4gG191uBARERGRE4tyJVLl1EauREREROTko1yJVDnKlYiIiEg+UK5EqhzlSkRERCQfKFciVY5yJSIiIpIPlCuRKke5EhEREckHypVIlaNciYiIiOQD5UqkylGuRERERPKBciVS5ShXIiIiIvlAuRKpcpQrERERkXygXIlUOcqViIiISD5QrkSqHOVKREREJB8oVyJVjnIlIiIikg+UK5EqR7kSERERyQfKlUiVo1yJiIiI5APlSqTKOZxcHThwIPr37x+nnnpq/NM//VPF+MpXvhJnn312vPXWW7F///6aPYts3rw51q5dm8rZtWtXrFixIvbt21ez9qNs3bo1XnzxxdixY0fNkiKzZs2KMWPGxN69e2uWiIiIiHwyUa5EqpzDydULL7wQf/RHfxRnnXVWtGjRIh588MGPRcuWLePf//3f4/Of/3zMnDkziVQG+995552pfOTrxhtvTMeDchFbt25dPPXUU7F9+/aaJUUmTpyYpAu5Yp/S8kVEREQ+SShXIlXO4eTqF7/4RfzsZz9LWSWkBrkpD1i2bFl87nOfi44dO8aePXvSMhg6dGh07tw5pk2bFq+99lo8+eST6XjDhw+PRo0apfVktJCwm2++OVq1apVkauzYsSnL9corr8T48ePj1VdfjdWrV6f9EbqlS5cqWSIiIvKJQ7kSqXIOJ1c/+tGP4p577kkCdDiQrO9///spi1VaFlI0atSo6NSpU4wcOTL69OkTkydPju7du8fGjRujS5cuaf2gQYNS5or1r7/+epIuhK1fv35JrpCxrl27RpMmTeL6669P0mU3QREREfmkoVyJVDmHkyuyVjfccMMR5Yps1de+9rVo3br1R8oaMmRI6g44derUWL58efTu3TsmTJgQPXr0SGV269YtBg8enDJXyFbPnj2TbCFl8+fPj169eh3MXJEVQ7yo74YNG8xciYiIyCcO5UqkyjmcXJG1+uxnP5sySVu2bIlt27Z9LJi0gszUb/3WbyVRKp2wgv2QKZYhYGSmVq1alWSKsgcOHJhEie5+999/f7Rv3z51+eN18+bNk1yR6RoxYkS899570bRp07jvvvtS18FDTYwhIiIi0lBRrkSqnMPJ1cqVK9NkFr/92799yECqPv3pT8ddd92VBKwUuu6VShCCRcaJZZs2bTq4jiwW77MMGZNaIG5szzZZF0CWkeEqHdclIiIi8klBuRKpcg4nV4D0kH0ie3SooNvf4coQERERkeNHuRKpco4kV0C26UghIiIiIicW5UqkyqmNXImIiIjIyUe5EqlylKuGB5lExqoxNq00GLtWl1lGnhvKNXMpIiINlayHTvnfukMtP9EoVyJVjnLV8GAae74A+utf/3p8+9vfPhhMrf/444/H+vXra7Y8NphwhC9z/o//+I+45ZZb0hc8i4iINES2bt0aM2fOTOPL165dm5bxYeXChQtjypQpsXjx4vR9n/WFciVS5ShXDY+5c+emWR6bNWuWviOML11mWvynn346fvzjH6dp7o/03WWHY9q0aXHqqafGG2+8kf7Q+PyIiEhDhtmTESm+Fmbnzp3pb9/bb7+dpGvHjh01W9UPypVIlaNcNTzmzJmTMlfDhg2rWfIhiNbZZ5+dvk+M7xjjS57Z/tlnn00ixh8N4JM4vvS5S5cuB7+rDGbNmhWNGjWK73//++l7yd599920HCgLgevbt2/aP4Mp9Fk3e/bsePHFF9P3m/FJIPD8Pffcc/HUU0+lL4kulT6OxSeFK1asSPXr2rVrErusLhkLFiz4SF3pqphBd40333wzlU8ZfJl1KXx9AOfduXPnVC/+gIqIiJTC35V58+YloeLnjBkz0t+ndevW1WxRfyhXIlWOctXwyOTq5ZdfrlnyIXwBM3K1aNGiJDtsd9lll0WTJk3SlznT5W/UqFFxxRVXxO23356WX3TRRUmkEB/2v/baa+Ob3/xmkizE5YMPPoh27drFpZdeGvfee2/qKnjJJZfE6NGj0zHpNsi6Cy+8MJX38MMPJ7HjDxNl3XTTTenLodnngQceSNP/A7J0/vnnxx133JG+QPqqq66Kn//85wfLheHDh6dtrr/++vRda+eee2507949SRUC16ZNm3R+lH/zzTen1+PHj0/7cpzWrVuncvni6uuuuy6uvPLK1K1SRESkFP6m8IHipEmTYvLkyelDyvIP++oD5UqkylGuGh6HkiskB8FAJpAoug8iWh07dkzdGvhkbsmSJUmOnn/++SRT/OGYPn163Hjjjek7zQChOe+881JGCYYMGZIEiUwT27Nfnz59kpzxfPHJHuKEIJEp4nnjy6CRMzJK1IX+6mS7br311pTJgl69esUpp5wSr732WsqosS/yRjn0dycLdc0116RsGdkxjksW6uqrr07nQZaM8+VTRurFOXbr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r7abFN/q9HZ8tvVbadlnHhwbX39ycmz4YE9NiUVefvnlaNasWc27SNfgqaeeShmkmTNnJsF5++234913343FixfXbFXcDiFjHXIEGzZsSBkn4HpTBs8ZsWrVqrQsg+e1SZMmMWHChJolEXv27InmzZvHiBEj0r1iH64RLFmyJIkgwsc1y+DYU6dOjXnz5qXtkULqwGvELMu6zZ8/PyZPnpyWcY+p0+rVq9N69p87d26qH9txTlu2bEn7iYgcL8qViEjOqK1c0SCmQTls2LAYNGhQasTSGK1voajvQCBXrlyZGuecb6X1LJ8+fXpqxJevP5FRW7nqNmVlfK4gSqVZqz9u+WaSpuw98UcFsfrXgkS9tXRzLNywI7771NT448IypOwvH34r+k5bXVNiEbrdXXbZZUmoXnnllYNdAuG9996L22+/PQkWP6+88sokVPDaa6/FjTfemLJeSBKZJ7JQvXv3Ts/jmDFj4oYbbkjyQpABy7r8QSZX48ePr1lSpEOHDvHcc8+l8ho3bpxkCnG655570vGuuOKK1FURkCjKZfndd9+d6jdp0qR4/vnn07Hp4oi8IU833XRTXH/99XH55ZfHSy+9lH4XKJ/9b7311rj00ktTN8VHHnkkzj777Gjbtm2SPRGR40W5EhHJGbWRKz6VRxw6duwYnTt3Tl2wnnzyydSopnHfkAWLc2dcEQ1wGuTl2TrW0w3toYceildffbVes3m1latrB835iEiRnfp+l6nxD49OODixBRL1LwWxen1BUZBGFn5+/YnJqYsg69n/9pfnp3UZZHAQEMQCcUFQkCRArm6++eaUtQLEo0+fPilbdN9996X1wDP09NNPp/c8XwgagtS+ffuYNm1a6mrI88YzlnEouerXr1907do1fQiAHJE9QwCRLaCut912WxIfsm6PP/54Wr5s2bK0nOzUwIEDU/0yKCPLriGQCBX3+N57743u3bun5UOGDInrrrsuSTYyd/XVV6dnQkTkeFGuRERyxpHkioZkNkEAjVc+tQe6PpEpoIGJYNBgpQHMT4JllcqrtA3HONS+Wdnl2/M+24ef5VKTlVm6TWlZ2fZZWdk2pfuzjOszceLEuP/++w/KVVYmQZksf+yxx2L48OEHy62PqK1c/az79PjjGklCovguq2krtsXohRvja09MSpNc/HP7SfHavA1p+7GLN8W/FMSK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x/jx4+Pll1+OJUuWpOdDRERODsqViEjOUK7yG0crV2Sr+F4kZgNk38OxZcuWeOONN5KAmcUSETk5KFciIjlDucpvHI1ccZ8nTJiQpl9HsmoD2Sy6DU6ePDl9CfGh4Att27dvHx06dEhZrxM90+CcOXOie/fu0bFjx3TMHj16xLJly2rWHh1k7bguGzZsqFlSZNOmTUkskcwTCZlD7omzM4pIJZQrEZGcoVzlN45GrhhHdTRilbFr166U6Vq6dGnNko/CuubNmyfZ6du3bzz00EPRs2fPE9qdsHPnznHdddel43DMtm3bxv33339MgsV3ft19991JEEvh+7/uueeeNC7tRDJ69Oi45ZZbTuj1EpH8olyJiOQM5Sq/UVu5olsfY6yONQtDFmfIkCEfEwCE64477oj33nuvZkmkMVssmz59es2Suufpp5+Ofv36Hcz2cH5PPvlkErzDZdgqsXr16mjatOlHzgGQKqRx8eLFNUtODAhvo0aNlCsRqYhyJSKSM5Sr/EZt5QpRoIvb8UB3v3LRQLjatGlT8+5DEB8EiC53rVu3jsceeyzOPPPMuPjii9MkGbB169aUGTrllFPihhtuiDVr1qTlZKWQmgsuuCBOP/30NINhOZRNV8BSIRkxYkQ6DteEa0MZP/rRj+K0006L1157LW3Dtbr11lvTMRGajRs3xrp165JccR7nnXdeXHLJJWk7Mn0sf/DBB+Oss86KJk2apDoD66699tpUDudH90lALK+88sq0/Pzzz0+Cifg98cQTaX/KRuZmzZqVXlM/6sl1UK5EpBLKlYhIzlCu8hu1lSu67tVmu8OBFDEZRimIUK9evWrefcioUaOSmJApQzbuu+++NEshMxAiNUjXU089FcOHD0/bM3EGAoKkPProo3HXXXel55KsTuPGjWPlypVpu4xKcvXOO+9EixYtkqTNnj07XnrppbT89ddfT4LETIjs07t377Qc4Xr77bdj7dq1cf3110efPn3S8k6dOqUsGFm5iy66KLp165ayYYztIrjmdH1E5liOlJExA84v61744osvpu3oVnnbbbcdPC77s8/QoUPTe7YxcyUih0K5EhHJGcpVfqO2ckWXwCzrcqyQ5SnPIjHmqUuXLjXvPgRxIKOD0DCeCbkDxkQxPmrq1Klx5513xuOPPx7PPfdcEqrbb789CQ2S9corr6TtERWEiUkfSqkkV2TmEJX169encWXUoX///ml/RA+hQ/puuummtD8ixDJk7IEHHkiTZAD1QbCYrp5sU9ZdEGFD9JC4li1bHszA8b1gLAdEDalDpBgD9sgjj6T7xGsmzQDGclEnsl/AtWC9ciUilVCuRERyhnKV36itXA0aNCjd4+OBY2XZoAyEAbEonaqdcVDMHEiXQeSlVK6oK8JBxojueXSJQ2SyLBYCiHAhg/Duu+/WWq4QGiSNTBH1RKKQP45H5oq6AHJEBorjk3lD6JAvuupBJld0pUSiskky5s6dm7rvIUOly8musZysG+eNkHE+1AWRZDmZuyzrh8RxTpmcUR+OT2ZPRKQc5UpEJGcoV/mN2soVGScyT8dDpcwVdUAgkJgMsk50s2N7hIZugUyZDggUskV3QQSGmfIAkUGOyHS1a9fuiHKFvNAdMZu8AtFBpoYNG5beIzZ05wNELDvmgAEDYsqUKWn5pEmTUnaNcWSV5Irl11xzzcEyKYe6UU6rVq0O1h0Z5Fj8DpF9y0QScczk6t577z0oV9yzZs2axcCBA9P7rl27pvqZuRKRSihXIiI5Q7nKb9RWrsiuHGoq9dqCbDCpRTkIFJmgU089NX72s58l8WCSCECWyNow5uiMM86ICy+8MHWLA75XirFVP/nJT9JEEoyNgtJugTNnzkwCVD7migkzsuMRTH5Bl78MskEsv+KKK1J2iswVdeLYTETBMZlcA6FiOZkouv0BAoZIcb4IEvuec845qa6ZoJLFuvrqq1MdEKUsK8a+HPeqq65K0kQ3RWZapJysWyBQD7ZhQgu6BLKdciUilVCuRERyhnKV36itXCEK5ZNRHC2MLTrU90iRQWKcE1EqCZlcIRYsL+0+CHSFY5/S5ZSVTbHOzyw7VQrL2Sc7Znm5kJVdWh5Qj2yfbHnpNrzOjsmybPvS84LS8kuh3Kw+Wbml5WeU7l9ehohIhnIlIpIzaDQqV/mM2soVDXkmcDjWroFMEkE26WglgKwNE1dUyniJiMiRUa5ERHKGcpXfqK1cAVknxgll38lUW3g26HJXPu6pNnCskSNH1rqOIiLyUZQrEZGcoVzlN45GrrjPTOJwNIKViRWz+5V3axMRkROPciUikjOUq/zG0cgV0D1w8uTJSbCYUOJQwsRyJnpArJgcgmdERETqH+VKRCRnKFf5jaOVK0Ccli9fnsZgMckFX2bLmCqmGEeoeM/kFYyxKp+lT0RE6hflSkQkZyhX+Y1jkasM7jvTszPZBN/lxHdL8ZOZ/ZAvZ7ATETn5KFciIjlDucpvHI9ciYhI9aNciYjkDOUqv6FciYg0bJQrEZGcoVzlN5QrEZGGjXIlIpIzlKv8hnIlItKwUa5ERHKGcpXfUK5ERBo2ypWISM5QrvIbypWISMNGuRIRyRnKVX5DuRIRadgoVyIiOUO5ym8oVyIiDRvlSkQkZyhX+Q3lSkSkYaNciYjkjD179sTmzZtjy5YtRs5i06ZNsXz58nQPd+/ebRiGYRwh+P8yTyhXIiI5g6zVsmXLUgbEyFcgVosXL46VK1cahmEYtYg1a9bU/PXLB8qViEjOoFvgzp07jRzG9u3bk2SJiEjDRLkSEckZjrnKbzjmSkSkYaNciYjkDOUqv6FciYg0bJQrEZGcoVzlN5QrEZGGjXIlIpIzlKv8hnIlItKwUa5ERHKGcpXfUK5ERBo2ypWISM5QrvIbypWISMNGuRIRyRnKVX5DuRIRadgoVyIiOUO5ym8oVyIiDRvlSkQkZyhX+Y3aytXSjXti3rrdMf84Yv+BmsJERKTeUK5ERHKGcpXfqK1c/fyZFfGXLRbFF1otPqb420Js3bm/pjQREakvlCsRkZyhXOU3aitX5/RYEf/w0OL4StslxxRfLsTWXcqViEh9o1yJiOQM5Sq/cSLk6ouF7f6xzUeXHU6uFixYELfeemtcddVVccUVV8Q777yTllO/Tp06xfPPPx/79598MXv11VfjscceS9eslM2bN8eTTz4Zw4YNq1lyfLz11lvRqlWrWL9+ffrd6tWrV1xyySXRu3fveO655+Kpp56KXbt21Wxd9/Tv3z+eeeaZE3oMGD58eLpumzZtqllShHPu2rVr9OvXL70+VnhmXnjhhWjfvn3s3LmzZqnIJw/lSkQkZyhX+Y26lKsvF4TqSw8vjm4TN8dNL6xJQnVwXSEqydW0adPirLPOisGDB8fSpUtTY/jMM8+MMWPGpLpdfvnl0axZs+NqZNcVHTp0iF/+8pexcePGmiVFkCDkB1E4VubMmZPOGQYMGBBnnHFGrFq1KmbPnh3nnXdeEqx169ZFixYt4oYbbki/byeKpk2bpmOcCLkaPXp0LFmyJL1++umnk0xzXpzPqFGjYsOGDele33jjjdGkSZPjuu/s++CDD6Z7tn379pqlIp88lCsRkZyhXOU36kqukKp/bLM4uk/aEgcORLy1aEf8R4dlBzNYleSKBu8111yTshSlkGU4UChky5Ytcd1118V9990XCxcujGXLln0kA0HGg+WLFy9O28Lu3btj9erV6T2N+JUrV8aePXvSOkCMyJStWbMm1q5dG1u3bk3LyXKwjHU09jl+ORyP8rIsGtstWrQo5s+fH9dee2107tw5LQfqSt2yrAzlIQ5kuZAm9ssa/NOnT4+zzz47Zem4H9RpxYoVqd6vvfZanH766SmbhOxQBueX1Y9zoM7UK4Njsh3L2DarL7+nnGOWeeMn6zkO23BtOHbLli3jpptuirlz56ZrmG0Pe/fuTXUnMsGjXK4F58azxD7lYkZ9X3zxxfjWt74VI0eOTPcxuxZch4ceeiid53vvvZf2veOOO5LkUTbBuXCe5WKbQfnZveXaU0/OqU2bNkmuKp0Lx8nuE9cFKIfrR1lcW54t6pnB80U5fBDANSY4FnBOlMV6thOpFpQrEZGcoVzlN2hsHq1cIUr/kGSqKE5fLLwma/XMxM2FxmnEhCU74oedln+ka2AluaIh/Z3vfOdgxqYcBOnmm2+On//850nCfvrTn6bGMtDYvv3221Pm46KLLoq77747PYPvvvtufPOb34xHH300rr/++jj11FPj5ZdfTvvQkL7ggguSyDRq1Ci++93vHhQiuuKRJTv//PPj6quvTpmkcshMsT/1Qi7Y9txzz422bdvGOeeckzIxQBYOUWA9kkBdaYBTHzJCbP/tb387mjdvnmSGcr/+9a/HaaedljI7iBSZK7pHUs+vfe1rad3EiRNT5grh5FxnzZoVV155ZaoTx5o8eXI6PlJCvZBShC1r6CMxbN+uXbv0np8cl2uG5CCIgwYNSteY43EcfpJBQjCQMM6R+/GLX/wibUf9ESuya/fcc0888MAD8a//+q/RvXv3g1IHyArlffGLX0x14JjdunVL13zcuHHxk5/8JP75n/851Xn58uXpflIW123o0KFJkDhHngfWl0OGj/IvvPDC+NnPfpbqyfP9+OOPx/e+972UCeNc6H7KcsSK7pWUS3dUzofryf9lnMell16a9qUsRDOTZLpL/uAHP4hbbrklnQfPHs8V14GunNw3noUePXooWFI1KFciIjlDucpvHK1cIVGI0pndVsS/PL70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UK7yG8cqVwTvf9rlo7MCHioOJ1f1BXJGVoHnlcwPIocIiNQGJJBJMDIhZmwZGbZyiRSpNpQrEZGcoVzlN45Hrgi+36p8WaWoBrlCrJh6nGwDXdoYe0QGTKQ20C2QjCRdUOlGymuyb2TIRKoZ5UpEJGcoV/mN45Wr2kY1yBVd2BhvxXguxnZlXxwrUlsYH8Z4LZ4fuggequulSDWhXImI5AzlKr/xSZIrEZFPIsqViEjOUK7yG7WVq58/syI+32JR/G2rxccUf1OIrTuVKxGR+ka5EhHJGcpVfqO2cvXI6I1x64tr447Bxx479jg2RUSkvlGuRERyhnKV36itXImISD5RrkREcoZyld9QrkREGjbKlYhIzlCu8hvKlYhIw0a5EhHJGcpVfkO5EhFp2ChXIiI5Q7nKbyhXIiING+VKRCRnKFf5DeVKRKRho1yJiOQM5Sq/oVyJiDRslCsRkZyhXOU3lCsRkYaNciUikjOUq/yGciUi0rBRrkREcoZyld9QrkREGjbKlYhIzlCu8hvKlYhIw0a5EhHJGcpVfkO5EhFp2ChXIiI5Q7nKbyBXy5cvr7mTIiLS0FCuRERyyIEDB4ycBnIsIiINE+VKRERERESkDlCuRERERERE6gDlSkREREREpA5QrkREREREROoA5UpERERERKQOUK5ERERERETqAOVKRERERESkDlCuRERERERE6gDlSkREREREpA5QrkREREREROoA5UpERERERKQOUK5ERERERETqAOVKRERERESkDlCuRERERERE6gDlSkREREREpA5QrkREREREROoA5UpERERERKQOUK5ERERERETqAOVKRERERESkDlCuRERERERE6gDlSkREREREpA5QrkREREREROoA5UpERERERKQOUK5ERERERETqAOVKRERERESkDlCuRERERERE6gDlSkREREREpA5QrkREREREROoA5UpE5ATwwQcfGIZhGIaRo6gLlCsRkRPAli1bDMMwDMPIUdQFypWIiIiIiEgdoFyJiIiIiIjUAcqViIiIiIhIHaBciYiIiIiI1AHKlYiIiIiISB2gXImIiIiIiNQBypWIiIiIiEgdoFyJiIiIiIjUAcqViIiIiIhIHaBciYiIiIiI1AHKlYiIiIiISB2gXImIiIiIiNQBypWIiIiISB0xYNrW+NYTS+NHTy2v2vheh2Vx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", "title": null, "units": null, "w": "597", "x": 643, "y": 25, "z": -1}, {"color": "#9fc5e8", "definition": "", "description": null, "errorInDef": false, "extraData": null, "h": "50", "identifier": "pyplan_library", "moduleId": "financial_planning_library", "nodeClass": "module", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Pyplan library", "units": null, "w": "100", "x": 50, "y": 500, "z": 1}, {"color": "#9fc5e8", "definition": "", "description": null, "errorInDef": false, "extraData": null, "h": 61, "identifier": "pyplan_xarray_extensions", "moduleId": "pyplan_library", "nodeClass": "module", "nodeFont": "", "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Pyplan XArray Extensions", "units": null, "w": 116, "x": 100, "y": 100, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(pypi_name,import_name=None):\n    \"\"\" Install library from pypi or .libs dir\n    pypi_name : Library name in pypi\n    import_name: library name for use in import\n    \"\"\"\n    import importlib\n    \n    def _exists_module(import_name):\n        try:\n            importlib.import_module(import_name)\n            return True\n        except ImportError:\n            return False\n\n    if import_name is None:\n        import_name = pypi_name\n        \n    if not _exists_module(import_name):\n        #check in lib folder\n        import os  \n        _lib_path = current_path + \"libs\"\n        \n        if not os.path.isdir(_lib_path):\n            os.mkdir(_lib_path) \n\n        #install lib to libs folder    \n        os.system(f\"pip install -t \\\"{_lib_path}\\\" {pypi_name}\")\n        \n        importlib.invalidate_caches()\n        \n        if not _exists_module(import_name):\n            raise ValueError(f\"Can't install the module '{import_name}'\")\n    return True\n    \n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "install_library", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Install Library", "units": null, "w": 179, "x": 306, "y": 497, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(dataArray,domainDic, defaultValue=None):\n    _da = dataArray\n    for key in domainDic:\n        _da = _da.reindex({key:domainDic[key].values})\n        _da = _da.rename({key:domainDic[key].name})\n    if not defaultValue is None:\n        _da = _da.fillna(defaultValue)\n    return _da\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "set_domain", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Set domain", "units": null, "w": 179, "x": 107, "y": 90, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(values,name=\"Report\"):\n    _titles = [str(xx.name) for xx in values]\n    _index = pd.Index( _titles, name=name)\n    \n    return xr.concat(values,_index)\n\n\nresult = _fn\n", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "build_report", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Build Report", "units": null, "w": 179, "x": 107, "y": 127, "z": 1}, {"color": null, "definition": "def _fn(filepath, useOpenpyxl=False, dataOnly=True, readOnly=True ):\r\n    \"\"\" Create excel object from filepath.\r\n    filepath: path to excel file\r\n    useOpenpyxl: True for use custom \r\n    dataOnly: True for view only the values, not formula\r\n    readOnly: True for read only, False for write options\r\n    Ex.\r\n            excel_connection(\"\\path\\to\\the\\excelfile.xlsx\")\r\n    \"\"\"\r\n    import os\r\n    \r\n\r\n    if self.model.isLinux():\r\n        filepath = filepath.replace(\"\\\\\",\"/\")        \r\n\r\n    fullFilename=filepath\r\n    \r\n    if not os.path.isfile(fullFilename):\r\n        fullFilename = self.node.model.getNode(\"current_path\").result + filepath     \r\n        \r\n\r\n    if os.path.isfile(fullFilename):\r\n        if useOpenpyxl:\r\n            from openpyxl import load_workbook\r\n            return load_workbook(fullFilename, data_only=dataOnly, read_only=readOnly)\r\n        else:\r\n            return filepath\r\n    else:\r\n        raise ValueError(\"File not found\") \r\n        \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "excel_connection", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Excel connection", "units": null, "w": 179, "x": 306, "y": 90, "z": 1}, {"color": null, "definition": "def _fn(value,coords,dtype=None):\n    _data = np.full( tuple([(len(x)) for x in coords]),value, dtype=dtype )\n    return xr.DataArray( _data, coords )\n\nresult = _fn\n", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "create_dataarray", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Create dataArray", "units": null, "w": 179, "x": 107, "y": 164, "z": 1}, {"color": null, "definition": "def _fn(excel,sheetName=None,namedRange=None,cellRange=None, indexes=None, driver=\"Driver={Microsoft Excel Driver (*.xls, *.xlsx, *.xlsm, *.xlsb)};DBQ=%s;READONLY=TRUE\"):\r\n    \"\"\" return a pandas dataframe from excel.\r\n    excel: path to excel file or cp.excel object\r\n    sheetName: sheet name to be read\r\n    namedRange: name of the range to be read\r\n    cellRange: used with sheetname, for read from a simple range\r\n    indexes: Listo of columns names for convert to index of dataframe\r\n        Ex.\r\n            pandas_from_excel(excelNode,\"Sheet 1\")\r\n            pandas_from_excel(excelNode,namedRange=\"name_range\")\r\n            pandas_from_excel(excelNode,\"Sheet 1\",cellRange=\"A1:H10\")\r\n\r\n    \"\"\"\r\n\r\n    if isinstance(excel,str):\r\n        import os\r\n        \r\n        \r\n        if not os.path.isfile(excel):\r\n            excel = os.path.join(self.model.getNode(\"current_path\").result,excel)\r\n            \r\n            \r\n        if self.model.isLinux():\r\n            filename=excel\r\n            target_dir = os.path.dirname(filename)\r\n            file_name, file_extension = os.path.splitext(filename)\r\n            target_dir = os.path.join(target_dir, file_name)\r\n\r\n            file_to_read = os.path.join(target_dir, (namedRange if namedRange else \"\")  +\".pkl\")\r\n            if os.path.isfile(file_to_read):\r\n                df = pd.read_pickle(file_to_read,compression='gzip')\r\n                if not indexes is None:\r\n                    df.set_index(indexes,inplace=True)\r\n                return df\r\n            else:\r\n                from openpyxl import load_workbook\r\n                _wb = load_workbook(filename, data_only=True, read_only=True)\r\n                return _fn(_wb,sheetName,namedRange,cellRange,indexes)\r\n        else:\r\n            \r\n\r\n            import pyodbc\r\n    \r\n            cnxn = pyodbc.connect(driver % excel, autocommit=True)\r\n            cursor = cnxn.cursor()\r\n            table = \"\"\r\n            if not sheetName is None: \r\n                table = \"[\"+sheetName+\"$]\"\r\n            if not namedRange is None:\r\n                table = \"[\"+namedRange+\"]\"\r\n            if not cellRange is None:\r\n                table = \"[\"+sheetName+\"$\"+cellRange+\"]\"\r\n    \r\n            cursor.execute(\"SELECT * FROM \" + table)\r\n            rows = cursor.fetchall()\r\n            columnNames = [str(x[0]) for x in cursor.description]\r\n            cnxn.close()\r\n    \r\n            _df = pd.DataFrame.from_records(rows,None,None,columnNames)\r\n            _df = _df.dropna(how =\"all\")\r\n            if not indexes is None:\r\n                _df.set_index(indexes,inplace=True)\r\n            return _df\r\n    else:\r\n        \r\n        if \"openpyxl.workbook\" in str(type(excel)):\r\n            rangeToRead = None\r\n            if not namedRange is None:\r\n                the_range = excel.defined_names[namedRange]\r\n                dests = the_range.destinations\r\n                for title, coord in dests:\r\n                    ws = excel[title]\r\n                    rangeToRead=ws[coord]\r\n            elif not cellRange is None:\r\n                ws = excel[sheetName]\r\n                rangeToRead = ws[cellRange]\r\n            else: \r\n                rangeToRead = excel[sheetName]\r\n\r\n            nn=0\r\n            cols=[]\r\n            values = []\r\n            for row in rangeToRead:\r\n                if nn==0:\r\n                    cols = [str(c.value) for c in row]\r\n                else:\r\n                    values.append([c.value for c in row]) \r\n                nn+=1\r\n            df = pd.DataFrame(values,None,cols)\r\n            if not indexes is None:\r\n                if isinstance(indexes,str):\r\n                    indexes=[indexes]\r\n                toIndex = []\r\n                for indexColumn in indexes:\r\n                    if indexColumn in df.columns.values:\r\n                        toIndex.append(indexColumn)\r\n                if len(toIndex)>0:\r\n                    df.set_index(toIndex, inplace=True)\r\n\r\n            return df.dropna(how =\"all\")\r\n        else:\r\n            raise ValueError(\"excel can be cp.excel object\") \r\n            \r\n            \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "pandas_from_excel", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Pandas from excel", "units": null, "w": 179, "x": 304, "y": 238, "z": 1}, {"color": null, "definition": "def _fn(dataframe, columnName=None, removeEmpty=True):\r\n    \"\"\" Return a pd.Index from an column of a pandas dataframe.\r\n    dataframe: pandas dataframe\r\n    columnName: dataframe column name used for create cp.index. By default is created using the first column\r\n    removeEmpty: True for remove empty rows\r\n        Ex.\r\n            index_from_pandas(df)\r\n            index_from_pandas(df,\"column10\")\r\n    \"\"\"                \r\n    \r\n    _serie= None\r\n    if columnName is None:\r\n        _serie=dataframe[dataframe.columns[0]]\r\n    else:\r\n        _serie=dataframe[columnName]\r\n\r\n    if removeEmpty:\r\n        _serie.dropna(inplace=True)\r\n        if kind_to_string( _serie.dtype.kind )==\"string\" or kind_to_string(_serie.dtype.kind )==\"object\":\r\n            _serie = _serie[_serie!=\"\"]\r\n\r\n    return pd.Index(_serie.unique())\r\n\r\n            \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "index_from_pandas", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Index from Pandas", "units": null, "w": 179, "x": 304, "y": 275, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(kind):\n    \"\"\"Returns the data type on human-readable string\n    \"\"\"\n    if kind in {'U', 'S'}:\n        return \"string\"\n    elif kind in {'b'}:\n        return \"boolean\"\n    elif kind in {'i','u','f','c'}:\n        return \"numeric\"\n    elif kind in {'m','M'}:\n        return \"date\"\n    elif kind in {'O'}:\n        return \"object\"\n    elif kind in {'V'}:\n        return \"void\"\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "kind_to_string", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Kind to String", "units": null, "w": 179, "x": 304, "y": 201, "z": 1}, {"color": null, "definition": "def _fn(excel, sheetName=None,namedRange=None,cellRange=None, columnName=None, removeEmpty=True):\r\n    \"\"\" Return a pd.Index from an excel file.\r\n    excel: pp.excel object\r\n    sheetName: sheet name to be read\r\n    namedRange: name of the range to be read\r\n    cellRange: used with sheetname, for read from a simple range\r\n    columnName: dataframe column name used for create pp.index. By default is created using the first column\r\n    removeEmpty: True for remove empty rows\r\n        Ex.\r\n            index_from_excel(excelNode,\"Sheet 1\")\r\n            index_from_excel(excelNode,namedRange=\"name_range\")\r\n            index_from_excel(excelNode,namedRange=\"name_range\", columnName=\"indicadores\")\r\n    \"\"\"                \r\n    if isinstance(excel,str) or \"openpyxl.workbook\" in str(type(excel)):\r\n        _df = pandas_from_excel(excel,sheetName,namedRange,cellRange)\r\n        return index_from_pandas(_df,columnName,removeEmpty)\r\n    else:\r\n        raise ValueError(\"excel can be excel_connection object or a str path to the filename\")\r\n\r\n            \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "index_from_excel", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Index from Excel", "units": null, "w": 179, "x": 304, "y": 312, "z": 1}, {"color": null, "definition": "def _fn(excel, sheetName=None,namedRange=None,cellRange=None, indexes=None, valueColumns=None, indexColumnHeaders=None, replaceByIndex=None, defaultValue=0):\r\n    \"\"\" Return a xr.DataArray from excel file.\r\n    excel: excel_connection object.\r\n    sheetName: sheet name to be read\r\n    namedRange: name of the range to be read.\r\n    cellRange: used with sheetName to read from a simple range.\r\n    indexes: pd.Index objects to perform a change_index operation.\r\n    valueColumns: string with the column name of the dataframe that contains the values.\r\n                pd.Index with column names to convert columns to index.\r\n    indexColumnHeaders: (optional) column names in pandas to parse with indexes. Used if header on dataframe is not equal to index identifiers.\r\n    replaceByIndex: (optional) replace index used in valueColumns by this index (using change_index).\r\n\r\n        Ex.\r\n            dataarray_from_excel(excelNode,\"Sheet 1\",indexes=[indicadores],valueColumns=\"descuentos\")\r\n            pp.dataarray_from_excel(excelNode,namedRange=\"nombre_rango\",indexes=[indicadores],valueColumns=time)\r\n    \"\"\"\r\n\r\n    dataframe = pandas_from_excel(excel,sheetName,namedRange,cellRange)\r\n    # Check size of dataframe. If it is empty, create empty dataArray. Else, proceed\r\n    if len(dataframe) == 0:\r\n        if not isinstance(indexes, list):\r\n            indexes = [indexes]\r\n        if isinstance(valueColumns, pd.Index):\r\n            indexes.append(valueColumns)\r\n        \r\n        _data = np.full(tuple([(len(x)) for x in indexes]), defaultValue)\r\n        return xr.DataArray(_data, indexes)\r\n    else:\r\n        valueIndex=None\r\n        if isinstance(valueColumns,pd.Index):\r\n            valueIndex = valueColumns\r\n            valueColumns = valueIndex.values\r\n        elif isinstance(valueColumns,str):\r\n            valueColumns = [valueColumns]\r\n    \r\n        if indexColumnHeaders is None:\r\n            indexColumnHeaders = [index.name for index in indexes]\r\n            \r\n        # Create total index and index names\r\n        _allindexes = indexes\r\n        _allIndexNames = indexColumnHeaders[:]\r\n        if not valueIndex is None:\r\n            _allindexes.append(valueIndex)\r\n            _allIndexNames.append(\"data_index\")    \r\n            \r\n        #fill other columns for prevent melt error\r\n        cols_not_in_df = [col for col in valueColumns if col not in dataframe.columns]\r\n        for col in cols_not_in_df:\r\n            dataframe[col] = np.nan\r\n    \r\n        _full = dataframe.reset_index().melt(id_vars=indexColumnHeaders,value_vars=valueColumns, var_name=\"data_index\", value_name=\"data_value\")\r\n        \r\n        # sum for acum over duplicate records\r\n        _full = _full.groupby(_allIndexNames, as_index=False).sum()\r\n        _dtype = _full[\"data_value\"].dtype\r\n        \r\n        _dataType = kind_to_string(_dtype.kind )\r\n        if _dataType==\"string\":\r\n            _full = _full[ (_full[\"data_value\"]!=\"\") & (_full['data_value'].notna()) ]\r\n        else:\r\n            _full = _full[ (_full[\"data_value\"]!=0) & (_full['data_value'].notna()) ]\r\n    \r\n        _full.set_index(_allIndexNames, inplace=True)\r\n        _da = _full[\"data_value\"].to_xarray()  \r\n    \r\n        # If indexed, rename index\r\n        if not indexes is None and not indexColumnHeaders is None:\r\n            if not isinstance(indexes,list):\r\n                indexes = [indexes]\r\n            idxPos=0\r\n            for cubeIndex in indexes:\r\n                newIndexName=cubeIndex.name\r\n                if idxPos<= len(indexColumnHeaders)-1:\r\n                    oldIndexName=indexColumnHeaders[idxPos]\r\n                    if not newIndexName in _da.coords:\r\n                        _da.coords[newIndexName] = _da.coords[oldIndexName]\r\n                        _da = _da.swap_dims({oldIndexName:newIndexName}).drop(oldIndexName)\r\n                    idxPos+=1\r\n                    # Reindex to complete combinations\r\n                    _da = _da.reindex({newIndexName:cubeIndex.values})\r\n    \r\n        if not valueIndex is None:\r\n            newIndexName=valueIndex.name\r\n            oldIndexName=\"data_index\"\r\n            if not newIndexName in _da.coords:\r\n                _da.coords[newIndexName] = _da.coords[oldIndexName]\r\n                _da = _da.swap_dims({oldIndexName:newIndexName}).drop(oldIndexName)\r\n            # Reindex to complete combinations\r\n            _da = _da.reindex({newIndexName:valueIndex.values})\r\n    \r\n            if not replaceByIndex is None:\r\n                _da = change_index(_da,valueIndex,replaceByIndex, 2 )    \r\n                \r\n        return _da.fillna(defaultValue)\r\n\r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "dataarray_from_excel", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "DataArray from Excel", "units": null, "w": 179, "x": 306, "y": 386, "z": 1}, {"color": null, "definition": "def _fn(dataArray, indexes, values):\r\n    \"\"\"\r\n    Filter dataArray using the filterList filters. \r\n\r\n    dataArray: dataArray to be filtered\r\n    indexes: the index to filter \r\n    values: the value to filter \r\n        Ex.\r\n            subscript(dataArray, index, value)\r\n    \"\"\"\r\n    if not isinstance(dataArray,xr.DataArray):\r\n        raise ValueError(\"the 'dataArray' parameter must be of the type xr.DataArray\")\r\n\r\n    if not isinstance(indexes,list):\r\n        indexes = [indexes]\r\n    if not isinstance(values,list):\r\n        values = [values]\r\n        \r\n    res = dataArray\r\n    filterDic = {}\r\n    for _pos, indexItem in enumerate(indexes):\r\n        filterDic[indexItem.name] = values[_pos]\r\n\r\n    if len(filterDic)>0:\r\n        res = res.sel(filterDic, drop=True)\r\n\r\n    return res\r\n        \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "subscript", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Subscript", "units": null, "w": 179, "x": 306, "y": 127, "z": 1}, {"color": null, "definition": "def _fn(dataArray,oldIndex,newIndex,compareMode=1,defaultValue=None):\r\n    \"\"\" Change index of a dataArray object.\r\n    \"\"\"\r\n    _da = dataArray\r\n\r\n\r\n    if compareMode==1:\r\n        _temp = _da.reindex({oldIndex.name:newIndex.values})\r\n        _temp[newIndex.name] = _temp[oldIndex.name]\r\n        _temp = _temp.swap_dims({oldIndex.name:newIndex.name}).drop(oldIndex.name)\r\n        if not defaultValue is None:\r\n            _temp = _temp.fillna(defaultValue)\r\n        return _temp\r\n    else:\r\n\r\n        if len(oldIndex.values) == len(newIndex.values):\r\n            _tmp = _da.copy()\r\n            _tmp.coords[newIndex.name] = _tmp.coords[oldIndex.name]\r\n            _tmp.coords[newIndex.name].data = newIndex.values\r\n            _tmp = _tmp.swap_dims({oldIndex.name : newIndex.name}).drop(oldIndex.name)\r\n            return _tmp\r\n        elif len(oldIndex.values) > len(newIndex.values):\r\n            raise ValueError(\"Changeindex by pos for indices of different size is not implemented\")\r\n        else:\r\n            raise ValueError(\"Changeindex by pos for indices of different size is not implemented\")\r\n    \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "change_index", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Change index", "units": null, "w": 179, "x": 306, "y": 164, "z": 1}, {"color": null, "definition": "def _fn(date_start,date_end,freq='M',format='%Y.%m'):\r\n    \"\"\"Create time index usign start and end dates and freq. The result is formated to format parameter\r\n        Ex.\r\n            create_time('2016.01','2018.12')\r\n            create_time('2016.01.01','2016.12.31',freq='D',format='%d/%m/%Y')\r\n    \"\"\"\r\n    if \".\" in date_start:\r\n        date_start = date_start.replace('.', '-')\r\n    if \".\" in date_end:\r\n        date_end = date_end.replace('.', '-')\r\n    return pd.Index(pd.period_range(start=date_start, end=date_end, freq=freq).strftime(format))\r\n        \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "create_time", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "CreateTime", "units": null, "w": 179, "x": 505, "y": 90, "z": 1}, {"color": null, "definition": "def _fn(param1, param2, compareType=1, caseSensitive = True):\r\n    \"\"\"\r\n    param1: value or indexarray for compare\r\n    param2: index compare to\r\n    compareType: exact=1, start_with=2, end_with=3, contain=4  \r\n    caseSensitive: able to differentiate between uppercase and lowercase (by default True)\r\n\r\n    If param1 is a scalar (numeric or str) and param2 is an index:  return a dataArray indexed by param2 with True on ocurrences of param2\r\n        Ex. result = find(\"te\", region, cp.end_with)\r\n    If param1 is an index and param2 is an index too:  return a dataArray indexed by param1 and param2 with True on ocurrences of param1 on param2\r\n        Ex. result = find(subregion, region, cp.contain)\r\n\r\n    \"\"\"\r\n    def _internalFn(item,value):\r\n        if not isinstance(item,str):\r\n            item = str(item)\r\n        if not isinstance(value,str):\r\n            value = str(value)\r\n            \r\n        if compareType==1:\r\n            if caseSensitive:\r\n                return item == value\r\n            else:\r\n                return item.lower() == value.lower()\r\n        elif compareType==2:\r\n            if caseSensitive:\r\n                return item[:len(value)] == value\r\n            else:\r\n                return item[:len(value)].lower() == value.lower()                                    \r\n        elif compareType==3:\r\n            if caseSensitive:\r\n                return item[-len(value):] == value\r\n            else:\r\n                return item[-len(value):].lower() == value.lower()                    \r\n        elif compareType==4:\r\n            if caseSensitive:\r\n                return value in item\r\n            else:\r\n                return value.lower() in item.lower()\r\n\r\n    if (isinstance(param1,str) or str(param1).isnumeric()) and isinstance(param2,pd.Index):\r\n        vfn = np.vectorize(_internalFn)\r\n        return xr.DataArray(vfn(param2.values,param1),[param2])\r\n\r\n    if isinstance(param1,pd.Index) and isinstance(param2,pd.Index):\r\n        _res = create_dataarray(False, [param1,param2], dtype=bool)\r\n        for row in param1.values:\r\n            for col in param2.values:\r\n                _res.loc[ {param1.name:slice(row,row), param2.name:slice(col,col) }] = _internalFn(col,row)\r\n        return _res \r\n            \r\nresult = _fn\r\n", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "find", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Find", "units": null, "w": 179, "x": 107, "y": 201, "z": 1}, {"color": null, "definition": "def _fn(dataArray, dataMap, sharedIndex, defaultValue=0): \n    \"\"\"\n    Returns the value of dataArray indexed by the index of dataMap.\n    dataArray must be indexed by sharedIndex and dataArray values must correspond to elements of sharedIndex.\n    For example: Let's say you have a cube with an estimated inflation rate by Country (\"inflation_rate\" is the name of the cube; \"country\" is the name of the index) and you want to assign it to the corresponding Company depending on its location. On the other hand, there's a many-to-one map where each Company is allocated to a single Country (\"country_to_company_allocation\"). The sharedIndex, in this case, is Country (\"country\").\n    As a result, \n        lookup( inflation_rate , country_to_company_allocation , country )\n    will return the estimated inflation rate by Company.\n    \"\"\"\n\n    try:\n        return dataArray.sel({sharedIndex.name: dataMap }, drop=True) \n    except Exception as ex:\n        filtro =  dataMap.isin(sharedIndex.values)\n        valuesOk =  dataMap[dataMap.isin(sharedIndex.values)]\n        lookOk =  dataArray.sel({sharedIndex.name: valuesOk }, drop=True) \n        final = lookOk.reindex({dataMap.dims[0]:dataMap.coords[dataMap.dims[0]].values})\n        return final.fillna(defaultValue)\n    \nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "lookup", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Lookup", "units": null, "w": 179, "x": 505, "y": 127, "z": 1}, {"color": null, "definition": "def _fn(dataArray, mapInfo, sourceIndex, targetIndex, aggregationFunction='sum'):\n    \"\"\" Aggregates the values in DataArray to generate the result indexed by  targetIndex.\n        mapInfo gives the value of targetIndex for each element of sourceIndex (If the map does not match then the element will not be set into target index and information will be lost)\n        aggregationFuction (optional) especifies the function to be used when grouping data (sum, mean, min, max, median)\n\n        Example for aggregating time information into annual index the syntax is:\n            aggregate(dataArray, map, time, years)\n    \"\"\"\n    _map = pd.DataFrame({targetIndex.name:mapInfo.to_series()})\n    _serie = dataArray.to_series()\n    _df = pd.DataFrame({\"value\":_serie})\n    _df = _df[ _df[\"value\"]!=0 ]\n    _df = _df.join(_map).reset_index()\n    _df.drop(columns=[sourceIndex.name],inplace=True)\n    _newDimList = [xx for xx in dataArray.dims if xx not in [sourceIndex.name]]\n    _newDimList.append(targetIndex.name)\n    _df = _df.groupby(_newDimList).agg(aggregationFunction)\n    _da = _df[\"value\"].to_xarray()\n\n    #reindex\n    _reindexDic={targetIndex.name:targetIndex.values}\n    for coord in dataArray.coords:\n        if coord!=sourceIndex.name:\n            _reindexDic[ coord] = dataArray.coords[coord].values\n    _da = _da.reindex(_reindexDic)\n    # fin reindex\n    return _da.fillna(0)\n    \nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "aggregate", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Aggregate", "units": null, "w": 179, "x": 505, "y": 164, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(cube):\n    \"\"\"Returns a list of all the elements of the index for which cube is true. The function is used to create a new index that is a subset of an existing index.\n        Ex. subset(sales>0)\n    \"\"\"\n    cond = cube>0\n    values = cond.coords[cond.dims[0]].values[cond.values]\n    return pd.Index(values)\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "subset", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Subset", "units": null, "w": 179, "x": 107, "y": 275, "z": 1}, {"color": "#cb98ff", "definition": "def _fn( param1, separator, part=None ): \n    \"\"\"\n    Description: Returns a DataArray object with text values formed by splitting the elements of param1 text values at each occurrence of separator \"separator\". \n    The DataArray will have the original dimension plus a new dimension 'Parts' of length (number of separators + 1). \n    All text values must have the same number of separators separator.        \n    \"\"\"\n    if isinstance(param1, pd.Index) : \n        param1 = xr.DataArray(param1.values, [param1]) \n\n    _q_separators = apply_fn( param1, lambda x: x.count(separator) ) \n    _max_q_separators = np.asscalar( _q_separators.max().values ) \n    _result_coords = ['Part ' + str(i) for i in range( 1, _max_q_separators + 2)] \n    _result_dim = pd.Index( _result_coords ) \n    _result_dim.name = \"Parts\" \n\n    _results = [] \n\n    for _part in range( _max_q_separators + 1 ): \n        _dataarray = apply_fn( param1, lambda x: x.split(separator)[_part] ) \n        _results.append(_dataarray) \n\n    _res = xr.concat( _results, dim = _result_dim )\n\n    if not part is None:\n        _res = _res.sel(Parts=\"Part \" + str(part),drop=True)\n\n    return _res\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "split_text", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Split Text", "units": null, "w": 179, "x": 107, "y": 312, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(index): \n    \"\"\"\n    Return datarray with pd.index and yours positions as values\n    \"\"\"\n    return xr.DataArray(range(0,len(index)), [index] )\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "get_pos", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Get pos", "units": null, "w": 179, "x": 107, "y": 349, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(*args):\n    \"\"\"\n    Concatenates two or more indexes and/or atomic values into a single new index\n    Return: new index\n        Ex.\n            cp.concatIndex(index1,index2,index3,value1,value2)\n    \"\"\"\n    _list = []\n    for arg in args:\n        if isinstance(arg,pd.Index):\n            values = (arg.values).tolist()\n            _list.extend(values)\n        else:\n            _list.append(arg)\n\n    seripandas = pd.Series(_list)\n    return pd.Index(seripandas.unique())\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "concat_index", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Concat Index", "units": null, "w": 179, "x": 107, "y": 386, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(index,selection,includeAll=False):\n    \"\"\"Return the element in the \"selection\" position of the index. \n    \"\"\"\n    if selection==0 and includeAll==1:\n        return \"All\"\n    else:\n        values = None\n        if isinstance(index,pd.Index):\n            values = (index.values[:1000]).tolist()\n        elif isinstance(index,np.ndarray):\n            values = (index[:1000]).tolist()\n        else:\n            values = list(index)[:1000]\n        if not values is None and len(values)>=selection:\n            return values[selection-1]\n    return \"\"\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "choice", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Choice", "units": null, "w": 179, "x": 505, "y": 201, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(dataArray,index,shift, initialValues=None):\n    \"\"\"\n    Perform cyclic calculations betwwen nodes.\n    cube: cp.cube to evaluate\n    index: Index to shift \n    shift: amount of elemnts to shift. Can be positive or negative\n    initialValues: (optional), initial values to apply to first \"shift\" elemnts\n    \"\"\"\n    _da = dataArray.shift({index.name:(shift*-1)})\n    if not initialValues is None:\n        _da = _da.fillna(initialValues)\n    return _da\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "dynamic", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Dynamic", "units": null, "w": 179, "x": 505, "y": 238, "z": 1}, {"color": "#EEEEEE", "definition": null, "description": "Pyplan XArray Extensions - 21-Aug-2019", "errorInDef": false, "extraData": null, "h": 521, "identifier": "a46ff2bbf32b248e9abbbeed6c482547b", "moduleId": "pyplan_xarray_extensions", "nodeClass": "text", "nodeFont": "Helvetica,15", "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 0, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 1}, "originalId": null, "picture": null, "title": null, "units": null, "w": 851, "x": 46, "y": 53, "z": -1}, {"color": null, "definition": "def _fn(dataArray, index, position):\r\n    \"\"\"\r\n    Filter dataArray by integer position along the specified index.\r\n    \r\n    dataArray: dataArray to be filtered\r\n    index: pp.index \r\n    position: int \r\n        Ex.\r\n            pp.isel(dataArray1, index1, 0)\r\n    \"\"\"\r\n    if not isinstance(dataArray,xr.DataArray):\r\n        raise ValueError(\"the 'dataArray' parameter must be of the type xr.DataArray\")\r\n    return dataArray.isel({index.name:position},drop=True)\r\n    \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "slice_dataarray", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Slice", "units": null, "w": 179, "x": 505, "y": 275, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(param):\n   return xr.DataArray(param.values,[param])\n   \n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "to_dataarray", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "To Dataarray", "units": null, "w": 179, "x": 306, "y": 423, "z": 1}, {"color": null, "definition": "def _fn(dataArray,value=0):\r\n    \"\"\"Fill np.inf values with default value\r\n        Ex.\r\n            fill_inf(dataArray,0)\r\n    \"\"\"\r\n    return apply_fn(dataArray,lambda x: value if np.isinf(x) else x)\r\n    \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "fill_inf", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Fill inf", "units": null, "w": 179, "x": 505, "y": 312, "z": 1}, {"color": null, "definition": "def _fn(dataArray,value=0):\r\n    \"\"\"Fill np.inf and np.nan with default value\r\n        Ex.\r\n            fill_all(dataArray,0)\r\n    \"\"\"\r\n    return fill_inf(dataArray.fillna(value),value)\r\n    \r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "fill_all", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Fill all", "units": null, "w": 179, "x": 505, "y": 349, "z": 1}, {"color": "#cb98ff", "definition": "def _fn( obj, applyFn, *args):\n    \"\"\" Apply \"applyFn\" to \"obj\" where obj can be DataArray or Index\n    \"\"\"\n    vfn = np.vectorize(applyFn)\n    if isinstance(obj,pd.Index):\n        \n        return pd.Index(np.unique(vfn(obj.values,*args)))\n        \n    if isinstance(obj,xr.DataArray):\n        return xr.apply_ufunc(vfn,obj,*args)\n    return None\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "apply_fn", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Apply", "units": null, "w": 179, "x": 107, "y": 238, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(start, periods, freq='M', format='%Y.%m'):\n    \"\"\"Add periods to a date. Can set freq and output format \n        Ex.\n            pp.addPeriods('2016.01',6)\n            pp.apply( pp.addPeriods, inicio_de_proyectos , duracin_de_proyectos)\n    \"\"\"\n    if \".\" in start:\n        start = start.replace('.', '-')\n    if periods<0:\n        return pd.period_range(end=start, periods=-periods+1, freq=freq).strftime(format)[0] \n    else:\n        return pd.period_range(start=start, periods=periods+1, freq=freq).strftime(format)[-1] \n   \n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "add_periods", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Add Periods", "units": null, "w": 179, "x": 505, "y": 386, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(nodeIdX, nodeIdObjective, goal=0, startValue=1, matrixIndex=None ): \n    \"\"\" Finds the value of nodeIdX that makes nodeIdObjective equal to goal.\n    nodeIdX: String with id of node X\n    nodeIdObjective: String with id of node X\n    matrixIndex: Index for multidimensional goal seek\n    \"\"\"\n    _aa=subscript\n    _getNodeFn = globals()[\"getNode\"]\n    from scipy.optimize import newton\n    \n    if matrixIndex is None:\n    \n        def _f(x):\n            _getNodeFn(nodeIdX).definition = \"result = \" + str(x)\n            value = _getNodeFn(nodeIdObjective).result\n            return value - goal\n        \n        _res = newton(_f, x0=startValue)\n        return _res\n        \n    else:\n        _indexName=matrixIndex.name\n        for item in years:\n            def _f(x):\n                _values = _getNodeFn(nodeIdX).result\n                _values.loc[{_indexName: slice(item, item)}] = x\n                np.set_printoptions(threshold = np.prod(_values.values.shape))\n                data = np.array2string(_values.values, separator=\",\", precision=20 , formatter={'float_kind':lambda x: repr(x)}).replace('\\n','')\n                _getNodeFn(nodeIdX).definition = f\"result = xr.DataArray({data},[{_indexName}])\"\n                value = _getNodeFn(nodeIdObjective).result\n                return subscript(value,matrixIndex,item)\n            _res = newton(_f, x0=1)\n\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "goal_seek", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Goal Seek", "units": null, "w": 179, "x": 306, "y": 460, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(rate, flow, time_index, offset = 1): \n    \"\"\"\"Returns the Net Present Value (NPV) of a cash flow with equally spaced periods. The flow parameter must contain a series of periodic payments (negative values) and inflows (positive values), indexed by time_index.\n        The optional offset parameter especifies the offset of the first value relative to the current time period. By default, offset is set to 1, indicating that the first value is discounted as if it is one step in the future\n    \"\"\"\n    _number_of_periods = get_pos(time_index) + offset \n    _present_values = flow / ( 1 + rate ) ** _number_of_periods \n    _npv = _present_values.sum(time_index.name ) \n    return _npv\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "npv", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "NPV", "units": null, "w": 179, "x": 505, "y": 423, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(flow, time_index ):\n    \"\"\"Returns the Internal Rate of Return (IRR) of a series of periodic payments (negative values) and inflows (positive values). The IRR is the discount rate at which the Net Present Value (NPV) of the flows equals zero. \n        The variable flow must be indexed by time_index.\n\n    If the cash flow never changes sign, cp.irr() has no solution and returns NAN (Not A Number).\n    \"\"\"\n    import pandas as pd\n    _getNodeFn = globals()[\"getNode\"]\n    \n\n    _rest_of_indexes_labels = np.setdiff1d( flow.dims, [time_index.name])\n\n    _cube = None\n    if len( _rest_of_indexes_labels ) == 0: \n        _cube = np.irr( flow.values ) \n    else:\n        _rest_of_indexes = [_getNodeFn(xx).result for xx in _rest_of_indexes_labels]\n        _cube = create_dataarray(0.,_rest_of_indexes)\n        _multivalues = [idx.values for idx in _rest_of_indexes] \n        _values = pd.MultiIndex.from_product( _multivalues ).values \n        \n        for _item in _values: \n            _filter = {}\n\n            for _nn in range(len(_item)): \n                _filter[ _rest_of_indexes[_nn].name ] = _item[_nn]\n                \n            _toIrr = flow.sel(_filter).values\n            _irr = np.irr( _toIrr ) \n            _cube.loc[_filter] = _irr\n\n\n    return _cube\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "irr", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "IRR", "units": null, "w": 179, "x": 107, "y": 460, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(investments, usefulLife, timeIndex, includeInCurrentMonth=False):\n    \"\"\" TODO: comment\n        investments: investments\n        usefulLife: useful life in years\n    \n        Ex.\n            linear_depreciation(investments, usefulLife)\n    \"\"\"\n    \n    timeCoords = xr.DataArray(timeIndex.values, [timeIndex])\n    _cuota = investments/usefulLife/12\n    _newTime = xr.DataArray( timeCoords.values, [('new_time',timeCoords.values ) ] )\n    _ending = apply_fn(timeCoords, add_periods, usefulLife*12)\n    if includeInCurrentMonth:\n        _proy = xr.where( (_newTime >= timeCoords) & (_newTime < _ending), _cuota , 0  )\n    else:\n        _proy = xr.where( (_newTime > timeCoords) & (_newTime <= _ending), _cuota , 0  )\n    _final = _proy.sum(timeIndex.name)\n    _final = _final.rename({\"new_time\":timeIndex.name})\n    return _final\n   \n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "linear_depreciation", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Linear depreciation", "units": null, "w": 179, "x": 107, "y": 423, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(dataArray, sortValues=True):\n    \"\"\"Generates a pd.Index with the unique values of the dataArray.\n    \"\"\"\n    np_values = dataArray.values.flatten()\n    \n    # Numpy unique function automatically reorders. Pandas unique, does not. \n    if sortValues is True:\n        return pd.Index(np.unique(np_values))\n    else:\n        return pd.Index(np_values).unique()\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "copy_index", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Copy Index", "units": null, "w": 179, "x": 505, "y": 460, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(source, targetId):\n    \"\"\"Copy values of datArray \"source\" into dataArray with id 'targetId'. This function alter the definition of dataArray with 'targetId' identifier.\n            source: dataArray/index from copy values\n            targetId: identifier (string) of the target node \n    \"\"\"\n    \n    _getNodeFn = globals()[\"getNode\"]\n\n    if isinstance(source,str):\n        source = self.node.model._getNodeFn(source).result\n\n\n    if not isinstance(source,xr.DataArray) and not isinstance(source,pd.Index) and not isinstance(source,float) and not isinstance(source,int):\n        raise ValueError(\"The 'source' parameter must be a xr.DataArray, pd.Index, float or int\")\n\n    if not isinstance(targetId,str):\n        raise ValueError(\"The 'targetId' parameter must be a string (identifier of node)\")\n    \n        \n    newDef = \"\"\n    if isinstance(source,float) or isinstance(source,int):\n        newDef = f\"result = {str(source)}\" \n    elif isinstance(source,xr.DataArray):\n        _indexes = str(list(source.dims)).replace(\"'\",'')\n        np.set_printoptions(threshold = np.prod(source.values.shape))\n        _data = np.array2string(source.values, separator=\",\", precision=20 , formatter={'float_kind':lambda x: repr(x)}).replace('\\n','')\n        newDef = f\"result = xr.DataArray({_data},{_indexes})\"\n    elif isinstance(source,pd.Index):\n        np.set_printoptions(threshold = np.prod(source.values.shape))\n        _data = np.array2string(source.values, separator=\",\", precision=20 , formatter={'float_kind':lambda x: repr(x)}).replace('\\n','')\n        newDef = f\"result = pd.Index({_data})\"\n    \n    _getNodeFn(targetId).definition = newDef\n    return True\n\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "copy_as_values", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Copy as values", "units": null, "w": 179, "x": 106, "y": 497, "z": 1}, {"color": "#cb98ff", "definition": "def _sequence(_start, _end, _step=1):\n   \"\"\"\n   Returns a pd.Index with the sequence between 'start' and 'end' parameters. Both limits are inclusive. Values are converted to string.\n   \"\"\"\n   \n   try:\n       _start = int(_start)\n       _end = int(_end) + 1\n       _step = int(_step)\n   except:\n       raise ValueError(\"Only numbers are allowed as 'start', 'end' and 'step' parameters\")\n   \n   _list = [str(x) for x in range(_start, _end, _step)]\n   _index = pd.Index(_list)\n   return _index\n\nresult = _sequence", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "sequence_index", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Sequence Index", "units": null, "w": 179, "x": 505, "y": 497, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(dataframe, domainDic, valueColumns, defaultValue = None, valueColumnsAsDim = True, sumDuplicateRecords = True):\r\n    \"\"\" Returns a DataArray (valueColumns is string or (valueColumns is pd.Index and valueColumnsAsDim is True)) or Dataset (valueColumns is a list or (valueColumns is a pd.Index and valueColumnsAsDim is False)) from a Pandas dataframe applying the set_domain function.\r\n    dataframe: Pandas dataframe with no index columns.\r\n    domainDic: Dictionary of column names and index names. Ex. {'Column Name': index_name}.\r\n    valueColumns: String, list or pd.Index. Dataframe's value columns.\r\n    defaultValue: Default value when applying set_domain function.\r\n    valueColumnsAsDim: If True, valueColumns becomes a dimension of resulting DataArray. If False, each value column becomes a variable of the resulting Dataset.\r\n    sumDuplicateRecords: If True, sums identical rows. Otherwise, removes duplicates (except the first one). \r\n    \r\n    Ex. pandas_to_dataarray(sales_dataframe, {'Sales Channel': sales_channels, 'Market Segment': market_segments, 'Month': time}, 'Sales', 0.)\r\n    \"\"\"\r\n    _index_value_columns = None\r\n    \r\n    # Check if valueColumns is string, list, np.ndarray or pd.Index (transform to list) and indexes is dict.\r\n    if isinstance(valueColumns, pd.Index):\r\n        _index_value_columns = valueColumns.copy()\r\n        _index_value_columns_name = _index_value_columns.name\r\n        valueColumns = valueColumns.values.tolist()\r\n    elif isinstance(valueColumns, np.ndarray):\r\n        valueColumns = valueColumns.tolist()\r\n    elif not isinstance(valueColumns, str) and not isinstance(valueColumns, list):\r\n        raise ValueError(\"valueColumns must be a string, a list or a pd.Index\")\r\n    if not isinstance(domainDic, dict):\r\n        raise ValueError(\"Indexes must be a dictionary\")\r\n    \r\n    # Transform indexes into list and create list with all columns.\r\n    _index_cols = list(domainDic.keys())\r\n    _cols = _index_cols.copy()\r\n    \r\n    if isinstance(valueColumns, list):\r\n        _cols = _cols + valueColumns\r\n    else:\r\n        _cols.append(valueColumns)\r\n    \r\n    # If valueColumnsAsDim is True, check if every column is in dataframe and filter it.\r\n    if (valueColumnsAsDim is True) and isinstance(_index_value_columns, pd.Index):\r\n        _df_columns = dataframe.columns.values.tolist()\r\n        _cols = [value for value in _df_columns if value in _cols]\r\n    \r\n    # Filter dataframe by columns.\r\n    _df = dataframe[_cols]\r\n    \r\n    # Sum identical rows or remove duplicates.\r\n    if sumDuplicateRecords is True:\r\n        _df = _df.groupby(_index_cols, as_index = False).sum()\r\n    else:\r\n        _duplicate_rows =_df.duplicated(_index_cols)\r\n        _df = _df[~_duplicate_rows]\r\n    \r\n    # If valueColumnsAsDim is True, melt valueColumns.\r\n    if (valueColumnsAsDim is True) and isinstance(_index_value_columns, pd.Index):\r\n        # Unpivot dataframe from wide format to long format by valueColumns.\r\n        _df = pd.melt(_df, id_vars = _index_cols, value_vars = _index_value_columns, var_name = _index_value_columns_name, value_name = 'values')\r\n        _index_cols = _index_cols + [_index_value_columns_name]\r\n        domainDic[_index_value_columns_name] = _index_value_columns\r\n        \r\n        # Create DataArray\r\n        _data = _df.set_index(_index_cols)['values'].to_xarray()\r\n        \r\n        # Appy set_domain function to DataArray / Dataset.\r\n        _data = set_domain(_data, domainDic, defaultValue)\r\n    else:\r\n        # Create DataArray / Dataset.\r\n        _data = _df.set_index(_index_cols)[valueColumns].to_xarray()\r\n        \r\n        # Appy set_domain function to DataArray / Dataset.\r\n        _data = set_domain(_data, domainDic, defaultValue)\r\n        \r\n    return _data\r\n\r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "dataarray_from_pandas", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "DataArray from Pandas", "units": null, "w": 179, "x": 306, "y": 349, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(dataArray, targetValue, targetIndex, method = 'Last'):\n    \"\"\" Returns a dataArray containing the value of targetIndex for which dataArray (indexed by targetIndex) is equal to targetValue.\n    dataArray: Xarray dataArray.\n    targetValue: Integer, Float or String.\n    targetIndex: Pandas Index.\n    method: There are two options: \"Last\" returns the last occurrence of targetIndex for which dataArray is equal to targetValue. \"First\" returns the first occurrence.\n    \"\"\"\n    \n    # Equals dataArray to targetValue and cumulates it along targetIndex.\n    _matriz_1_0 = xr.where(dataArray == targetValue, 1, 0)\n    _matriz_1_0_acum = xr.where(_matriz_1_0 == 1, _matriz_1_0.cumsum(targetIndex.name), 0)\n    \n    if method == 'Last':\n        # Get max cumulated value along targetIndex\n        _max = _matriz_1_0_acum.max(targetIndex.name)\n        _max = xr.where(_max == 0, np.nan, _max)\n        _matriz_max = xr.where(_matriz_1_0_acum == _max, to_dataarray(targetIndex), np.nan)\n        return _matriz_max.max(targetIndex.name)\n    elif method == 'First':\n        # Get min (1) cumulated value along targetIndex\n        _matriz_min = xr.where(_matriz_1_0_acum == 1, to_dataarray(targetIndex), np.nan)\n        return _matriz_min.max(targetIndex.name)\n    else:\n        raise ValueError(\"Insert a valid method\")\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "subindex", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Subindex", "units": null, "w": 179, "x": 700, "y": 90, "z": 1}, {"color": "#cb98ff", "definition": "def _concat_rows(array_param, index_param):\n   _index = pd.Index([])\n   for i in index_param.values:\n       _index = concat_index(_index , pd.Index(array_param.sel({index_param.name:i}, drop=True).values))\n   return _index\n\nresult = _concat_rows", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "concat_rows", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Concat Rows", "units": null, "w": 179, "x": 700, "y": 127, "z": 1}, {"color": "#cb98ff", "definition": "import plotly.io as pio\nfrom plotly.graph_objs._figure import Figure\n\ndef _fn(fig, **kwargs):\n    \"\"\"\n        Generate HTML with plotly chart\n        Params:\n            fig: plotly fig\n    \"\"\"\n    if isinstance(fig, dict):\n        fig = Figure(fig)\n    \n    if isinstance(fig,Figure):\n        if not \"layout\" in fig or not \"margin\" in fig[\"layout\"] or fig[\"layout\"][\"margin\"][\"b\"] is None:\n            fig.update_layout(margin=dict(b=10))\n        if not \"layout\" in fig or not \"margin\" in fig[\"layout\"] or fig[\"layout\"][\"margin\"][\"t\"] is None:\n            fig.update_layout(margin=dict(t=10))\n        if not \"layout\" in fig or not \"margin\" in fig[\"layout\"] or fig[\"layout\"][\"margin\"][\"l\"] is None:\n            fig.update_layout(margin=dict(l=10))\n            \n\n    return pio.to_html(fig,full_html=False, include_plotlyjs=False, **kwargs)\n\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "plot", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Plot", "units": null, "w": 179, "x": 700, "y": 164, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(task_state=\"PROGRESS\",task_description=None,task_activity=None, task_info=None):\n    \"\"\"\n        Generate log entry. Used for schedule tasks\n        params:\n          task_state: PROGRESS, INFO, WARNING, FAILURE, RETRY, SUCCESS, REVOKED, STARTED, PENDING, RECEIVED\n          task_description: Shot description of task. example: start process\n          task_activity: other short description\n          task_info: json with more info \n    \"\"\"\n\n    import requests\n    from os import environ\n    import json\n    _params = {\n            \"state\": task_state,\n            \"description\": task_description,\n            \"activity\": task_activity,\n            \"info\": json.dumps(task_info)}\n    \n    res=None\n\n    if task_log_endpoint:\n        base_host = environ['PYPLAN_API_HOST'] + task_log_endpoint\n        res = requests.post(base_host, data=_params)\n    else:\n        print(str(_params))\n        \n    return res\n\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "log_task", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Log Task", "units": null, "w": 179, "x": 700, "y": 201, "z": 1}, {"color": "#cb98ff", "definition": "def _fn(filepath):\n    from pyxlsb import open_workbook as open_xlsb\n    \n    _df = []\n    \n    with open_xlsb(filepath) as wb:\n        with wb.get_sheet(1) as sheet:\n            for row in sheet.rows():\n                _df.append([item.v for item in row])\n    \n    return pd.DataFrame(_df[1:], columns = _df[0])\n\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 33, "identifier": "pandas_from_xlsb_file", "moduleId": "pyplan_xarray_extensions", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Pandas from XLSB File", "units": null, "w": 179, "x": 700, "y": 238, "z": 1}, {"color": "#cb98ff", "definition": "# marc_value must be a xr.DataArray to be considered\r\ndef _fn(demand,ranges,consumption_range_index=None,marc_value=None):\r\n  if consumption_range_index is None:\r\n      if ranges.ndim==1:\r\n          consumption_range_index = ranges.dims[0]\r\n      else:\r\n          raise ValueError(\"You must specify the consumption_range_index\")\r\n  elif isinstance(consumption_range_index,pd.Index):\r\n      consumption_range_index = consumption_range_index.name\r\n  ranges_1 = ranges.shift(shifts={consumption_range_index:1}).fillna(-1) #Se coloca el \"-1\" por que si hay consumo 0 genera error en la asignaci\u00f3n\r\n  if isinstance(marc_value, xr.DataArray)==True:\r\n      ConsEnRangos = (demand<=ranges)*(demand>ranges_1)*marc_value\r\n  else:\r\n      ConsEnRangos = (demand<=ranges)*(demand>ranges_1)\r\n  return ConsEnRangos\r\nresult = _fn", "description": null, "errorInDef": false, "extraData": null, "h": 30, "identifier": "band_allocation", "moduleId": "novix_library", "nodeClass": "function", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 0, "showLabel": 1, "showOutputs": 0, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Band Allocation", "units": null, "w": 176, "x": 832, "y": 652, "z": 1}, {"color": "#4CBCFF", "definition": "result = to_dataarray(time)", "description": null, "errorInDef": false, "extraData": null, "h": 30, "identifier": "data_array_time", "moduleId": "novix_library", "nodeClass": "variable", "nodeFont": null, "nodeInfo": {"__dict__": {}, "fill": 1, "py/object": "app.classes.NodeInfo.NodeInfo", "showBorder": 1, "showInputs": 1, "showLabel": 1, "showOutputs": 1, "useNodeFont": 0}, "originalId": null, "picture": null, "title": "Data Array Time", "units": null, "w": 184, "x": 580, "y": 698, "z": 1}]}