ace.define("ace/mode/ade_highlight_rules",
  ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"],
  function (require, exports, module) {
    "use strict";

    // to complete 
    var classActiveX = " ";
    var classAlias = " ";
    var classButton = " ";
    var classChance = " ";
    var classConstant = " ";
    var classConstraint = " ";
    var classDecision = " ";
    var classDeterm = " ";
    var classExcelWorkbook = " ";
    var classForm = " ";
    var classFormNode = " ";
    var classFunction = " ";
    var classGraphStyleTemplate = " "; //"GST_AfternoonBlueSky|GST_Blue_Surround|GST_FireRed|GST_Teal_Pastel";
    var classIndex = " ";
    var classLocalVar = " ";
    var classLibrary = " ";
    var classLinkLibrary = " ";
    var classLinkModule = " ";
    var classModel = " ";
    var classModule = " ";
    var classObjective = " ";
    var classPicture = " ";
    var classPluginFunction = " ";
    var classPluginLibrary = " ";
    var classText = " ";
    var classVariable = " ";

    var classAttribute = "Aliases|Att_AreaFill|Att_Assignees|Att_Assigners|Att_AttributeType|Att_BarOverlap|Att_BrowseOnly|Att_CanBeIn|Att_CatLineStyle|Att_CellFmtKids|Att_CellFmtParents|Att_checkKids|Att_checkParents|Att_ChoiceIndexes|Att_classesTracked|Att_classTrackers|Att_clearTypeFonts|Att_ClusterIndex|Att_ColorRole|Att_ColorSeqSubsets|Att_ColorSeqSuperset|Att_ColorSequence|Att_Computed_Relsd|Att_ContLineStyle|Att_CoordinateIndex|Att_DerefReformVal|Att_Dirties|Att_Dirty|Att_DomainFor|Att_DomainIndex|Att_DomainInputs|Att_DomainOutputs|Att_DomainShallow|Att_DynamicLoopId|Att_DynLoopIndexes|Att_EditSliceState|Att_EvalMode_Dep|Att_ExogenousValues|Att_FixedAttribute|Att_FixedOnChange|Att_FixedOnClick|Att_ForceCategorical|Att_FormatDependents|Att_GraphIndexRange|Att_GraphRoles|Att_GraphSetupSlices|Att_GraphTemplate|Att_GraphValueRange|Att_HyperLinkPref|Att_indexValSrcInfo|Att_IsTableIndexAtt|Att_noDependInputs|Att_noDependOutputs|Att_Obfuscated|Att_OnChangeAssignee|Att_OnChangeAssigner|Att_OnChangeInputs|Att_OnChangeKids|Att_optDimensionKids|Att_OriginRole|Att_PreLoadScript|Att_PrevDomainValue|Att_PrevIndexValue|Att_ReadOnly|Att_RecordDepends|Att_RecordSet|Att_RelProportion|Att_ResultSliceState|Att_ReverseOrder|Att_ReverseValOrder|Att_Rlm_License|Att_Rlm_LicenseObj|Att_Saveable|Att_SaveAlways|Att_SelectedTab|Att_Showable|Att_SlicerPopupSize|Att_StackedBar|Att_Stacked_Lines|Att_StackingIndex|Att_SymbolRole|Att_SymbolSizeRole|Att_Symmetric_Colors|Att_UnfixedAttribute|Att_UsedByPrevIndex|Att_UsedInExogenous|Att_usedInReform|Att_VersionRange|Att_WaterfallBar|Att_whenDisallowed|Att_WikiHelpURL|Att_XRole|Att_YRole|Att__BarOrigin|Att__CachedIndexVals|Att__CloakDefn|Att__CustomFormat|Att__DiagramPrintSca|Att__DiscretenessInf|Att__GraphPrintScali|Att__ObjectPrintScal|Att__OutlinePrintSca|Att__TablePrintScali|Att__TotalsIndex|Att__VersionRequired|Author|BalloonHelp|CachingMethod|CellFormatExpression|ChartLibrary|ChartName|Check|CICN|Class|CloudPlayerStyles|Contains|CorrespondenceMethod|Date|DefaultExprAssistLvl|DefaultSize|Definition|DefnState|DensityNumberFormat|Derived|Description|DiagramColor|DiagState|DisplayInputs|DisplayOutputs|Domain|DomainExpr|DomainValue|DynamicValue|DynInputs|DynOutputs|EvaluationTime|EvaluationTimeAll|ExpressnAssistLevel|FileInfo|FixedCellFormatExpr|FixedCheck|FixedDef|FixedOptGuess|FontStyle|GraphSetup|Icon|Identifier|Imports|IndexVals|InObjs|Inputs|IsIn|LastError|LinkedReform|MetaOnly|ModAuthor|Mode|Moniker|MonikerDataFormat|NeededBy|Needs|NodeColor|NodeFont|NodeFontColor|NodeInfo|NodeLocation|NodeSize|NumberFormat|OleGraph|OnChange|OnClick|OptDimensions|OptInitialGuess|OrigContains|Original|OutlinerState|Outputs|PageSetup|ParameterEnumeration|Parameters|ParamNames|ParamTypes|PdfValue|Pict|ProactivelyEvaluate|ProbabilityNumberFmt|ProbValue|Publisher|Range|Recursive|ReformDef|ReformVal|Role|SaveAuthor|SaveDate|Script|Section|Subscriber|TableCellDefault|TemplateInput|TemplateOutput|Title|Units|UpdateLink|UseCheck|Value|ValueState|Warnings|WarnUndefCell|WindState|XyExpr";
    var classCommand = "AllShow|AskAttribute|BrowseModeOn|Bye|Clock|Close|CloseGraph|Delete|Edit|End|EndObfuscated|EndPhoto|Export|FreePassObjectCount|Graph|Help|IacQuit|Import|Include|List|MakeChangesInTable|MakeSticky|Manual|MoreHelp|Move|Need|News|Obfuscated|Open|PausePhoto|Photo|PrintTable|Profile|PublishToCloud|ReadFile|Rename|ResetEvalTimes|ResumePhoto|ResynchAllWindows|Save|Show|ShowAboutAnalytica|ShowAnalyticaLicense|ShowAskAttribute|ShowContactLumina|SkipOverNextLines|SoftwareVersion|SpliceIndex|SpliceTable|Tree|Tutorial|What|Why|WhyAll|With";
    var classKeyword = "All|And|ArrayT|ArrayType|Ascending|Atomic|Begin|Coerce|Context|CustomType|Descending|DetermType|Diagram|Do|DomCategorical|DomContinuous|DomDiscreteNumeric|Each|Else|Every|Expr|For|FullScreen|HyperTalk|If|IfAll|IfOnly|In|IndexType|ListType|LocalAlias|LvarType|MetaIndex|MetaVar|NoKey|NonNegative|Not|Numeric|Of|Optional|Or|Output|Over|Positive|Prob|Rectangular|ReferenceType|Result|Samp|Scalar|Self|Span|Sticky|Sys_ContextSamp|TextType|TexType|Then|Undef|Unevaluated|Using|VarList|VarType|Vector|_End";
    var classObject = "ActiveX|Alias|Var|Attribute|Button|Chance|Command|Constant|Constraint|Decision|Determ|ExcelWorkbook|Form|FormNode|Function|GraphStyleTemplate|Index|Keyword|Library|LinkLibrary|LinkModule|LocalVar|Model|Module|Object|Objective|Picture|PluginFunction|PluginLibrary|SysFunction|SysLibrary|SysVar|Text|Variable";
    var classSysFunction = "@[I=u]|Abs|AddIndex|Aggregate|AnalyticaLicenseInfo|ArcCos|ArcCosH|ArcSin|ArcSinH|ArcTan|ArcTan2|ArcTanH|Area|ArgMax|ArgMin|Array|Asc|AskMsgChoice|AskMsgNumber|AskMsgText|AttribGet|Average|Bernoulli|BesselI|BesselJ|BesselK|BesselY|Beta|BetaFn|BetaI|BetaIaInv|BetaIInv|Binomial|BitAnd|BitCount|BitNot|BitOr|BitShift|BitXOr|Boolean|Cdf|Ceil|CellAlignment|CellBorder|CellFill|CellFont|CellFormats|CellMerge|CellNumberFormat|Certain|ChanceDist|Checkbox|ChiSquared|Choice|Chr|COMArray|Combinations|COMCallMethod|COMCreateObject|COMGetProperty|ComplexDegrees|ComplexRadians|CompressMemoryUsedBy|ComputedBy|COMPutProperty|Concat|ConcatRows|CondMax|CondMin|Conj|Continuous|CopyIndex|Correlation|Cos|CosH|Covariance|CreateNewObject|CubicInterp|CumDist|CumIPmt|CumNormal|CumNormalInv|CumPrinc|CumProduct|Cumulate|CumWilcoxon|CumWilcoxonInv|CurrentDataDirectory|CurrentDataFolder|CurrentModelDirector|CurrentModelFolder|CustomizeBalloonHelp|DateAdd|DatePart|DbLabels|DbQuery|DbTable|DbTableNames|DbWrite|Decompose|DefineOptimization|Degrees|Determinant|DetermTable|Discrete|Dispatch|DomainAllowed|DomainIntegerGroup|DomainLowerBound|DomainNullOk|DomainType|DomainUpperBound|DotProduct|DyDx|DyDx_Elas_Twiddle|Dynamic|EigenDecomp|Elasticity|Erf|ErfInv|Error|Evaluate|EvaluateScript|Exp|Exponential|Factorial|FFT|FFTInv|FindInText|FindObjects|FindPolynomialZeroes|Floor|ForLocal|Fractiles|Frequency|FunctionOf|Fv|Gamma|GammaFn|GammaI|GammaIInv|Geometric|GetArrowsOnDiagram|GetEvaluationContext|GetFract|GetProcessInfo|GetRegistryValue|GetVariableByName|GroupedInteger|Handle|HandleFromIdentifier|HyperGeometric|IdenSubscript|IdentPred|If0|IfPos|IgnoreWarnings|ImPart|IndexesOf|IndexLocal|IndexNames|IndexValue|Integer|Integrate|IntraTable|Invert|IPmt|Irr|IsDateTime|IsHandle|IsNaN|IsNotSpecified|IsNull|IsNumber|IsRealNumber|IsReference|IsResultComputed|IsText|IsUndef|Iterate|Join|JoinText|Kurtosis|LGamma|LinearInterp|LinearTermAtom|ListOfHandles|Ln|Logistic|LogisticRegression|Logit|LogNormal|LogTen|LpDefine|LpFindIIS|LpObjSa|LpOpt|LpRead|LpReducedCost|LpRhsSa|LpShadow|LpSlack|LpSolution|LpStatusNum|LpStatusText|LpWrite|LpWriteIIS|MakeDate|MakeTime|MatrixMultiply|Max|MdArrayToTable|MdTable|MdxQuery|Mean|Median|MemoryInUseBy|Mid|Min|MIrr|Mod|MonoCubicInterp|MsgBox|MultiTable|NegativeBinomial|NlpDefine|Normal|Normalize|NPer|Npv|NumberToText|OpenExcelFile|OpenURL|OptEngineInfo|OptFindIIS|OptGuess|OptInfo|OptMarginalValue|OptObjective|OptObjectiveSa|OptRead|OptReducedCost|OptRhsSa|OptScalarToConstrain|OptScalarToDecision|OptShadow|OptSlack|OptSolution|OptStatusNum|OptStatusText|OptWrite|OptWriteIIS|ParseDate|ParsedExprFunction|ParsedExprParameters|ParseNumber|Pdf|Permutations|PlugTermAtom|Pmt|Poisson|PoissonRegression|PositionInIndex|PPmt|Probability|ProbBands|ProbDist|ProbitRegression|ProbTable|ProbWilcoxon|Product|ProductLog|Pv|QpDefine|QuadraticTermAtom|Q_SquareInterp|Radians|Random|Rank|RankCorrel|Rate|ReadExportFile|ReadFromURL|ReadImageFile|ReadTextFile|RealPart|Reform|Regression|ReThrow|Round|RunConsoleProcess|Sample|SaveExcelWorkbook|ScanAttFromModelFile|SDeviation|SelectText|Sequence|SetContains|SetDifference|SetEvaluationFlag|SetIntersection|SetsAreEqual|SetUnion|ShowPdfFile|ShowProgressBar|Shuffle|Sigmoid|Sign|Sin|SingularValueDecomp|SinH|SipDecode|SipEncode|Size|Skewness|Slice|SobolSequence|SolverInfo|Sort|SortIndex|Split|SplitText|SpreadsheetCell|SpreadsheetInfo|SpreadsheetOpen|SpreadsheetRange|SpreadsheetSave|SpreadsheetSetCell|SpreadsheetSetInfo|SpreadsheetSetRange|SqlDriverInfo|Sqr|Sqrt|Statistics|StepInterp|StringLength|StringLowerCase|StringMixedCase|StringReplace|StringUpperCase|StudentT|SubFindString|SubIndex|Subscript|Subset|SubString|SubTable|Sum|Sys_AllInModule|Sys_CoordIndex|Sys_LocalIndex|Table|Tan|TanH|TestHeapConsistency|TextLength|TextLowerCase|TextReplace|TextSentenceCase|TextTrim|TextUpperCase|Today|Transpose|Triangular|Truncate|Try|TypeOf|Uncumulate|Uniform|Unique|UsingLocal|Variance|VarTerm|Weibull|WhatIf|WhatIfAll|While|Wilcoxon|WorksheetCell|WorksheetRange|WriteTextFile|WriteWorksheetCell|WriteWorksheetRange|XIrr|XMIrr|XNpv|YearFrac|_InvokeMethod|_OptSetContextWrap";
    var classSysLibrary = "SysLib_AdvMath|SysLib_AppInteg|SysLib_Array|SysLib_Database|SysLib_Distribution|SysLib_Financial|SysLib_Math|SysLib_Matrix|SysLib_Operators|SysLib_Optimizer|SysLib_Root|SysLib_Special|SysLib_Statistical|SysLib_SysVars|SysLib_TextFunctions";
    var classSysVar = "Abbreviation|AllProbabilityBands|AllWarnings|AnalyticaEdition|AnalyticaPlatform|AnalyticaVersion|AttributeFontSize|AutoCompletePinRect|AutoSaveFilename|AutoSaveInterval|AutoSaveMode|BarOverlap|BarOverlap4ValueKey|BigBrother|CdfResol|CdfSteps|Checking|Delimiter|DensityIndex|DepictFoundSetOnUI|Depth|DeveloperOn|DistResol|DistribSize|DistSteps|Editor|EnableComplexNumbers|EnableEvalContextUse|EvalDynamic|EvalIndex|ExprAssistShowHelp|False|Flip|Frame|FrameAuto|FunctionAssistPinRec|GraphTool|GraphWindows|Graph_3DEffects|Graph_AdaptFontSize|Graph_AxisLabelColor|Graph_AxisLabelFont|Graph_AxisTitleColor|Graph_AxisTitleFont|Graph_BalloonFullPrc|Graph_BarShape|Graph_Cdf_Valdim|Graph_ColorSeq|Graph_CumProb_Valdim|Graph_FileEffectSeq|Graph_FillTransparen|Graph_FrameColor|Graph_GridColor|Graph_HLabelRotation|Graph_KDE_Valdim|Graph_KeyAreaBrush|Graph_KeyFont|Graph_KeyLabelColor|Graph_KeyTextColor|Graph_KeyTitleFont|Graph_LineDashSeq|Graph_LineThickness|Graph_MaxSymbolSize|Graph_MinSymbolSize|Graph_OutlineKey|Graph_PageBrush|Graph_Pdf_Valdim|Graph_PlotAreaBrush|Graph_Primary_Valdim|Graph_Prob_Valdim|Graph_RoleVisibility|Graph_Stats_Valdim|Graph_SymbolKey|Graph_SymbolSeq|Graph_SymbolSizeKey|Graph_TickDir|Graph_VLabelRotation|Grid|HeapSize|IncludeXZero|IncludeYZero|IncludeZZero|Inf|InternalSDKErrTries|IsSampleEvalMode|It|LaserHeight|LaserWidth|Levels|LineStyle|MaxEvaluationThreads|MaximumOpenWindows|MaxModelThreads|Mesh|Namesize|Naming|NaN|Null|NumberWidth|OleAutoRecompute|OnLoadWarnExceed101|Pan|Pi|PlotHeight|PlotWidth|ProbIndex|PublishOnEval|RandomSeed|RandomType|Rectangularize_inter|Rotation|Run|SampleSize|SampleType|SampleWeighting|SaveFormat|SaveOptions|SaveValues|Scales|Scoping|ScreenHeight|ScreenWidth|SelectedOptimization|ShowDescriptionMarks|ShowHier|ShowKey|ShowUndef|StatsLabels|StatsSelect|SuppressExcelAlerts|SvdIndex|Sv__DateOriginOffset|SwapEnterReturn|SymbolSize|Sys_AllNullTreatment|Sys_AllStatistics|Sys_AnimateWindows|Sys_BalloonHelp|Sys_CoefAnalysisMode|Sys_DbDatesAsText|Sys_DefaultNumberFmt|Sys_DomainSelfIndex|Sys_FixableAtts|Sys_FoundSet|Sys_IntelliSense|Sys_LinkedModules|Sys_PdfSmoothFactor|Sys_PdfSmoothMethod|Sys_PdfSmoothNumPts|Sys_ShowFontsOnPopup|Sys_TableCellDefault|Sys_WarnUndefCell|Sys_WindowsMaximized|TableFontSize|TableType|TabWidth|TerminalType|TextLocale|Ticks|Tilt|Time|True|TypeChecking|Undefined|UseTable|Verbosity|WarnOnNonIndexedOp|WebHelper|Windows|Xintervals|Xmaximum|Xminimum|Yintervals|Ymaximum|Yminimum|Zmaximum|Zminimum";

    var arrHelp = {};
    arrHelp['Abs'] = { p: 'X:atom', d: 'Abs(x) returns the absolute value of «x».<br/><br/>When «x» is a complex number, Abs(x) returns the magnitude of the complex number.' };
    arrHelp['AddIndex'] = { p: 'A : Array ; I : ... Index', d: 'Returns a new array by adding one or more indexes to an existing array. The new array is constant over the new indexes. If the new index or indexes are already present, no change is made.<br/><br/>There is a basic philosophy in Analytica that an array only needs to contain an index if its data varies along that index; hence, there is usually no need for this function. Its use primarily arises in meta-inference algorithms.<br/><br/> Examples:<br/><br/>AddIndex(A,I)<br/>  the result is indexed by I along with the original indexes of A.<br/><br/>AddIndex(A,I,J,K)<br/>  the result is indexed by I, J, and K along with the original indexes of A.' };
    arrHelp['Aggregate'] = { p: 'X:Array All[I] ; Map : Array All[I] ; I : WarnDynamic Index ; targetIndex : Index ; type : optional named atomic ; positional : optional named atomic boolean ; defaultValue : optional named atomic', d: 'Aggregates the values in array «x» over index «i» to produce a result indexed by «j», where map (indexed by «i») gives the value of «j» for each element of «i». It gives a warning if any value in map is not in index «j».<br/><br/>For example, if Population_by_country is indexed by Country and the map Continent_by_country (indexed by Country) gives the continent containing each country, where Continent is an index listing the Continents, then<br/><br/>	Aggregate(Population_by_country, Continent_by_country, Country, Continent)<br/><br/>returns the population by continent.<br/><br/>Optional parameters:<br/>«Type»:  the aggregation method, ‘Average’, ""First"", ""Last"", ‘Max’, ‘Min’, ‘Median’, or ‘Sum’ (which is the default).<br/>«Positional»: (false by default) If true, map must contain the integer positions of the corresponding element of «j» rather than their values.<br/>«defaultValue»: The value in the result array when no value in «x» maps to that value of «j». (Default is NULL.)' };
    arrHelp['AnalyticaLicenseInfo'] = { p: 'item:atomic text ; license : optional LicenseType', d: 'Returns information about the current Analytica license. The parameter can be one of the following: "Expiration", "PurchaserID" (int),"UserID", "Optimizer", "Beta", "Educational". Expiration returns the expiration date as an integer (view using date number format). Optimizer, Beta and Educational are flags.' };
    arrHelp['ArcCos'] = { p: 'X:atom', d: 'Returns the inverse cosine of «X» in degrees (0 to 180).' };
    arrHelp['ArcCosH'] = { p: 'X:atom', d: 'Returns the inverse hyperbolic cosine in degrees.' };
    arrHelp['ArcSin'] = { p: 'X:atom', d: 'Returns the inverse sine of «X» in degrees (-90 to 90).' };
    arrHelp['ArcSinH'] = { p: 'X:atom', d: 'Returns the inverse hyperbolic sine in degrees.' };
    arrHelp['ArcTan'] = { p: 'X:atom', d: 'ArcTan(X) returns the arctangent of «X» in degrees. The arctangent is the angle which has a tangent of «X».' };
    arrHelp['ArcTan2'] = { p: 'Y,X:atom', d: 'Returns the inverse tan of «Y»/«X» in degrees (-180 to 180).' };
    arrHelp['ArcTanH'] = { p: 'X:atom', d: 'Returns the inverse hyperbolic tangent in degrees.' };
    arrHelp['Area'] = { p: 'y,x : all numeric OrNull[I] ; X1,X2 : optional numeric atomic ; I : optional WarnDynamic Index = common', d: 'Area(y, x, x1, x2) returns the area (sum of trapezoids) under the curve represented by the points («x»,«y») between «x1» and «x2». If «x1» and «x2» are not specified, the area is calculated across all of «x». This is the total integral.<br/><br/>Usually «x» is a list-of-numbers index, which is also a dimension of «y». When «x» and «y» are both arrays which may have other dimensions, the common index should be specified in the parameter «I» using Area(y,x,x1,x2,I).' };
    arrHelp['ArgMax'] = { p: 'R:vector all[I];I:...recommended WarnDynamic Index; position : optional named boolean atomic', d: 'ArgMax(A,I) returns the element of «I» corresponding to the largest value of «A».  ArgMax(A,I,J,K...) returns the coordinate on indexes «I»,«J»,«K»,... where the maximum in «A» occurs. The coordinate (for >=2 dims) is indexed by a local index named .Dims. If an optional position:true flag is specified, the index position is returned rather than the index value.' };
    arrHelp['ArgMin'] = { p: 'R:vector all[I];I:...recommended WarnDynamic Index; position : optional named boolean atomic', d: 'ArgMin(A,I) returns the element of «I» corresponding to the smallest value of «A». ArgMin(A,I,J,K...) returns the coordinate on indexes «I», «K», «K», ... where the minimum in «A» occurs. The coordinate (for >=2 dims) is indexed by a local index named .Dims. If an optional position:true flag is specified, the index position is returned rather than the index value.' };
    arrHelp['Array'] = { p: 'I:...Index;A:Final Expression', d: 'Array(I1,I2,...,In,A) returns an array on the indexes I1,..,In with the contents of A.<br/><br/>Array(I,[a,b,c,d,...]) creates an array indexed by I out of the elements a,b,c,d,...<br/><br/>A(I,x) where x is atomic creates an array on I where every element is equal to x.<br/><br/>Array(I1,I2,[[a,b,c,...],[d,e,f,...],...]) creates an array on I1,I2 with the indicated elements, with I1 used as the outermost dimension.<br/><br/>The above examples are the primary "safe" uses of Array. Array can be used in several other ways that are "unsafe" in the sense that it does not array-abstract. For example, Array(I,A) will re-index the array A by index I. This is unambiguous only when A is guaranteed to be 1-D or atomic, hence it is better to use A[@J=@I] (where J is the existing index of A), which does safely array abstract if dimensions are added to your model later.' };
    arrHelp['Asc'] = { p: 'Text:coerce textual OrNull atomic ; n : optional numeric atomic', d: 'Asc(text,n) returns the numeric character code of the «n»th character in the text. «n» defaults to 1 if omitted.' };
    arrHelp['AskMsgChoice'] = { p: 'question : atom text ; title : optional Text atomic;optionList alias options:vector;default:optional atom;showAll alias inclAll,combobox alias anyTextOk:optional named boolean atomic ; optionExpr : hidden Unevaluated = optionList', d: 'Shows a choice pull-down in a pop-up window with indicated question, title, and default.<br/><br/>Parameters:<br/> <br/> «question»: Text that appears above the pulldown or combobox in the dialog<br/> «title»: Text for the dialog caption bar.<br/> «optionList»: An unindex list or 1-D array, containing the possible options.<br/> «default» (optional): The item displayed initially.<br/> «showAll» (optional): True causes an option of all" to appear.<br/> «comboBox» (optional): True causes a combobox (combination of text and pulldown) to appear.<br/> <br/>The return value is the selection item, unless all" is selected, in which case the result is the entire parameter passed to «optionList».<br/> <br/>When «comboBox» is false or unspecified, a standard pulldown displays, and thus, «optionList» contains all possible options.<br/> <br/>When «comboBox» is true, then the pulldown contains suggested values, but any single-line freeform text can be entered.' };
    arrHelp['AskMsgNumber'] = { p: 'question : atomic Text; title : optional named atomic text; default : optional named atomic numeric', d: 'Shows a message box with specified title, question and a textbox containing the default value, if any. It returns the number entered by the user into the text box. If no default is entered and no number is entered, returns NaN.' };
    arrHelp['AskMsgText'] = { p: 'question : atomic Text; title : optional named atomic text; maxText : optional named positive atom ; default : optional atomic text ; password : optional boolean atom', d: 'Shows a message box with specified title, question and a textbox containing the default text, if any, and allowing up to maxText characters. It returns the text entered by the user into the text box, or the default if none.' };
    arrHelp['AttribGet'] = { p: '«null»', d: 'AttribGet(attribute,identifier) gets the indicated attribute value from the indicated object. The first parameter is evaluated, so you will need to pass it as a text or handle. It is more customary to use the operator form of this: «attribute» of «identifier».' };
    arrHelp['Average'] = { p: 'X : QuadraticNumber OrNull Vector All[I] ; I : ... recommended index = _fromVector; IgnoreNaN : optional atomic boolean', d: 'Average(X,I) returns the average of «X» over index «I». The result has all the dimensions of «X», except for «I». Null values are not counted in either the denominator or numerator when computing the average. NaN are also ignored when IgnoreNaN:true is specified. Average( [A,B] ) can be used to find the element-wise average of «A» and «B». You can also take an average over a multi-D slice by specifying multiple indexes, e.g., Average(X,I,J).<br/><br/>Average(X,I) and Mean(X,I) are equivalent in many cases, except when the index used is Run. Average(X,Run) and Mean(X,Run) behave differently when evaluated in Mid mode. Average always evaluates «X» in context, while Mean() forces «X» to be evaluated in sample mode when the index is Run.' };
    arrHelp['Bernoulli'] = { p: 'p : nonNegative[Run] ; over : ... optional named atomic ; singleSampleMethod : optional hidden scalar', d: 'Bernoulli(P) returns a discrete probability distribution with probability «P» of result 1 and a probability (1-P) of result 0.' };
    arrHelp['BesselI'] = { p: 'X:scalar orNull;N:nonnegative orNull atom', d: 'Returns the Modified Bessel I function of order «N». The modified I Bessel function is equivalent to the usual Bessel J Bessel function evaluated for a purely imaginary argument.' };
    arrHelp['BesselJ'] = { p: 'X:scalar orNull;N:nonnegative orNull atom', d: 'Returns the J Bessel function of order «N».' };
    arrHelp['BesselK'] = { p: 'X:scalar orNull;N:nonnegative orNull atom', d: 'Returns the modified Bessel K function of order «N». The modified K Bessel function is equvalient to the regular Y Bessel function evaluated on a purely imaginary argument.' };
    arrHelp['BesselY'] = { p: 'X:scalar orNull;N:nonnegative orNull atom', d: 'Returns the Y Bessel function of order «N».' };
    arrHelp['Beta'] = { p: 'X,Y:positive[Run]; lower,upper : optional numeric[Run] ; over : ... optional named atomic ; singleSampleMethod : optional hidden scalar', d: 'Beta(X, Y, lower, upper) returns a continuous probability distribution with a range between 0 and 1 and a mean equal to X/(X+Y) when lower and upper are not specified. If they are specified, the distribution is stretched to fit that range.' };
    arrHelp['BetaFn'] = { p: 'Alpha,Beta:Numeric orNull atomic', d: 'The beta function.' };
    arrHelp['BetaI'] = { p: 'X,A,B:numeric orNull atomic', d: 'The incomplete beta function evaluated at «X».' };
    arrHelp['BetaIaInv'] = { p: 'P,X,B:numeric orNull atomic', d: 'Computes the inverse of the partial beta function BetaI(x,a,b) with respect to «a». BetaIaInv(y,x,b) returns a value for «a» such that y = BetaI(x,a,b).<br/><br/>For the inverse with respect to «x», see BetaIInv(y,a,b).' };
    arrHelp['BetaIInv'] = { p: 'P:numeric orNull reduced;A,B:numeric orNull atomic', d: 'The inverse of the incomplete beta function. BetaIInv(p,a,b) returns a value «x» such that «p» = BetaIInv(x,a,b). This is also the inverse cumulative density function (CDF) of the beta(a,b) distribution.' };
    arrHelp['Binomial'] = { p: 'n,p : nonNegative[Run] ; over : ... optional named atomic ; singleSampleMethod : optional hidden scalar', d: 'The binomial distribution describes the number of occurrences in «n» independent trials, where each trial has a probability «p».' };
    arrHelp['BitAnd'] = { p: 'X : number orNull ; I : ... recommended WarnDynamic Index', d: 'Returns the bit-wise AND of the integer portions of an array of numbers, in which the bit is only if it is on in every number. Use BitAnd([a,b]) for the bit-wise AND of two numbers.' };
    arrHelp['BitCount'] = { p: 'X:Number orNull atom ; which : optional text orNull atom', d: 'BitCount(x) counts the number of 1 bits in the 64-bit integer portion of x.<br/><br/>The optional «which» parameter can be as follows:<br/>"-0" : Number of trailing (least significant) zero bits.<br/>"-1" : Trailing 1s<br/>"0-" : leading (most significant) 0s<br/>"1-" : leading 1s.' };
    arrHelp['BitNot'] = { p: 'X:scalar OrNull', d: 'Returns the bit-wise one"s complement of the integer portion of a number.' };
    arrHelp['BitOr'] = { p: 'X : number orNull ; I : ... recommended WarnDynamic Index', d: 'Returns the bit-wise OR of the integer portion of an array of numbers, in which a bit is on when it is on in any number. Use BitOr([a,b]) for the bit-wise OR of two numbers.' };
    arrHelp['BitShift'] = { p: 'X:Number orNull [I] ; shift : scalar orNull ; left:optional boolean=false ; I:optional Index ; rotate:optional boolean atom=false ; bit : optional boolean orNull atom', d: 'BitShift(x,shift) shifts the bits of the integer portion of «x» to the right by «shift» bits. Optional parameters:<br/><br/>«left» : When true, shifts left.<br/>«I» : An index of «x», shifts across multiple 64-bit integers, with bits right-shifting into the next cell along «I».<br/>«rotate» : when true, the last bits rotate back into the first bits.<br/>«bit» : 0 or 1 to specify the value for new bits.' };
    arrHelp['BitXOr'] = { p: 'X : number orNull ; I : ... recommended WarnDynamic Index', d: 'Returns the bit-wise XOR of the integer portion of an array of numbers, which which a bit is on when it is on in an odd number of numbers.' };
    arrHelp['Boolean'] = { p: 'nullOk:optional named boolean', d: 'Boolean() is used a Domain attribute expression to specify that a variable is boolean (or binary) valued, having the values of 0 and 1 (false and true).' };
    arrHelp['Cdf'] = { p: 'x : ContextSamp[I]; I : WarnDynamic Index=Run ; w:named NonNegative ContextSamp[I]=SampleWeighting ; discrete : optional named boolean atomic ; spacingMethod alias binMethod : optional named NonNegative atomic ; samplesPerStep : optional named positive atomic ; numPoints : optional named positive atom ; reserved1 : optional hidden ; reserved2 : optional hidden ; domain : Hidden Unevaluated=x ; allX : Hidden All = x ; possibleValues : Hidden optional ; possibleValuesIndex : Hidden Index Optional', d: 'Computes the Cumulative Density Function (CDF) or Cumulative Probability Function for an uncertain or random quantity, «x».<br/><br/>Cdf can be applied to an uncertain quantity or to historical data. When «x» is an uncertain quantity, «I» is generally omitted (it is understood to be the Run index). For historical data, the data points in «x» are indexed by «I». Data points may optionally be unequally weighted by specifying «w», where «w» is also indexed by «I».<br/><br/>«discrete» : You can specify discrete:false to indicate that «x» is to be interpreted as real-valued and continuous, in which case a CDF is return. Discrete:true specifies that «x» should be interpreted as a discrete (continuous, integer-valued, etc) quantity, in which case a CPF is returned. When this is omitted, the domain of «x» is consulted when «x» is an identifier, and otherwise the values are scanned and heuristics make a best guess as to whether «x» is discrete or continuous.<br/><br/>--- Continuous Quantities ---<br/><br/>When a continuous CDF is computed, the result is indexed by a local .Step index and the Density Index. The DensityIndex="X" slice contains points where an estimate is made, and the DensityIndex="Y" slice contains the actual cumulative density estimate. You can plot the result using an XY graph by pressing the [XY] button on a result window and checking "Use comparison index".<br/><br/>«spacingMethod» : controls how the set of X values for the resulting estimate are selected. 0=Equal-X, 1=Equal-Sample-points, and 2=Equal-Weighted-P.<br/><br/>«samplesPerStep» or «numPoints» : controls how many points are plotted in the final CDF estimate.  One or the other of these should be specified. These also control the bin size for the histograms used during the estimation, and hence, a larger «samplesPerStep» or smaller «numPoints» will result in a greater averaging/smoothing effect.<br/><br/>--- Discrete Quantities ---<br/><br/>When «x» is discrete, the set of possible values is collected in a local index named .PossibleValues. The ordering of the possible values can be controlled using the domain of «x» when «x» is a single identifier. The result reflects the fraction of probability landing on or before the given values in the PossibleValues index.' };
    arrHelp['Ceil'] = { p: 'X:Number OrNull atom;digits:optional scalar;dateUnit:optional text atom', d: 'Returns the smallest integer that is greater than or equal to «X».<br/><br/>   Ceil(4.1) --> 5<br/>   Ceil(-4.1) --> -4<br/><br/>When «digits» is specified, returns the smallest number with «digits» digits past the decimal that is greater than or equal to «x», e.g.:<br/><br/>   Ceil(pi,2) --> 3.15<br/><br/>Ceil(x,dateUnit:unit) rounds a date-time number «x» upward to the nearest «dateUnit», yielding a date later than or equal to «x». The «dateUnit» parameter must be one of "Y", "Q", "M", "WD", "D", "h", "m", or "s".<br/><br/>   Ceil( MakeDate(2010,4,21), dateUnit: "M") --> 1-May-2010' };
    arrHelp['CellAlignment'] = { p: 'justification,vertJustification : optional text atom ; wrap alias wrapText : optional boolean atom ; strinkToFit : hidden optional boolean atom', d: 'Specify the alignment of text in table cells.' };
    arrHelp['CellBorder'] = { p: 'type:text orNull atom;weight:optional number atom;side:text atom;I,J:optional index;color:optional color atom ; outerInnerBlock : hidden = unique', d: 'Used to specify which cell borders to display in a table.' };
    arrHelp['CellFill'] = { p: 'color : Color atom ; alpha : optional positive atom ; color2 : hidden optional Color atom ; alpha2 : hidden optional positive atom ; gradient alias gradientType, pattern alias patternType : hidden optional text atom', d: 'Specify the background color for a cell in a table.' };
    arrHelp['CellFont'] = { p: 'face:optional text atom;size:optional number atom;color:optional color atom;bold,italics,underline: optional boolean atom;strikethru:hidden optional boolean atom', d: 'Specify the font for cells in a table' };
    arrHelp['CellFormats'] = { p: 'fmts : ...', d: 'Combine multiple cell-level formatting directives.' };
    arrHelp['CellMerge'] = { p: 'I : Index ; n : positive', d: 'Merge adjacent cells in tables.' };
    arrHelp['CellNumberFormat'] = { p: 'format alias fmt : optional text ; digits : optional positive ; showZeroes alias showZeros, thousandsSeparators alias separators : optional boolean ; currency : optional text ; dateFormat alias dateFmt : optional text ; fullPrecision alias full : optional boolean', d: 'Cell-level formatting in tables.' };
    arrHelp['Certain'] = { p: 'U ; over:...optional atomic ; singleSampleMethod : optional hidden scalar', d: 'Certain(U) returns a discrete probability distribution with certain outcome; «U» is always returned.' };
    arrHelp['ChanceDist'] = { p: 'P : NonNegative[I,Run] ; A : Array[I,Run] ; I : WarnDynamic Index=Common ; singleSampleMethod : optional atomic hidden numeric ; over : ... optional named atomic', d: 'ChanceDist(P,A,I) returns a discrete probability distribution in which the possible outcomes are given in array «A» and the probability of each outcome is given in the array «P». Both arrays «A» and «P» must be indexed by «I».' };
    arrHelp['Checkbox'] = { p: 'b : atomic boolean', d: 'The parameter to Checkbox(b) should be a literal boolean value (0 or 1). When rendered as an input control, the control appears as a checkbox, checked when the parameter is 1.' };
    arrHelp['ChiSquared'] = { p: 'dof:positive[Run] ; over : ... optional named atomic ; singleSampleMethod : optional hidden scalar', d: 'The Chi-squared distribution is used in a variety of classical statistical tests, often involving analysis of variance or contingency table tests. The sum of x^2 (the second moment) of n independent normally distributed samples follows a Chi-squared distribution with n degrees of freedom.' };
    arrHelp['Choice'] = { p: 'I : Index SelfDomain ; n : atomic NonNegative ; inclAll : optional named atomic boolean ; eval : optional named boolean atomic ; result: optional named Array[I] ; separator : optional named atom ; enabled : optional reduced hidden', d: 'Choice(I,n,inclAll) returns the nth item of the index «I». A popup menu appears in the definition field to make it easy for users to choose the term returned from index «I». The popup includes an all" choice unless the optional «inclAll» parameter is false.<br/><br/>When the elements of Choice are Handles to variables, the optional «Eval» parameter controls whether the handle is returned (eval:false) or the result of evaluating the variable (eval:true). The «Eval» parameter has no effect when «I» is Self, so that handles in the variable"s own domain are always returned as handles, unevaluated.<br/><br/>The optional «Result» parameter can be an array indexed by «I», which specifies the value returned from choice, which may be different from the elements of «I».<br/><br/>The optional «separator» indicates which value in «I» should be displayed as a non-selectable separator.' };
    arrHelp['Chr'] = { p: 'Num:numeric OrNull atomic', d: 'Returns a character with the given numeric character code.' };
    arrHelp['COMArray'] = { p: 'X : List[I] ; I : ... recommended WarnDynamic Index', d: 'Specifies the indexes and their order for an array that is being passed to an external method or call, such as when calling the method of a COM object that has an array parameter.' };
    arrHelp['Combinations'] = { p: 'k,n:scalar OrNull', d: '«k» choose «n»: number of ways «k» different items can be chosen from a bucket of «n» items.' };
    arrHelp['COMCallMethod'] = { p: 'obj : COMObject atom ; methodName : text ; parameters alias params : ... optional atom ; resultIndex : ...optional index ; concurrent : optional boolean atom', d: 'Calls a method of a COM automation object.' };
    arrHelp['COMCreateObject'] = { p: 'name : text atom; server:optional text atom; flags:optional scalar ; user : optional text atom ; pwd : optional text atom', d: 'Instantiates a COM automation object.' };
    arrHelp['COMGetProperty'] = { p: 'obj : COMObject atom ; propertyName : text ; parameters alias params : ... optional atom ; resultIndex : ...optional index ; concurrent : optional boolean atom', d: 'Gets the value of a property of an ActiveX object (a COM object that supports the IDispatch interface).' };
    arrHelp['ComplexDegrees'] = { p: 'x:atom', d: 'Returns the phase angle, in degrees, of a complex number. For real numbers, the result is the sign of the number times 180.' };
    arrHelp['ComplexRadians'] = { p: 'x:atom', d: 'Returns the phase angle, in radians, of a complex number. For real-numbers, the result is the sign of the number times PI.' };
    arrHelp['CompressMemoryUsedBy'] = { p: 'A : Array', d: 'Analytica"s internal representation of an array is able to capture certain types of sparsity in some cases. This function attempts to optimize the internal storage of «A»  by replacing dense sub-arrays in «A» with sparse versions. When this is possible, a reduction in the amount of memory used to store the array may result. The same array «A» is returned. The internal sparsity is transparent to you as a user of Analytica, but may be detected by looking at the result of the MemoryInUseBy() function.' };
    arrHelp['ComputedBy'] = { p: 'x:Variable', d: 'This function indicates that the value of the variable whose definition contains ComputedBy(x) is computed as a side-effect of another variable «x». The other variable, «x», must contain an assignment within its computation. ComputedBy() can only exist at the top-most level of a definition.' };
    arrHelp['COMPutProperty'] = { p: 'obj : COMObject atom ; propertyName : text ; value ; parameters alias params : ... optional atom ; resultIndex : ...optional index ; concurrent : optional boolean atom', d: 'Sets the value of a property of an ActiveX object (a COM object that supports the IDispatch interface).' };
    arrHelp['Concat'] = { p: 'A1 : Expression ; A2 : Expression; I,J,K : optional Index', d: 'Concat(A1,A2) concatenates two one-dimensional arrays (or lists) and returns a list result.<br/><br/>Concat ( A1, A2, I, J, K ) returns an array indexed by «K», containing the contents of arrays «A1» and «A2» joined together across indexes «I» and «J». «K» is the index formed by concatenating indexes «I» and «J». When «K» is omitted, but «I» and «J» are present, a local index named «K» is introduced.' };
    arrHelp['ConcatRows'] = { p: 'A : Array all[RowIndex,ColIndex] ; RowIndex,ColIndex : optional WarnDynamic Index ; ConcatIndex : Optional Index', d: 'Takes an array, «A» indexed by «RowIndex» & «ColIndex», and concatenates each row, henceforth flattening the array by one dimension. The result is indexed by «ConcatIndex», which (if specified) must be an index with size(RowIndex) * size(ColIndex) elements. If the «ConcatIndex» parameter is not specified, ConcatRows() introduces a local index named .ConcatIndex.' };
    arrHelp['CondMax'] = { p: 'X,cond : Array [I] ; I : ... optional Index ; caseInsensitive : optional boolean reduced', d: 'Returns the largest value in «x» among those in which the corresponding condition, «cond», is non-zero. Both «x» and «cond» should be indexed by «I». If «cond» is FALSE everywhere along «I», returns -INF.' };
    arrHelp['CondMin'] = { p: 'X,cond : Array [I] ; I : ... optional Index ; caseInsensitive : optional boolean reduced', d: 'Returns the smallest value in «x» among those in which the corresponding condition, «cond», is non-zero. Both «x» and «cond» should be indexed by «I». If «cond» is FALSE everywhere along «I», returns INF.' };
    arrHelp['Conj'] = { p: 'x:atom', d: 'Returns the complex conjugate of a complex number. <br/><br/>Conj(4+3j) → 4-3j' };
    arrHelp['Continuous'] = { p: 'lb,ub:optional named Number;orZero alias semicontinuous zero:optional named boolean;nullOk:optional named boolean', d: 'Continuous() is used in a domain attribute expression to specify that a variable is real-valued. Lower or upper bounds can optionally be specified using Continuous(lb,ub).<br/><br/>A semi-continuous variable is one that requires the variable to be between «lb» and «ub», or it may be 0. For example, to specify that the variable may be 0 or may be a value greater than 10, use:<br/>	 Continuous( lb:10, zero:true )' };
    arrHelp['CopyIndex'] = { p: 'I', d: 'Returns an unindexed list containing the values in «I». «I» must be an index or 1-D array.' };
    arrHelp['Correlation'] = { p: 'X,Y : all Numeric orNull ContextSamp[I] ; I : WarnDynamic Index=Run ; w : NonNegative orNull ContextSamp[I] = SampleWeighting', d: 'Correlation(X,Y) returns the correlation coefficient between expressions «X» and «Y». This is -1 if the two expressions are perfectly negatively correlated, 0 if they have no correlation, and +1 if they are perfectly positively correlated.<br/><br/>Use Correlation(X,Y,I) for correlation across an index other than Run, and Correlation(X,Y,w:w) for weighted correlation.<br/><br/>To compute a correlation matrix from data «X», where each point is a vector indexed by R, and the points are indexed by «I», use:<br/>  Index R2:=R;<br/>  Correlation( X, X[R=R2], I )' };
    arrHelp['Cos'] = { p: 'X:atom', d: 'Cos(X) returns the cosine of «X», where «X» is assumed to be in degrees.' };
    arrHelp['CosH'] = { p: 'Degrees:atom', d: 'Returns the hyperbolic cosine.' };
    arrHelp['Covariance'] = { p: 'X,Y : all CNumber OrNull ContextSamp[I] ; I : WarnDynamic Index=Run ; w : NonNegative OrNull ContextSamp[I] = SampleWeighting', d: 'Covariance(X,Y) returns the covariance between expressions X and Y.<br/><br/>Use Covariance(X,Y,I) for correlation across an index other than Run, and Covariance(X,Y,w:w) for weighted correlation.<br/><br/>To compute a covariance matrix from data where each point is a vector indexed by I, and points are indexed by R, use:<br/>  Index I2:=I;<br/>  Covariance( X, X[I=I2], R )' };
    arrHelp['CreateNewObject'] = { p: 'class : coerce class atom ; inModule : coerce module atom ; title,identifier : optional text atom ; original : optional coerce handle atom', d: 'Creates a new Analytica object in the global name space and returns a handle to it. <br/><br/>«class» specifies the type of object, such as Variable, Chance, Index, Module, FormNode, etc. <br/><br/>«inModule» identifies the module where the object should be placed.<br/><br/>«Title» is optional title text.<br/><br/>«Identifier» is the desired identifier. If an object with that identifier already exists, it will be made unique by adding numbers to the end. If not specified, the «title» or «class» will be used to generate an identifier.<br/><br/>«original» is used when creating an Alias or FormNode, and specifies the original object.' };
    arrHelp['CubicInterp'] = { p: 'D alias xi: Ascending Number OrNull All[I] ; R alias yi:Number OrNull All[I];X:Number OrNull Reduced;I:WarnDynamic Index=common', d: 'CubicInterp(D, R, X, I) finds the two values closest to «X» in array «D» and returns the cubic interpolated value between the corresponding values of array «R». «D» and «R» must be indexed by «I», and the interpolation will occur along dimension «I».' };
    arrHelp['CumDist'] = { p: 'P : NonNegative[I,Run] ; R : ascending Numeric[I,Run] ; I : WarnDynamic Index=Common ; Smooth : optional boolean[] ; singleSampleMethod : optional atomic hidden numeric ; over : ... optional named atomic', d: 'CumDist(P,R,I) returns a cumulative probability distribution. Each element of «P» gives the probability the outcome will be less than or equal to the corresponding element in «R». Optional parameters:<br/>Smooth:true - uses smooth monotonic cubic interpolation on the CDF, so the PDF is continuous.<br/>Smooth:false - uses linear interpolation on the CDF, resulting in a piecewise constant, but discontinuous, PDF.<br/>Over: Indexes - independent sample is generated for each element combination.' };
    arrHelp['CumIPmt'] = { p: 'Rate,Nper: Scalar ; Pv : QuadraticNumber atomic ; Start_per,End_per,Type : optional numeric atomic', d: 'The cumulative interest received on an annuity (with periodic payments and constant interest rate) between «Start_per» and «End_per» inclusive. A negative number represents cumulative interest paid.<br/><br/>Parameters:<br/>  «Rate»: The interest rate per period.<br/>  «NPer»: The total number of periods in the annuity"s lifetime.<br/>  «Pv»: The present value. If you receive a loan, this is the<br/>        loan amount as a positive number. If you give someone<br/>        a loan, this is a negative number.<br/>  «Start_per»: First period included in the sum.<br/>  «End_per»: Last period included in the sum.<br/>  «Type»: (Optional) Indicates whether payments are at the beginning of the<br/>        period.<br/>        True  = Payments due at beginning of period, with first payment <br/>                due immediately.<br/>        False = Payments due at end of period. (default)<br/><br/>Returns SUM_{n=Start_per..End_per} IPmt(rate,n,NPer,Pv,0,Type)<br/><br/>Note: The CumIPmt() function in some versions of Microsoft Excel returns the interest received between «Start_per»-1 and «End_per», and thus may return different results than this function in Analytica.' };
    arrHelp['CumNormal'] = { p: 'X:numeric orNull atomic ; mean : optional scalar orNull ; stddev:optional nonnegative orNull atom', d: 'Returns the area under normal distribution from -INF to «X».<br/>«mean» & «stddev» are optional and default to mean=0, stddev=1.' };
    arrHelp['CumNormalInv'] = { p: 'Y:numeric orNull atomic ; mean:optional numeric orNull ; stddev : optional nonnegative orNull', d: 'The inverse cumulative distribution function for the Normal distribution. Returns X such that CumNormal(X)=«Y».' };
    arrHelp['CumPrinc'] = { p: 'Rate,Nper : numeric atomic ;Pv : QuadraticNumber atomic ; Start_per,End_per,Type : optional numeric atomic', d: 'The cumulative principal received on an annuity (with periodic payments and constant interest rate) between «Start_per» and «End_per» inclusive. A negative number represents cumulative principal paid.<br/><br/>Parameters:<br/>  «Rate»: The interest rate per period.<br/>  «NPer»: The total number of periods in the annuity"s lifetime.<br/>  «Pv»:   The present value. If you receive a loan, this is the<br/>        loan amount as a positive number. If you give someone<br/>        a loan, this is a negative number.<br/>  «Start_per»: First period included in the sum.<br/>  «End_per»: Last period included in the sum.<br/>  «Type»: (Optional) Indicates whether payments are at the beginning of the<br/>        period.<br/>        True  = Payments due at beginning of period, with first payment <br/>                due immediately.<br/>        False = Payments due at end of period. (default)<br/><br/>Returns SUM_{n=Start_per..End_per} PPmt(rate,n,NPer,Pv,0,Type).' };
    arrHelp['CumProduct'] = { p: 'X : all Number OrNull Vector[I] ; I : recommended WarnDynamic index = _fromVector ; passNull : optional named boolean atom ; reset : optional named boolean array[I]', d: 'CumProduct(X,I) returns an array with each element being the product of all of the elements of «X» along dimension «I» up to, and including, the corresponding element of «X». The second parameter, «I», is optional if «X» is one-dimensional.<br/><br/>Optional Parameters:<br/>«passNull»: When set to true, null values in X are passed through to the result as null values, when false they do not contribute to the cumulation.<br/><br/>«reset»: At the given points along «I» where «reset» is true, the cumulation will be reset to the value in «X». This is of use when you want to restart the cumulation immediately following a state change, for example.' };
    arrHelp['Cumulate'] = { p: 'X : all QuadraticNumeric OrNull Vector[I] ; I : recommended WarnDynamic Index ; passNull : optional boolean atom ; reset : optional boolean array[I]', d: 'Cumulate(X,I) returns an array with each element being the sum of all of the elements of «X» along dimension «I» up to, and including, the corresponding element of «X». The second parameter, «I», is optional if «X» is one-dimensional.<br/><br/>Optional Parameters:<br/>«passNull»: When set to true, null values in «X» are passed through to the result as null values, when false they do not contribute to the cumulation.<br/><br/>«reset»: At the given points along «I» where «reset» is true, the cumulation will be reset to the value in «X». This is of use when you want to restart the cumulation immediately following a state change, for example.' };
    arrHelp['CumWilcoxon'] = { p: 'u : Number OrNull ; m,n : nonNegative OrNull ; exact : optional boolean OrNull', d: 'The cumulative probability function for the Wilcoxon distribution. This  returns the probability that a value sampled randomly from a Wilcoxon(«m»,«n») distribution is less than or equal to «u».<br/><br/>The «exact» parameter controls whether an exact algorithm or a Normal approximation is used. By default, a Normal approximation is used when m+n>100 which has an accuracy within 0.1%.' };
    arrHelp['CumWilcoxonInv'] = { p: 'p : Number OrNull ; m,n : nonNegative OrNull ; exact : optional boolean OrNull', d: 'The inverse cumulative probability function (quantile function) of the Wilcoxon distribution. Suppose you hypothesize that a measurable quantity is stocastically less in Population 1 than in Population 2. You take «m» measurements from Population 1 and «n» measurements from population 2.  CumWilcoxonInv(p,m,n) returns the threshold U-statistic value at which you would accept (or reject) the hypothesis as being supported by the data at a statistically significant level. A measured U-value less than this value would be considered statistically significant.<br/><br/>The «exact» parameter controls whether an exact algorithm or a Normal approximation is used. By default, a Normal approximation is used when m+n>100 which has an accuracy within 0.1%.' };
    arrHelp['CurrentDataDirectory'] = { p: 'folderPath alias newDir folder path: optional textual atomic', d: 'Without a parameter, returns the path to current file system folder (e.g., directory) that is used as the default for saving or loading data. <br/><br/>With a parameter, the current folder for saving or loading data is set (with relative paths interpreted relative to the previous setting) and the full path is returned.' };
    arrHelp['CurrentDataFolder'] = { p: 'folderPath alias newDir folder path: optional textual atomic', d: 'Without a parameter, returns the path to current file system folder (e.g., directory) that is used as the default for saving or loading data. <br/><br/>With a parameter, the current folder for saving or loading data is set (with relative paths interpreted relative to the previous setting) and the full path is returned.' };
    arrHelp['CurrentModelDirector'] = { p: 'folderPath alias newDir folder path: optional textual atomic', d: 'Without a parameter, returns the path to current file system folder (e.g., directory) that is used as the default for saving or loading model and module files.<br/><br/>With a parameter, the current folder for saving or loading model & module files is set (with relative paths interpreted relative to the previous setting) and the full path is returned.' };
    arrHelp['CurrentModelFolder'] = { p: 'folderPath alias newDir folder path: optional textual atomic', d: 'Without a parameter, returns the path to current file system folder (e.g., directory) that is used as the default for saving or loading model and module files.<br/><br/>With a parameter, the current folder for saving or loading model & module files is set (with relative paths interpreted relative to the previous setting) and the full path is returned.' };
    arrHelp['CustomizeBalloonHelp'] = { p: 'obj : object ; isEditMode : boolean atom ; actualObj : object = obj', d: 'Returns the contents that should be displayed in a help balloon. By changing the definition, you can alter what information is displayed, and under what conditions. ' };
    arrHelp['DateAdd'] = { p: 'date,offset : atomic numeric orNull ; unit : atomic textual orNull', d: 'Adds either a day, month, year, hour, minute or second offset to a given date time. The date is number indicating the number of days elapsed since the date origin. The offset may be positive or negative. Unit may be "Y", "Q", "M", "D", "h", "m", or "s". For example, DateAdd(d, 0..12, "M") creates a sequence of dates spaced one month apart, occurring on the same day of the month. If an offset results in a illegal date (such as 29 Feb 2005), the last day of the month is returned (e.g., 28 Feb 2005).' };
    arrHelp['DatePart'] = { p: 'date : atomic numeric orNull; part : textual atomic orNull', d: 'Given an integer denoting the number of days elapsed since the date origin (normally 1 Jan 1904), this returns either the year, month or day. If part="Y", the year is returned, if part="M" the month is returned as a number between 1 and 12, and if part="D" the day is returned as a number between 1 and 31.' };
    arrHelp['DbLabels'] = { p: 'recordIndex:Variable', d: 'Returns a list of column labels for an SQL query performed using the DBQuery() function. The definition of index «recordIndex» should be a DBQuery() function.' };
    arrHelp['DbQuery'] = { p: 'connection,sql : atomic text ; key : optional text atom ; datesAsText : optional boolean atom ; rs : hidden optional boolean atom', d: 'Connects to a data source and performs an SQL query (in read-only mode). «connection» is an ODBC connection string. «sql» is an SQL query string. A common use is as in the following example, querying the Orders table in from an ODBC data source configured with the name Northwind:<br/><br/>  DbQuery( "DSN=Northwind", "SELECT * FROM Orders" )<br/><br/>The function returns a list that is used to define the row index for the result. This list numbers the result rows, unless you specify the optional «key» parameter to select a column from the result set to use as the index labels. The following uses the values from the OrderID column of the data base for the row labels:<br/><br/>  DbQuery( "DSN=Northwind", "SELECT * FROM Orders", key: "OrderID" )<br/>  <br/>When you are retrieving data that includes columns with a date or time data type, the values can be returned either as text by setting the «datesAsText» parameter to true, or otherwise as a date-time number containing the number of days since the date origin. ' };
    arrHelp['DbTable'] = { p: 'recordIndex:Variable ; label : atomic text', d: 'Returns the specified column from an SQL query performed using the DBQuery() function.  The definition of the index «recordIndex» should be a DBQuery() function, and the «label» string should be the name of a column in the result table. This can be combined with smart arrays to yield a result table rather than a single column.' };
    arrHelp['DbTableNames'] = { p: 'connection:atom text;catalogs,schemas,tables,tableTypes:optional text atom', d: 'Connects to an ODBC datasource and returns catalog data for the data source.  «catalogs», «schemas», «tables», and «tableTypes» may be patterns (if your system"s ODBC driver manager is ODBC 3 compliant). Use "%" as a wildcard for each (matches 0 or more characters).  Underscore "_" matches one char.  Most drivers use backslash ("\") as an escape char, so "%", "_", or "\" as literals must be entered as "\%", "\_", or "\\".<br/>DBTableNames(db,catalogs:"%") returns all valid catalog names for the data source.<br/>DBTableNames(db,schemas:"%") returns all valid schemas for the data source.<br/>DBTableNames(db,tables:"%") returns all table names.<br/>DBTableNames(db,tableTypes:"%") returns all valid table types.<br/>«tableTypes» may be a comma-separated list of types.<br/>Use DBTable() and DBLabels() to access the result set.<br/>Note: Some drivers, including MSAccess ODBC, do not support all of these uses.' };
    arrHelp['DbWrite'] = { p: 'connection,sql:atomic text ; key : optional text atom ; datesAsText : optional boolean atom ; rs : hidden optional boolean atom', d: 'Connects to a data source and performs an SQL query (in read-write mode). If the call does not change the database, use DBQuery instead. The function is identical to DBQuery(), except that queries that alter the contents of the data source are allowed.' };
    arrHelp['Decompose'] = { p: 'C : CNumber ; I,J : recommended WarnDynamic Index ; R : hidden optional All[I,J]', d: 'Decompose(C, I, J) returns the Cholesky decomposition (square root) matrix of matrix «C», where «I» and «J» are the indexes that specify the two dimensions of the matrix. The matrix «C» must be symmetric and positive-definite.' };
    arrHelp['DefineOptimization'] = { p: 'Decisions alias decision: ...LVarType recognizeAllDecision Named;Minimize alias Min: recommended Named Expression;Maximize alias Max: optional Named Expression;Constraints alias constraint: recommended named ...Expression recognizeAllConstraint;Type : optional named text atom;Domain: optional named ...;Engine : optional named atomic text;SettingName alias Parameter : optional named Text Reduced;SettingValue alias Setting: optional named numeric Reduced;Preserve : optional named boolean atom;Gradient, Jacobian : optional named ... Expression;Guess alias InitialGuess InitialValue: optional named ... numeric OrNull;TraceFile alias Trace: optional named text atom;SetContext : optional named ... Variable;Over : optional named ... atomic ;InferIntrinsicMethod : optional hidden atom', d: 'Defines a structured optimization problem.<br/><br/>The basic form of an optimization problem is:<br/><br/>  DefineOptimization(<br/>    Decisions: d1, d2, d3,<br/>    Maximize: objExpr,<br/>    Constraints: c1,c2,c3<br/>  )<br/><br/>Each di is a decision variable (either a local variable or a global decision variable), each cj is a constraint, either an equality or inequality expression, or a constraint object whose definition is an equality or inequality expression, and objExpr is an expression (Minimize may be used instead of Maximize).<br/><br/>The result of evaluating DefineOptimization() is an optimization problem object which displays as «LP», «QP», «QCP», «NLP», etc. In the result table, you can double click on this object to view its internal details.<br/><br/>DefineOptimization() does not solve for the optimal solution, it simply defines the problem to be solved. Calls to OptSolution(), OptStatusText() or other related functions cause the problem to be solved. However, in the process of defining the problem, your model may be evaluated one or more times in order to determine the appropriate dimensionality and to deduce linear or quadratic relationships and the corresponding linear or quadratic coefficients.<br/><br/>There are many optional parameters, and many aspects of an optimization problem are encoded in within the model itself. For additional information, please consult the Optimizer guide (from the Help menu) and extended description of DefineOptimization() on the Analytica Wiki.' };
    arrHelp['Degrees'] = { p: 'Radians:atom', d: 'Converts radians to degrees.' };
    arrHelp['Determinant'] = { p: 'C : CNumber ; I,J : recommended WarnDynamic Index ; R : hidden optional All[I,J]', d: 'Determinant(C, I, J) returns the determinant of matrix «C», where «I» and «J» are the indexes that comprise the two dimensions of the matrix.' };
    arrHelp['DetermTable'] = { p: 'Indexes:Index...', d: 'DetermTable(I1, I2, ...In)(u1, u2, ...um) defines a conditional dependency on the outcomes of discrete uncertain variables, and returns an array that is reduced across its probabilistic index(es). «u1», «u2», ...«um» give the deterministic outcomes.' };
    arrHelp['Discrete'] = { p: 'allowed:...optional atom; type:optional named text; nullOk:optional named boolean atom', d: 'Discrete() is used to specify that a variable takes on a discrete set of possible values (as opposed to a continuous set of values). This declaration is used in a domain attribute expression. You can specify this with no parameters, indicating only that the values are discrete, or you can list a set of allowed values, such as:<br/><br/>	Discrete(1,""one"",""2"",""two"",3,""three"")<br/><br/>You can also limit the allowed values to a given data type using the «type» parameter, such as these examples:<br/><br/>	Discrete(type:""Text"")<br/>	Discrete(type:[""Number"",""Text""])<br/><br/>The «type» may include ""Number"", ""Text"", ""Handle"", or ""Reference"".<br/><br/>This function is used to define explicit values for a domain, either as a list of labels, list of numbers, etc. The parameters are evaluated, so the actual domain values are the result of evaluating each parameter.' };
    arrHelp['Dispatch'] = { p: 'demand : NonNegative OrNull atom ; capacity : NonNegative OrNull all[Resource] ; Resource : recommended WarnDynamic Index = common ; active : optional boolean[Resource] ; minimum : optional named NonNegative[Resource] ; increment : optional named NonNegative[Resource] ; method : optional named atom number', d: 'Allocates capacity from a set of resources, allocating from the first resources first, until demand is met. «demand» is the amount of demand that must be filled. «capacity» is the amount of capacity that each resource can supply. An optional «active» parameter allows you to specify that selected resources are inactive (false) or active (true). Only capacity from active resources are allocated. The result is indexed by the «Resources» index. The sum of the result will equal demand provided that there is sufficient capacity to meet the demand.' };
    arrHelp['DomainAllowed'] = { p: 'X:Variable', d: 'DomainAllowed(X) returns a set (reference to the list) of values that each cell of the result of «X» is allowed to have, not including Null. If an explicit set of values is not specified in the domain attribute expression (e.g., via a Discrete() function), then returns Null.' };
    arrHelp['DomainIntegerGroup'] = { p: 'X:Variable', d: 'DomainIntegerGroup(X) returns the name of the group for grouped-integer variables. Returns null for variables that are not grouped-integer, and "" for variables belonging to the unnamed group.' };
    arrHelp['DomainLowerBound'] = { p: 'X:Variable', d: 'DomainLowerBound(X) returns the lower bound of «X» as specified in its domain declaration. If its domain is not numeric or is unspecified, returns null.' };
    arrHelp['DomainNullOk'] = { p: 'X:Variable', d: 'DomainNullOk(X) returns true if a null value is tolerated without a out-of-range bounds checking error. This is controlled by the domain attribute.' };
    arrHelp['DomainType'] = { p: 'X:Variable', d: 'DomainType(X) returns the type of the variable as specified in the domain. Possible values are: "Continuous", "Integer", "Boolean", "GroupedInteger", "Discrete", "Index", or null (automatic/unspecified).' };
    arrHelp['DomainUpperBound'] = { p: 'X:Variable', d: 'DomainUpperBound(X) returns the upper bound of «X» as specified in its domain declaration. If its domain is not numeric or is unspecified, returns null.' };
    arrHelp['DotProduct'] = { p: 'x,y : number orNull[I]; I:Index', d: 'Evaluates the dot product of two vectors, e.g., Sum(X*Y,I).' };
    arrHelp['DyDx'] = { p: 'Y : Expression ; X : Variable ; delta : optional positive = 1.0e-8 ; preserve : optional boolean atom', d: 'Dydx(Y, X) returns the derivative of expression «Y» with respect to «X», evaluated at current mid values. In particular, it returns the change in the mid value of «Y», divided by delta, when the mid value of «X» becomes «delta» larger (where «delta» is 1e-8).' };
    arrHelp['DyDx_Elas_Twiddle'] = { p: 'mid,prob,fixdef:Expression;delta:scalar;mult:boolean atom', d: 'A function used internally during the evaluation of Dydx() and Elasticity(). Not available for use in a model.' };
    arrHelp['Dynamic'] = { p: 'X1 : Expression ; X : ... recommended Expression ; Reverse : optional named boolean ; Over : hidden optional Index', d: 'Dynamic(«x1», «x») returns an array where «x1» is evaluated for the first time step, then «x» is evaluated for each time step following, where «x» can depend on values at previous time steps. The recurrence occurs across the system index Time. For example:<br/><br/>  Dynamic(0, Losses[Time-1] - TaxedLosses[Time-1] )<br/><br/>You may specify separate initial values for the first n time steps, e.g.:<br/>  Dynamic(«x1», «x2», «x3», «x4», «x»)<br/><br/>In some dynamic programming applications, it is more convenient to start with the final value(s) and specify a recurrence that computes each value based on the value at future time points. To do this, list the recurrence first, followed by the final value(s), and also include reverse:true:<br/><br/>  Dynamic(Utility[Time+1][State=NextState]-ActionCost, <br/>          FinalReward,<br/>          reverse:true )<br/>          <br/>To specify a recurrence over an index other than Time, specify the dynamic index in brackets after the word Dynamic:<br/><br/>   Dynamic[Project]( Budget, Self[Project-1] - ProjectAllocation[Project-1] )<br/>   <br/>However, beware that Dynamic is optimized to operate over the Time index, and is often substantially less efficient when applied to non-Time indexes.' };
    arrHelp['EigenDecomp'] = { p: 'A : number all[I,J] ; I,J : WarnDynamic Index', d: 'Computes the eigenvalues and eigenvectors of square symmetric matrix «A» indexed by «I» and «J». The pairs of eigenvalues and eigenvectors are indexed by «J». If result is the result of evaluating EigenDecomp(), then the eigenvalues are given by result[.item="value"], and the eigenvectors are given by #result[.item="vector"]. Each eigenvector is indexed by «I».' };
    arrHelp['Elasticity'] = { p: 'Y : Expression ; X:Variable ; delta : optional positive = 1.0e-8 ; preserve : optional boolean atom', d: 'Elasticity(Y, X) returns the percent change in the value of expression «Y» if the value of expression «X» is 1% larger.' };
    arrHelp['Erf'] = { p: 'X:Numeric orNull atomic', d: 'The error function, 2/sqrt(pi) Integral( e^(-t^2),0,x ).' };
    arrHelp['ErfInv'] = { p: 'Y:Numeric orNull atomic', d: 'The inverse error function. Returns x such that erf(x)=«Y».' };
    arrHelp['Error'] = { p: 'msg:text atom', d: 'Raises an evaluation-time error, displaying the indicated message to the end user and aborting the current computation.<br/><br/>If Error(msg) is called from inside a Check attribute, it is displayed as a warning and replaces the standard failed-check message.' };
    arrHelp['Evaluate'] = { p: 'exprText:atomic;params:... optional Expression', d: 'Parses and evaluates an Analytica expression in the form of a string. Since the string can be dynamically constructed, Analytica is unaware of any dependencies contained within the string, so the user must use caution if using an expression containing variable identifiers. Top level functions are not allowed. Numbers are parsed using the number format setting for the variable containing this function. If an error occurs parsing expression, the function returns null.' };
    arrHelp['EvaluateScript'] = { p: 'script : text atom ; showError alias showErr : boolean named atom = false ; typescriptContext : hidden boolean atom = false', d: 'Processes a typescript command and returns the output from the typescript evaluation.<br/><br/>The optional «showError» parameter controls what happens if an error occurs while evaluating the script. When «showError» is omitted or false, no error message is reported to the user, and the function returns the error message text. When «showError» is true, the error is reported and stops model evaluation, or it can be caught by the Try() function.<br/><br/>This function is "dangerous", in that it can be used in ways that potentially violate invariant conditions assumed by Analytica, leading to unpredictable behavior, particularly when side-effects are involved.' };
    arrHelp['Exp'] = { p: 'X:atom', d: 'Exp(X) returns the exponential of «X» (e to the power of «X»).' };
    arrHelp['Exponential'] = { p: 'Rate : positive[Run] ; over : ... optional named atomic ; singleSampleMethod : optional hidden scalar', d: 'Describes the times between successive events when events are independent. The parameter is the occurrence rate of the process, and is thus the reciprocal of the mean.' };
    arrHelp['Factorial'] = { p: 'X:NonNegative OrNull atom', d: 'Factorial(X), usually written as X!, returns (X)(X-1)(X-2)..(1). «X» must be positive or zero.' };
    arrHelp['FFT'] = { p: 'X : Complex all[T] ; T,Freq : Index ; Parallel : hidden optional named boolean atom', d: 'The Fast Fourier Transform where «x» contains discretely sampled points at equal spacing along «T». FFT() transforms these to the discrete frequency domain with the result indexed by «Freq» and consisting of complex numbers in general, where «Freq» has units of cycles per (units of «T»). You should usually set «T» and «Freq» to have the same length, and the best computational efficiency is obtained when they are an even power of 2.' };
    arrHelp['FFTInv'] = { p: 'X:Complex all[Freq] ; Freq,T : Index', d: 'The Inverse Fast Fourier Transform where «X» contains discrete complex points spaced uniformly in the frequency domain indexed by «Freq», and in units of cycles per second (or, more generally, cycles per unit of «T»). The result is in the discrete time domain indexed by «T».' };
    arrHelp['FindInText'] = { p: 'substr,text:coerce textual OrNull atomic;start,caseInsensitive:optional named numeric atomic ; re:atom optional named boolean ; return : optional named text reduced ; subpattern:optional named reduced; repeat:optional named atomic boolean; repeatSubpattern: optional named atomic; repeatIndex : optional named index', d: 'FindInText(substr,text) returns the position of the first occurrence of «substr» in «text». If «substr» does not occur in text, returns 0.<br/><br/>Optional parameters:<br/>«start»: position to start searching.<br/>«caseInsensitive»: If true, match «substr» in a lower/upper-case insensitive fashion.<br/>«re»: When true, treat «substr» as a regular expression<br/>«return»: What to return:<br/>   "P" = position of match<br/>   "L" = length of match<br/>   "S" = sub-pattern text that matches<br/>   "#" = number of regular expression subpattern groups<br/>«subPattern»: A named or numbered regular expression subpattern to return information for.<br/>«repeat»: When true, finds all matches. The result is indexed by a local index named .Repeat.<br/>«repeatSubpattern»: Find all matches and use the named or numbered regular expression subpattern matches for the index labels. With a named subpattern, uses the subpattern name as the local index name.<br/>«repeatIndex»: An pre-existing index for the result. Finds the first Size(«repeatIndex») matches.' };
    arrHelp['FindObjects'] = { p: 'regExp : optional text atom ;  attribute : optional ... coerce Attribute atom ;  excludeAttribute : named optional ... coerce Attribute atom ;  class : named optional ... coerce class atom ;  excludeClass : named optional ... coerce class atom ;  value : named optional atom ; influences, influencedBy : named optional ... coerce handle atom ; inclusive : named optional boolean atom = false ;  within, withinAny, contains, containsAny : named optional ... coerce module atom ; hasInput alias hasInputs, hasOutput alias hasOutputs, hasParent alias hasParents, hasKid alias hasKids, isLiteral : named optional boolean atom ; uses, usedBy : named optional ... coerce handle atom ; caseSensitive alias caseSens : optional boolean atom = false', d: 'Finds analytica objects matching the criteria specified and returns a set of handles to these objects. The result is a set (a reference to a list), which can be used directly in functions like SetUnion, SetDifference and SetIntersection to combine search criteria in arbitrary ways. To get the result as a list, preface with a de-reference operator, i.e.,<br/><br/> #FindObjects( "Cost" )<br/><br/>A rich set of parameters, all optional, allow many types of criteria to be specified. You can combine criteria by specifying multiple attributes. When multiple types of criteria are present, they are combined conjunctively (i.e., they must all be true).<br/><br/>-----------<br/>Parameters:<br/>-----------<br/><br/>All parameters, with the possible exception of «regExp» and «attribute», must be specified using a named calling convention. All parameters are optional, but at least one parameter should be specified.<br/><br/>«regExp» : A regular expression (text) to search for. Objects having this pattern in any textual attribute, or in any of the attributes listed in «attribute» are returned.<br/><br/>«attribute»: One or more attributes to be matched against «regExp» and «value». When omitted, all applicable attributes are searched. No information about which attribute matched is included in the result.<br/><br/>«excludeAttribute»: One or more attributes to be excluded from the match.<br/><br/>«class»: One or more object classes. Only objects having one of the specified classes are returned. When not specified, only user objects are returned (not built-in objects like SysFunction or SysVar). If you specify Any, then all object classes, user and built-in, are included.<br/><br/>«excludeClass»: One of more object classes to exclude.<br/><br/>«value»: An atomic value to find. Previously computed values are search, or the attributes listed in «attribute». Searches within the individual cells of tables and arrays. You can search for NaN or Null.<br/><br/>«influences»: A list of handles to, or names of variables. Finds all objects that influence all of the listed variables, i.e., all objects upstream from all the listed variables.<br/><br/>«influencedBy»: A list of handles to, or names of variables. Finds all objects downstream from all variables listed.<br/><br/>«inclusive»: Boolean. By default FindObjects(influences:x) does not include x itself. When «inclusive» is true, then X is included. The same goes for «influencedBy», «within», «withinAny», «contains» and «containsAny».<br/><br/>«within»: When one or more modules is specified, only objects within the indicated modules are searched. <br/><br/>«withinAny»: Same as «within», except that it also includes objects that are inside the specified module(s) only as a result of a module alias being inside the module.<br/><br/>«contains»: Searches among modules that contain all of the objects specified in «contains».<br/><br/>«containsAny»: Same as «contains», except that it also includes modules that contain an alias that contains the indicates object(s).<br/><br/>«hasInput»: When true, returns objects that have an input node. When false, objects that have no input node.<br/><br/>«hasOutput»: When true, returns objects that have an output node. When false, objects that have no output node.<br/><br/>«hasParent»: When true, returns objects that depend on at least one other variable. When false, returns objects that have no dependency parents.<br/><br/>«hasKid»: When true, returns objects influence at least one other variable. When false, returns objects with no dependants.<br/><br/>«isLiteral»: When true, returns objects that contain only literals (explicit numbers, text, etc.) or are defined as a table with only literals in the cells.<br/><br/>«uses»: Find objects that use the items listed in «uses». Specify handles to, or textual names of variables, functions or attributes to «uses».<br/><br/>«usedBy»: Finds objects that are used by the items listed in «usedBy». You should specify handles to, or textual names of variables, functions or attributes to «uses».<br/><br/>«caseSensitive»: Controls whether «regExp» is case-sensitive. By default, it is case-insensitive.' };
    arrHelp['FindPolynomialZeroes'] = { p: 'C:Numeric All[I] ; I : WarnDynamic Index ; J : optional Index', d: 'Finds all real-number factors of a polynomial. The polynomial is specified by its coefficients, «C», in the first parameter, indexed by «I». The first element along «I» is the constant, the second is the linear coefficient, etc., so that the full polynomial is:<br/>   Sum( c * x^(@I-1), I )<br/><br/>There are at most n-1 solutions. The solutions are returned indexed also by «I», with the last elements filled with NaN when the remaining solutions are complex. Alternatively, you can provide an optional index, «J», with one element less than «I», to index the solutions.<br/><br/>This is not an officially supported function.' };
    arrHelp['Floor'] = { p: 'X:Number OrNull atom;digits:optional scalar;dateUnit:optional text atom', d: 'Returns the largest integer that is less than or equal to «X»:<br/><br/>   Floor(5.9) --> 5<br/>   Floor(-7.1) --> -8<br/><br/>When «digits» is specified, returns the largest number with «digits» digits past the decimal that is less than or equal to «X». E.g.<br/><br/>  Floor(pi,3) --> 3.141<br/><br/>Floor(x,dateUnit:unit) rounds a date-time number «X» downward to the nearest «dateUnit», yielding a date earlier than or equal to «X». The «dateUnit» parameter must be one of "Y", "Q", "M", "WD", "D", "h", "m", or "s".<br/><br/>   Floor( MakeDate(2010,4,21), dateUnit: "M") --> 1-Apr-2010' };
    arrHelp['ForLocal'] = { p: '«null»', d: '"For x := I Do body" iterates across index «I», returning the value of expression «body» by substituting «x» with each value of index «I». The result is an array indexed by «I» containing the result of each evaluation of «body».<br/><br/>For can also be used to iterate over every value of an array value by writing simply:<br/><br/>For x := expr Do body<br/><br/>where «expr» evaluates to an array.  In this case, «body» is evaluated once for every element in the array. In the event that «expr» is an identifier for an array-valued variable that also has a self-index, this syntax will treat the identifier as an index and iterate over the index values. To indicate an intention to iterate over all array values when such an ambiguity exists, follow «x» with brackets, or use the Atomic..Do declaration, e.g.:<br/><br/>For x[] := expr Do body<br/>Atomic x := expr Do body<br/><br/>For can also be used to iterate over all vectors indexed by J, or across all matrices indexed by J, K etc., by specifying the indexes for «x» as illustrated here:<br/><br/>For x[J] := expr Do body<br/>For x[J,K] := expr Do body' };
    arrHelp['Fractiles'] = { p: '«null»', d: 'If n is the number of elements in list «L», Fractiles(L) returns a continuous probability distribution where the first element is the 0% fractile, the second is the 1/(n-1) fractile, the third 2/(n-1) fractile, and so on.<br/><br/>This function is deprecated, because its design does not array abstract cleanly. It is recommended that you use CumProb() instead.' };
    arrHelp['Frequency'] = { p: 'X : all ContextSamp[I] ; A : WarnDynamic Index ; I : WarnDynamic Index=Run ; w : NonNegative named ContextSamp[I] = SampleWeighting', d: 'When I is an index with ascending real-valued elements, Frequency(X,I) returns the number of occurrences in «X» that are less than «I» but greater than the previous element of «I». Otherwise, for non-ascending or non-numeric indexes Frequency(X,I) returns the number of occurrences of «I».<br/><br/>Frequency can be used to tally along an index other than Run, such as «J», using Frequency(X,I,J). An optional «w» parameter can be used to specify the weight of each sample in «X».' };
    arrHelp['FunctionOf'] = { p: '«null»', d: 'non-evaluating function that holds the inputs of a variable for use in displaying influence diagram arrows' };
    arrHelp['Fv'] = { p: 'Rate,Nper:Scalar ; Pmt : QuadraticNumber atomic ; Pv : optional QuadraticNumber atom ; Type : optional scalar', d: 'Returns the future value of an annuity investment that returns constant, periodic payments and a constant interest rate.<br/><br/>Parameters:<br/>  «Rate»: Interest rate per period.<br/>  «NPer»: Total number of periods for the annuity. The computed value is<br/>        the value following the «NPer»"th payment.<br/>  «Pmt»: Payment received each period. If you receive payments from the<br/>        annuity, this is a positive number. If you make payments, this<br/>        is a negative number.<br/>  «Pv»: (Optional) The present value of the annuity -- i.e., the amount<br/>        you receive for the annuity. This is positive if you receive money<br/>        up front for the annuity. It is negative if you deposit money for<br/>        the annuity. If omitted, it is assumed to be zero.<br/>  «Type»: (Optional) Indicates whether payments are at the beginning of the <br/>        period.<br/>        True  = Payments due at beginning of period, with first payment <br/>                due immediately.<br/>        False = Payments due at end of period. (default)<br/><br/>Example: You invest $1000 in an annuity that pays 6% annual interest,<br/>        compounded monthly (0.5% per month), which pays out $50 at the<br/>        end of each month for 12 months, and then refunds whatever is left<br/>        over after 12 months. The amount refunded is:<br/>               Fv(0.5%,12,50,-1000) = $444.90.<br/>Example: You borrow $50,000 at a fixed annual rate of 12% (1% per month).<br/>        You make monthly payments of $550 for 15 years, and then pay off<br/>        the remaining balance in a single balloon payment.  That final balloon<br/>        payment is:<br/>               -Fv(1%,15*12,-550,50000) = $25020.99<br/><br/>Example: You open a fixed-rate bank account that pays 0.5% per month in<br/>        interest. At the beginning of each month (including when you open the<br/>        account) you deposit $100. The amount in the account at the end of the<br/>        first three years is:<br/>             Fv(0.5%,[12,24,36],-100,0,True) = [$1239.72, $2555.91, $3953.28]' };
    arrHelp['Gamma'] = { p: 'alpha:NonNegative[Run];beta:recommended positive[Run] ; over : ... optional named atomic ; singleSampleMethod : optional hidden scalar', d: 'The gamma distribution.<br/>The gamma distribution generates samples only in the x>0 range.<br/>It is often a good choice for quantities that can only be positive.<br/>«alpha» is the shape parameter. «alpha»=1 is an exponential distribution. «alpha»>1 is a unimodal distribution, approaching a normal distribution as «alpha» approaches infinity.<br/>«beta» is an optional scale factor (default=1.0).<br/>The theoretical mean is «alpha»*«beta», with variance «alpha»*«beta»^2. The mode is at («alpha»-1)*«beta» for «alpha»>1, or 0 for «alpha»<=1.' };
    arrHelp['GammaFn'] = { p: 'X: Numeric orNull atomic', d: 'The gamma function.' };
    arrHelp['GammaI'] = { p: 'X,A:Numeric orNull atomic;B:optional numeric orNull atomic', d: 'The incomplete gamma function.' };
    arrHelp['GammaIInv'] = { p: 'Y,A:numeric orNull atomic;B:optional numeric orNull atomic', d: 'The inverse of the incomplete gamma function. Returns X such that «Y»=gammaI(X,«A»).' };
    arrHelp['Geometric'] = { p: 'p : NonNegative[Run] ; over : ... optional named atomic; singleSampleMethod : optional hidden scalar', d: 'The geometric distribution describes the number of trials until the first successful occurrence. The parameter «p» is the probability of the event in a single trial.' };
    arrHelp['GetArrowsOnDiagram'] = { p: 'module : Object', d: 'Returns a list of the arrows that appear on an influence diagram. Each arrow is returned as a reference to a list containing three elements: Handle to source node, handle to target node, an integer that has bit zero (i.e., is odd) when the arrow is a dynamic arrow.' };
    arrHelp['GetEvaluationContext'] = { p: 'index : optional handle atom ; position : optional boolean atom', d: 'This function lets you examine the current evaluation context. The context reveals which slice of the current computation will be retained by the result. The context arises most commonly when array abstraction iterates over an index. If you call this with no parameters, it returns a list of handles to the indexes in the current evaluation context, such as those currently being iterated. If you pass a handle to an index as the first parameter, it returns the index value (or index position if «position» is true) in the current context.<br/><br/>This function is not typically used in Analytica models. It provides a glimpse into the internal workings of array abstraction.' };
    arrHelp['GetFract'] = { p: 'x : all ContextSamp[I] ; p:Numeric ; I: optional WarnDynamic Index=Run ; w : named NonNegative ContextSamp[I] = SampleWeighting ; discrete : optional atomic boolean ; domain : optional Unevaluated = x', d: 'GetFract(X,P) returns the «P»th fractile of «X», which is the value such that «X» has a probability «P» of being less than that value.' };
    arrHelp['GetProcessInfo'] = { p: 'item:atomic text', d: 'Returns information about the current process.<br/>GetProcessInfo("Process ID") returns the current process ID.' };
    arrHelp['GetRegistryValue'] = { p: 'root : atomic textual ; subfolder alias hive,name : optional atomic textual; warn : optional named atomic boolean', d: 'Retrieves a value from the system registry. The root must be one of the following: HKCR, HKCU, or HKLM (or HKEY_CURRENT_ROOT, etc), or ANA (for the Ana product installation folder) or ANAVER (for the version-specific release folder). The subfolder is a series of child folders separated by a forward slash (/), the name may be omitted for the default value. The result will be numeric for numeric entries, string for string entries. Warning: False will suppress a warning if the key does not exist (the result will be null).' };
    arrHelp['GetVariableByName'] = { p: 'varName : atomic text OrNull', d: 'Returns a handle to an object, such as a variable object, from the object identifier. This handle can usually be used where a function parameter expects a Variable.' };
    arrHelp['GroupedInteger'] = { p: 'groupName:optional text;start,stop:optional named Number;nullOk:optional named boolean', d: 'GroupedInteger(groupName) is used in a domain attribute expression to specify that a variable is integer valued, and belongs to a group of variables that are constrained to be all different in an optional solution. When solving an optimization problem (defined via DefineOptimization()), all scalar variables belonging to the same group must be assigned distinct values from 1..N, where N is the number of scalar variables in the group. The «groupName» parameter is optional; omitting it is equivalent to belonging to an unnamed group.<br/><br/>Optional «start» and «step» parameters allow you to transform the range of 1..N, for example to 0..(N-1) with start:0. If you have two variables with different «start» or «step» values, it is enforced only so that both would not simultaneously be assigned its own first possible value, etc. For example, when:<br/>	Domain X: GroupedInteger(start:1)<br/>	Domain Y:GroupedInteger(start:0)<br/><br/>then the possible (X,Y) combinations would be: (1,1) and (2,0), with (1,0) and (2,1) excluded.' };
    arrHelp['Handle'] = { p: 'X : Object Atom ; AsIndex : optional boolean atomic', d: 'Returns a handle to the object «A». This serves as an alias for the object «A». For example, in<br/>   Var x:=Handle(A) do Expr<br/>the local variable «x» serves as an alias of the object «A» within the body expression Expr, and can be passed to Variable or Index type parameters of other functions.<br/><br/>The variation Handle(A,AsIndex:true) can be used when «A» is a self-indexed table, where the handle"s index value (rather than array value) should be used within value contexts.' };
    arrHelp['HandleFromIdentifier'] = { p: 'varName : atomic text OrNull', d: 'Returns a handle to an object, such as a variable object, from the object identifier. This handle can usually be used where a function parameter expects a Variable.' };
    arrHelp['HyperGeometric'] = { p: 'Trials, PosEvents, Size : NonNegative[Run] ; over : ... optional named atomic ; singleSampleMethod : optional hidden scalar', d: 'The hypergeometric distribution describes the number of times an event occurs in a fixed number of trials without replacement.<br/><br/>«Trials»: the sample size, must be <=«Size»<br/>«PosEvents», the total number positive (successful) events in the population, must be <=«Size»<br/>«Size», the population size (successful + unsuccessful events).' };
    arrHelp['IdenSubscript'] = { p: 'A : Expression ; I : Index ImpliedDotI ; x : Expression ; defVal alias default : optional', d: 'A[I=x] returns the element or cross-section of array «A» for which index «I» has the value «x». <br/>A[@I=n] returns the «n»th element or cross-section of array «A» along index «I».<br/><br/>When «x» is a list or array, several elements or cross-sections of the array «A» along index «I» are returned. This can be used to re-index an array. For example, A[@I=@x] swaps index «I» for index «x» where «I» and «x» have the same length, or A[I=x] re-orders the array when «x» is a permutation of «I».<br/><br/>When «x» may contain elements that are not in «I», a default value to return may be specified using the syntax: A[I=x,defVal:z] where «z» is the default to use. When the default is specified, no warning will be issued about «x» being out-of-range.' };
    arrHelp['IdentPred'] = { p: '«null»', d: 'x[Time-n] is used inside a Dynamic() function to refer to a previous time period, n steps back along Time. When used in Dynamic[J]() along the dynamic index J, you would use x[J-n].' };
    arrHelp['If0'] = { p: '«null»', d: 'If0() is a function used internally by Analytica and is not intended for use in your own models. It is not supported and could be changed or removed in future releases.<br/><br/>if0(x) is equivalent to abs(x)<1e-6.' };
    arrHelp['IfPos'] = { p: '«null»', d: 'IfPos() is an function used internally by Analytica. It is not intended for use in your own models. It could be changed or removed in future releases.<br/><br/>IfPos(x) is equivalent to (x>0).' };
    arrHelp['IgnoreWarnings'] = { p: 'expr', d: 'Causes any warnings that occur during the evaluation of «expr» to be suppressed.' };
    arrHelp['ImPart'] = { p: 'x:atom', d: 'Returns the imaginary (non-real) part of a complex number.<br/><br/>Example:  Im( 7 - 3j ) --> -3' };
    arrHelp['IndexesOf'] = { p: 'A', d: 'IndexesOf(A) returns the indexes of array «A» as list of object handles. If «A» contains a null-index, the first element of the list will be Null (rather than a handle).' };
    arrHelp['IndexLocal'] = { p: 'J,sequence,body', d: 'Creates a local index.' };
    arrHelp['IndexNames'] = { p: 'A', d: 'Returns a list of the index names for array «A».' };
    arrHelp['IndexValue'] = { p: 'I : Index', d: 'IndexValue(I) returns the index value for «I». In some cases, a variable"s index value may be different from its value when evaluated. This is referred to as a self-index.' };
    arrHelp['Integer'] = { p: 'lb,ub:optional named Number;nullOk:optional named boolean', d: 'Integer() is used in a domain attribute expression to specify that a variable is integer-valued. Lower and upper bounds on acceptable values may be optionally specified using Integer(lb,ub).' };
    arrHelp['Integrate'] = { p: 'y,x : number orNull all[I] ; I : WarnDynamic Index=Common', d: 'Given a curve described by a set of points (x,y), where both «x» and «y» share index «i», Integrate(y,x,i) returns the area to the left of «x», for each point in «x». The result is an array indexed by «i».<br/><br/>When «x» or «y» is an index, the parameter «i» may be omitted.' };
    arrHelp['IntraTable'] = { p: 'Indexes:Index...', d: 'IntraTable(i1..in)(u1..um) provides an edit table, which behaves exactly the same as Table(i1..in)(u1..um) except that formulas within the cells of an IntraTable may refer to other cells within the same IntraTable. Intra-cell dependencies within an IntraTable must not form a directed loop, which is to say that a given cell must not depend indirectly upon its own value.<br/><br/>To refer to another cell, subscript or slice syntax is used on the keyword Self. For example, suppose I and J are the IntraTable indexes and a cell has the following formula:<br/><br/>	Self[I=5, @J=@J-1]^2+1<br/><br/>This means that the value of the cell is taken from previous J slice and the I=5 slice.<br/><br/>IntraTable() can be easily abused, since the presence of intra-cell dependencies introduces many of the downsides present in spreadsheets, and hence it is highly recommended that you avoid using IntraTables unless there is a distinct reason to do so.' };
    arrHelp['Invert'] = { p: 'C : CNumber ; I,J : recommended WarnDynamic Index ; R : hidden optional All[I,J]', d: 'Invert(C,I,J) returns the inverse matrix of the matrix «C», which has the two dimensions «I» and «J». The result also has dimensions «I» and «J».' };
    arrHelp['IPmt'] = { p: 'Rate,per,Nper:scalar ; Pv : QuadraticNumber atomic ; Fv : optional QuadraticNumber atom ; Type : optional scalar', d: 'Returns the interest portion of a payment received on an annuity, assuming constant periodic payments and a fixed interest rate.<br/><br/>Parameters:<br/>  «Rate»: The interest rate per period.<br/>  «Per»: The period to compute the principal payment for. {1..«NPer»}<br/>  «NPer»: The total number of periods in the annuity"s lifetime.<br/>  «Pv»: The present value. If you receive a loan, this is the<br/>        loan amount as a positive number. If you give someone<br/>        a loan, this is a negative number.<br/>  «Fv»: (Optional) Future value of annuity at the end of the «NPer»<br/>        periods. If you receive a loan, this is your final balloon<br/>        payment at the end as a negative number. If you get money<br/>        back at the end, this is a positive number.<br/>  «Type»: (Optional) Indicates whether payments are at the beginning of the<br/>        period.<br/>        True  = Payments due at beginning of period, with first payment <br/>                due immediately.<br/>        False = Payments due at end of period. (default)' };
    arrHelp['Irr'] = { p: 'Values : numeric OrNull all ArrayType[I] ; I : WarnDynamic Index ; Guess : optional numeric atomic', d: 'Returns the Internal Rate of Return (IRR) of a series of payments (negative values) and inflows (positive values). The IRR is the discount rate at which the Net Present Value (NPV) of the flows is zero.<br/><br/>Parameters:<br/>  «Values»: An array of values indexed by «I». All values must be<br/>      numeric.  Under normal usage, some values will be positive<br/>      and some will be negative.<br/>  «I»: The index of «Values» over which the NPV/IRR is computed.<br/>  «Guess»: (Optional) A guess to seed the search (defaults to 10%).<br/><br/>Note: In general, there may be zero or multiple solutions to IRR. The implementation uses an iterative search to locate a solution. If the iteration cannot locate a solution within 30 iterations, it returns NaN. The optional guess parameter can be used to seed the iteration with a guess, helping it to find a solution, or leading it to a particular solution when multiple solutions exist.' };
    arrHelp['IsDateTime'] = { p: 'x:atom', d: 'Returns true if the parameter is a numeric date time. A date-time number is a number that is recognized as representing the number of days elapsed since the date origin.' };
    arrHelp['IsHandle'] = { p: 'X:Expression ; local:optional boolean atom', d: 'IsHandle(«X») tests the value «X», or each cell of «X» when «X» is an array, and returns true when it contains a Handle.<br/><br/>Handle(«X»,local:true) will test whether a local variable «X» is set to a handle.  For the case of a local variable, if you don"t include the optional local:true parameter, the value held by the local variable is tested. When «X» is not the identifier of a local variable, the local parameter has no effect.' };
    arrHelp['IsNaN'] = { p: 'X:atomic', d: 'Returns 1 if «X» is an indeterminate numeric value, known as NaN. NaN stands for Not A Number, but this name is a bit misleading since it considered numeric. NaN results when an operation should result in a number, but the result is indeterminate, as occurs when you try to divide 0/0.' };
    arrHelp['IsNotSpecified'] = { p: 'X', d: 'Returns true if an optional parameter to a function was not supplied when the function was called. To set a default value, say X=0, your function definition might begin with:<br/><br/>If IsNotSpecified( X ) then X:=0' };
    arrHelp['IsNull'] = { p: 'X', d: 'IsNull(x) returns 1 when x is exactly null. It does *not* array abstract, so in this sense it is not equivalent to the comparison x=null. If x is an array, even an array of null, the result will be 0. If you want to compare each element of an array to null in an array abstractable fashion, use x=Null. This function is useful when testing whether an attribute is not set, distinguished from x=null that would test whether any cell in the attribute is null.' };
    arrHelp['IsNumber'] = { p: 'X:atomic', d: 'Returns 1 if «X» is numeric (including NaN or Inf), 0 otherwise.' };
    arrHelp['IsRealNumber'] = { p: 'x:atom', d: 'Returns 1 (true) when the parameter is a real number and not NaN. Returns 0 (false) when the parameter is not numeric, is NaN or is a complex number.<br/><br/>IsRealNumber(x) returns the same result as IsNumber(x) except in the case where x is a complex number or NaN.' };
    arrHelp['IsReference'] = { p: 'X:atomic', d: 'Returns 1 if «X» is a reference.' };
    arrHelp['IsResultComputed'] = { p: 'X : Variable', d: 'IsResultComputed(X) returns true if the result value for «X» has already been computed and is currently cached in memory, false otherwise. It does not cause «X» to be evaluated.<br/><br/>Mid(IsResultComputed(X)) tests whether the mid-value is cached, Sample(IsResultComputed(X)) tests whether the sample (i.e., probabilistic) value is cached.<br/><br/>It is unusual to use this within a model, but it has some uses in meta-inference algorithms.' };
    arrHelp['IsText'] = { p: 'X:atomic', d: 'Returns 1 if «X» is a string, 0 otherwise.' };
    arrHelp['IsUndef'] = { p: 'X:atomic', d: 'Returns 1 if «X» is the special value «undef» or «null».' };
    arrHelp['Iterate'] = { p: 'initial;expr:Expression;until:Expression; maxIter : optional scalar ; warn : optional boolean atom', d: 'Iterate() is used for convergence algorithms where the number of iterations that will be necessary is not known in advance. Iterate() repeatedly evaluates «expr» until the termination criteria, «until», is true. Iterate() must be a top-level function. «expr» and «until» may, and usually do, refer to the value of the variable being evaluated, while is the value at the previous iteration.<br/>Two parameters are optional. «maxIter» specifies a maximum number of iterations if «until» is never satisfied, and «warnFlag» set to true causes a warning to be issued if «maxIter» is reached.' };
    arrHelp['Join'] = { p: 'A : coerce textual OrNull Array all[I] ; I:recommended WarnDynamic Index=List; separator: recommended textual OrNull atomic ; finalSeparator : optional textual OrNull atomic ; default : optional atom ; textForNull : optional coerce text atom[I]', d: 'Concatenates elements of «A» along «I», separating each with «separator». If the optional «finalSeparator» is provided, it is used as the second-to-last and final elements.' };
    arrHelp['JoinText'] = { p: 'A : coerce textual OrNull Array all[I] ; I:recommended WarnDynamic Index=List; separator: recommended textual OrNull atomic ; finalSeparator : optional textual OrNull atomic ; default : optional atom ; textForNull : optional coerce text atom[I]', d: 'Concatenates elements of «A» along «I», separating each with «separator». If the optional «finalSeparator» is provided, it is used as the second-to-last and final elements.' };
    arrHelp['Kurtosis'] = { p: 'x : ContextSamp[I] ; I : optional WarnDynamic Index = Run ; w: optional named NonNegative ContextSamp[I] = SampleWeighting', d: 'Returns an estimate of the kurtosis of «X». Kurtosis is a measure of the peakedness of a distribution. A distribution with long thin tails has a positive kurtosis, while short tails and high shoulders (such as the Uniform) lead to negative kurtosis. The Normal distribution has a kurtosis of zero.' };
    arrHelp['LGamma'] = { p: 'X:numeric orNull atomic', d: 'The natural log of the gamma function. More numerically stable than log(gamma).' };
    arrHelp['LinearInterp'] = { p: 'D alias xi: Ascending Number OrNull All[I] ; R alias yi:Number OrNull All[I];X:QuadraticNumber OrNull Reduced ; I:WarnDynamic Index=common;extrapolationMethod : optional atom positive', d: 'LinearInterp(D, R, X, I) finds the two values closest to «X» in «D» and returns the linearly interpolated value between the corresponding value of array «R». «D» and «R» must be indexed by «I», and the interpolation occurs along dimension «I».<br/><br/>The optional «extrapolationMethod» parameter can be one of the following:<br/>	1=Use value of nearest point when «X» is outside the min and max of «D».<br/>	2=disallow extrapolation (return null).<br/>	3=disallow extrapolation during optimization, but same as 1 otherwise. <br/>	4=extrapolate using the first or last slope.<br/>	5=diallow extrapolation during optimization, but same as 4 otherwise.<br/><br/>When LinearInterp() appears within a linear or quadratic optimization, it encodes a piecewise-linear relationship. The optimizer can incorporate this into an LP or QP without losing linearity. If «extrapolationMethod» is 2, 3, or 5, an implicit constraint is introduced forcing the solution to be between the min and max of «D». If you can guarantee this, methods 2, 3, or 5, may result in an optimization problem that solves faster and is better-conditioned.' };
    arrHelp['LinearTermAtom'] = { p: 'c:Number All[I];I:WarnDynamic Index;c0:optional scalar', d: 'This is an internal function, used for QAing and Debugging purposes. Creates a linearTerm object from a vector of coefficients. This object is utilized by structured linear programs to deduce the linear coefficients that relate objectives or constraints to decision variables.' };
    arrHelp['ListOfHandles'] = { p: 'identifiers:...optional Object', d: 'ListOfHandles(X,Y,Z) takes a list of object identifiers as parameters, and returns a list of handles to these objects. The parameters are not evaluated. The result is equivalent to [Handle(X), Handle(Y), Handle(Z)], but can be syntactically more convenient. Can be used with any number of handles.' };
    arrHelp['Ln'] = { p: 'X:atom', d: 'Ln(X) returns the natural logarithm of «X». The natural logarithm is the power of e that equals «X». «X» must be a positive number.' };
    arrHelp['Logistic'] = { p: 'mean : numeric[Run] ; scale : recommended positive[Run] ; over : ... optional named atomic ; singleSampleMethod : optional hidden scalar', d: 'The logistic distribution is commonly used to describe growth.' };
    arrHelp['LogisticRegression'] = { p: 'Y : boolean orNull all[I] ; B : numeric orNull all[I,K] ; I,K : WarnDynamic Index ; priorType : optional named NonNegative atom ; priorDev : optional named positive atom ; IgnoreNaN : optional named hidden boolean atomic', d: 'Performs a logistic regression. Given a set of data points and a classification of 0 or 1 for each data point, the function returns a set of coefficients that enable you to predict the classification probability for other data points.<br/><br/>Given a data point with basis «b» (indexed by «K»), the probability that the data point should have a classification of 1 is given by:<br/><br/>	p = Sigmoid( Sum( c * b, K ) )<br/>	<br/>where «c» are the coefficients returned by LogisticRegression(). Both «c» and «b» are indexed by «K».<br/><br/>The basis for a data point is, in general, an arbitrary transformation from your data point to a vector indexed by «K». You should usually ensure that one element of «K» (usually the first) is the constant 1, to allow for an offset at zero. Without a constant term, the probability will be constrained to 1/2 when all basis terms are zero.<br/><br/>The coefficients, «c», are obtained by calling LogisticRegression(y,b,I,K), where «y» is the 0,1-classification and is indexed by «I», «b» is the basis for your training data set and is indexed by «I» and «K», «I» indexes your data points, and «K» is your basis index.<br/><br/>To obtain good predictive performance on data points that are not in the training data, you can apply a Bayesian prior over the space of coefficients during the learning process. You can adjust the prior type and strength, or use no prior at all, by specifying the optional parameters «priorType» and «priorDev». Possible values for «priorType» are:<br/><br/>	0 : No prior (the default). Pure maximum likelihood fit.<br/>	1 : Exponential L1-prior<br/>	2 : Normal L2-prior<br/>	<br/>The maximum likelihood method, priorType:0, returns the best possible fit to the training data, often resulting is an overconfident estimator for new data points. For maximum likelihood, the «priorDev» parameter is not used.<br/><br/>The «priorDev» parameter specifies strength of the prior bias, which in turn determines the tendency to overfit the data. Smaller values of «priorDev» bias the algorithm towards smaller coefficient values. The actual value is the standard deviation for the prior marginal distribution for each coefficient parameter. For more information on the exact interpretation of «priorDev», see LogisticRegression on the Analytica Wiki. For a specific data set, cross-validation may be used to find the best value for «priorDev».' };
    arrHelp['Logit'] = { p: 'p:atom', d: 'The Logit() function, equal to ln( p / (1-p) ), with 0 < p < 1.' };
    arrHelp['LogNormal'] = { p: 'median,gsdev: recommended named atomic Nonnegative[Run];mean,stddev alias SDeviation Sd: optional named atomic Nonnegative[Run] ; over : ... optional named atomic ; singleSampleMethod : optional atomic hidden numeric', d: 'LogNormal(median, gsdev) returns a continuous, lognormal probability distribution with the specified «median» and the geometric standard deviation, «gsdev».  The geometric standard deviation must be 1 or greater.<br/><br/>To specify the lognormal using the mean and arithmetic standard deviation, use: LogNormal(mean:m, stddev:sd), using the explicit parameter names.<br/><br/>To generate samples that are independent over the elements of one or more indexes, use the optional over parameter, e.g.: LogNormal(median, stddev, over:I,J).' };
    arrHelp['LogTen'] = { p: 'X:atom', d: 'LogTen(X) returns the log to the base 10 of «X». This is the power of 10 that equals «X». «X» must be a positive number.' };
    arrHelp['LpDefine'] = { p: 'vars,constraints : named Index;objCoef : named Numeric all[Vars];lhs : named numeric all[Vars,Constraints];rhs : named numeric all[Constraints];sense : optional named Textual[Constraints];maximize : optional named Numeric atomic;lb,ub : optional named Numeric[Vars];integertype alias intType cType: optional named Textual[Vars];ItLimit,NdLimit,MipLimit,TimeLimit : optional named positive atomic;OptTolerance,PivotTolerance,FeasTolerance,GapTolerance : optional named positive atomic;OptLb,OptUb : optional named scalar;Scaling : optional named scalar;Group : optional named number all[Vars] =1;Engine : optional named atomic text;SettingName alias Parameter : optional named Text Reduced;SettingValue alias Setting : optional named numeric Reduced', d: 'Defines a linear or linear-mixed integer programming problem.' };
    arrHelp['LpFindIIS'] = { p: 'lp:atomic LpType; newLp : optional named atomic boolean ; constraintsOnly : hidden optional atomic boolean', d: 'Finds an Irreducibly Infeasible Subset of Constraints. When LpStatusNum() returns 5, it indicates that there are no feasible solutions -- that the set of constraints and variable bounds are contradictory. This function is useful for locating the source of the contradiction. It returns a subset of the Constraints index, containing a subset of constraints that has no feasible solution, but such that if any one constraint is eliminated, the resulting set of constraints will be feasible.<br/><br/>If the optional «newLp» parameter is specified as true, a new LP object is returned in which both constraints and variable bounds have been reduced to a minimal conflicting subset. These can be accessed using the OptInfo() function.' };
    arrHelp['LpObjSa'] = { p: 'lp : Atomic LpType ; variable : optional atomic', d: 'Computes the range over which an objective function coefficient can vary in a linear program without changing the optimal solution.' };
    arrHelp['LpOpt'] = { p: 'lp : Atomic Optimization', d: 'Returns the value of the objective function at the optimum. The first parameter, «opt», is the result of a call to DefineOptimization(). Returns null when no feasible solution is located, unless the optional «PassNonFeasible» parameter is specified as Null.' };
    arrHelp['LpRead'] = { p: 'filename : atomic textual ; DecisionVector alias Vars,ConstraintVector alias Constraints : optional Index ;format : optional named atomic ; Engine : optional named atomic text;SettingName : optional named text Reduced;SettingValue : optional named numeric Reduced;Maximize : optional named atomic boolean;', d: 'Reads in a linear or mixed-integer linear programming problem from a file previously written using OptWrite(). When «filename» is a relative path, it is interpreted relative to the CurrentDataDirectory().<br/><br/>«DecisionVector» and «ConstraintVector» must be of the same size as in the file, or may be omitted and a local index will be created to index the scalar decision variables and scalar constraints.<br/><br/>Additional optional parameters:<br/><br/>«format»: the file format, either format:"LP" (default), "MPS", or "LPFML".<br/>«Engine» : The solver engine to use to solve it after it is loaded.<br/><br/>«SettingName», «SettingValue»: Any solver engine control settings to be used when solving it after it is loaded. You can either specify a single name and single value, or you can provide 1-D arrays with a common index for each «SettingNames» and «SettingValues».<br/><br/>«Maximize»: "True" (maximize) or "false" (minimize) to specify how the objective is to be treated. The "MPS" format standard does not include a description of whether the problem is a minimization or maximization, so when loading an MPS file from another program, you may need to set this. Note: OptWrite() from Analytica will always write MPS files as minimizations.' };
    arrHelp['LpReducedCost'] = { p: 'lp : Atomic LpType', d: 'Returns the reduced costs (dual values for the variables) at the optimal solution.' };
    arrHelp['LpRhsSa'] = { p: 'lp : Atomic LpQpType ; constraint : optional atomic', d: 'Computes the range over which a right-hand-side coefficient can vary in a linear or quadratic optimization program without changing the dual value (shadow price) of the optimal solution.' };
    arrHelp['LpShadow'] = { p: 'lp : Atomic LpType', d: 'Returns the shadow prices, or dual values for the constraints at the optimal solution.' };
    arrHelp['LpSlack'] = { p: 'lp : Atomic Optimization', d: 'Returns the slack or surplus values for the constraints at the optimal solution.' };
    arrHelp['LpSolution'] = { p: 'lp : Atomic Optimization', d: 'Returns the optimal solution to an optimization problem. If the solution has not yet been found, the evaluation of this call initiates the search for the solution.<br/><br/>The first parameter, «opt», is the result of a call to DefineOptimization().<br/><br/>The second parameter, «decision», is optional, and is the identifier of a decision variable. When the second parameter is not included, OptSolution() returns the solution vector for all scalar decision variables. When the second parameter is included, it returns the solution for the indicated decision variable, with the same dimensionality as the indicated decision.<br/><br/>When no feasible solution is found, OptSolution() returns Null. You should use OptStatusText(«opt») to obtain more information on why it is infeasible. You can specify an optional parameter, «PassNonFeasible», to be "True" in order to view the closest non-feasible solution found during the search.' };
    arrHelp['LpStatusNum'] = { p: 'lp : Atomic Optimization', d: 'Returns a numeric status for the solution process, as defined by Frontline solver.' };
    arrHelp['LpStatusText'] = { p: 'lp : Atomic Optimization', d: 'Returns a textual description of the solution status.' };
    arrHelp['LpWrite'] = { p: 'lp : Atomic LpType ; filename : atomic Textual ; format : optional named atomic', d: 'Writes a textual description of the LP problem to a file. The optional format parameter specifies the file format, either format:"LP" (default), "MPS", or "LPFML".' };
    arrHelp['LpWriteIIS'] = { p: 'lp:atomic LpType ; filename : atomic Textual ; format : optional named atomic textual', d: 'Writes a description of an Irreducibly Infeasible Subset (IIS) of constraints to a file. This may be called if LpStatusNum() returns 5, indicating that there is no feasible solution. An IIS is a subset of the original constraints which also contains no feasible solution, but is such that if any one constraint or variable bound is removed, the remaining set will have feasible solutions.<br/><br/>An optional «format» parameter controls the file format, and may be one of "LP", "MPS", or "LPFML".' };
    arrHelp['MakeDate'] = { p: 'year: coerce atomic positive orNull ; month,day : recommended coerce atomic positive orNull ; valueForInvalid : optional atom', d: 'Returns an integer denoting the number of days elapsed between the date origin (normally 1 Jan 1904) and the date given by the indicated year, month and day. Year must be a full four digits (e.g., 2005, not 05), 1<=month<=12, and 1<=day<=31.' };
    arrHelp['MakeTime'] = { p: 'h,m,s : coerce atomic nonNegative orNull', d: 'MakeTime(h,m,s) returns a number representing a time of day or a duration. For a time-of-day, the value will be be between 0 and 0.99999999 and the the parameters must be in these ranges:<br/><br/>  0 <= h <=23<br/>  0<= m <=59<br/>  0<= s <=59<br/><br/>For a duration, «h» may exceed 24 and the value may be larger than 1. The units are number of days, with 1.0 being one full day.' };
    arrHelp['MatrixMultiply'] = { p: 'A : CNumber All[aRow,aCol] ; aRow,aCol : recommended WarnDynamic Index ; B : CNumber All[bRow,bCol] ; bRow,bCol : recommended WarnDynamic Index', d: 'Matrix Multiplication where «A» is a matrix indexed by «aRow» and «aCol», «B» is a matrix indexed by «bRow» and «bCol». «aCol» and «bRow» must have the same number of elements. The result is indexed by «aRow» and «bCol».' };
    arrHelp['Max'] = { p: 'X ; I : ... recommended Index WarnDynamic ; IgnoreNonNumbers, IgnoreNaN : optional named atomic boolean ; caseInsensitive : optional atomic boolean ; NumImplicit : hidden optional positive atomic', d: 'Max(A,I) returns the largest element of array «X» along the «I» index. The result has the dimensions of array «X» with the index «I» removed.<br/><br/>Max(X,I,J,K) takes the maximum along all three dimensions «I», «J», and «K».<br/><br/>Max(X,I,IgnoreNonNumerics:True) takes the maximum of numeric values only, ignoring any non-numerics such as textual. Without this, textual values are included in a lexical order. Whether or not «IgnoreNonNumerics» is specified, null values are always ignored. Max(X,I,IgnoreNaN:true) ignores NaN values as well.' };
    arrHelp['MdArrayToTable'] = { p: 'a : Reduced ; row alias i : optional WarnDynamic Index ; col alias L column: optional vector ; valueIndex : optional named WarnDynamic index ; positional : optional named boolean atomic; omitZero,omitNull:optional named boolean atomic', d: 'Flattens a multi-dimensional array «a» into a 2-D array (a relational or fact table).<br/><br/>If you omit optional parameters (all except the first), it transforms a multidimensional array «a» into a 2-D relational table with local indexes .Col and .Row. Each cell of «a» becomes a row of the result, with the value of each index in the corresponding columns (its "coordinates"), and the cell value in the last column. Index .Col contains the indexes of «a», with a final column "Value". It omits rows whose Value is 0 or null. Index .Row numbers the rows from 1 to n. <br/><br/>Optional parameters:<br/><br/>«valueIndex»: If specified, the «valueIndex» must be an index of «a», say k, causing it to generate a "fact table": Instead of flattening over k, each row in the result shows all the values of «a» over k. It extends the column index to have a column for each value of k. The resulting table still has only 2 dimensions, but is more compact, reducing the number of rows by a factor equal to the size of k.<br/><br/>«omitNull»: (default: True) When false, it includes rows containing Nulls.<br/><br/>«omitZero»: (default: True)  When false, it includes rows containing zeros.<br/><br/>«positional»: (Default:  False) When true, it returns index positions instead of values for all the index coordinates.<br/><br/>«col»: If specified, a 1-D array or index containing handles to (or identifiers of) the indexes of «a», and the last element should be "Value". However, if you specify a «valueIndex» k, then k should be excluded from «col»; instead of a single "Value" as the last item, «col» is extended to include all the values of k. If «col» omits any index(es) of «a» the result will be an array of 2-D tables indexed by the omitted index(es) -- i.e., it flattens «a» only over the indexes listed in «col». If you want to flatten over all indexes of «a», it is easier to omit this parameter and let Analytica generate the local index .col automatically. <br/><br/>«row»: If specified, it is the index for rows in the result. The size of the index (number of rows), n, should be the product of the sizes of the indexes of «a» (omitting the «valueIndex» if any), assuming «a» has no zero or null values (or «omitNull» and «omitZero» are set to False). If «a» has any zero or null values, and «omitNull» or «omitZero» are set to true (default), n should be reduced by the number of omitted rows. It is usually easier to omit «row» and let the function generate the local index .Row automatically.<br/><br/>When «row» and «col» are omitted, MdArrayToTable() does not follow the rule of array-abstraction. For example, if you add a new index to «a» in the future, the existing logic does not iterate over that index as it would with an array-abstractable function; rather, MdArrayToTable() operates over the new index by flattening over it as well. When «row» and «col» are specified explicitly, then the call does follow the rule of array-abstraction. If you are using MdArrayToTable() to interface with a relational system such as a spreadsheet or database, then the array-abstraction correctness probably does not matter and it is easier to omit «row» and «col». If use MdArrayToTable() within your model"s internal logic, it is wise to specify «row» and «col» even though it requires more work, since array-abstraction correctness is necessary for obtaining correct results when performing parametric, what-if, sensitivity, scenario, and uncertainty analyses.' };
    arrHelp['MdTable'] = { p: 'T : Array[Rows,Cols] ; Rows,Cols : WarnDynamic Index ; Vars : optional Unevaluated; conglomerationFn : optional named atomic ; defaultValue : optional named atomic ; valueColumn : optional named reduced', d: 'MDTable() converts a 2-D table into a multi-dimensional array. «T» is a 2-D table indexed by «Rows» and «Cols». Each row of «T» corresponds to one cell in the final result. The first size («Cols»-1) columns specify the coordinates of a cell in the result, and the final column specifies the value for that cell.<br/><br/>Example:  T:=<br/>  Cols->  I    J    K    X<br/>  Rows   ---- ---- ---- ----<br/>    1      1    1    1    5<br/>    2      1    2    1    3<br/>    3      2    1    2    7<br/>    4      2    2    2    8<br/><br/>When applied to this 2-D table, MDTable() returns a 3-D array.<br/>Before evaluating MDTable(), you must define the indexes that will index the result.<br/>In the example, one would need to have three indexes, <br/>pre-defined as:<br/><br/>  I := J := K := [1,2]<br/><br/>Note that the Unique() function is useful for defining these indexes, e.g.:<br/><br/>  I := Unique( T[Cols="I"], Rows)<br/><br/>The fourth optional parameter to MDTable(), «Vars», specifies the list of <br/>index identifiers that are to index the final result. If «Vars» is omitted, <br/>then the elements of «Cols» (except for the final column) are taken to be <br/>the names of the indexes for the final result.<br/><br/><br/>If no row corresponds to a cell in the final result, the value in <br/>that cell will be «defaultValue», or null if the optional «defaultValue»<br/>parameter is omitted (use the IsUndef() function to detect null values).<br/>If the same cell"s coordinates occur more than once in «T», the conglomeration function <br/>is applied to the values. The optional conglomeration function may be "sum", "max", "min", <br/>average" or "product" (default="sum").<br/><br/><br/>Example usage: <br/><br/>   MDTable(T,Rows,Cols)<br/><br/>   MDTable(T,Rows,Cols,[I,J,K],average","n/a")' };
    arrHelp['MdxQuery'] = { p: 'connection alias connectionStr : atomic textual,mdx : atomic textual, userId,password, sep: optional atomic textual', d: 'Queries an OLAP data source using the MDX query language. An example of a connection string might be: <br/>  "Data Source=local;Provider=MSOLAP;Default Database=Adventure Works DW;Integrated Security=SSPI"<br/>The result returned is a multi-dimensional array, where the number of dimensions returned is equal to the number of axes in the MDX query. The dimensions are all local indices with names .Axis1, .Axis2, .Axis3, ... If an axis has more than one level, the member names are joined together by commas or by the optional «sep» parameter.' };
    arrHelp['Mean'] = { p: 'x : ContextSamp[I] ; I : optional Index WarnDynamic = Run ; w: optional named named NonNegative ContextSamp[I] = SampleWeighting ; unevaluatedX : hidden optional unevaluated = X', d: 'Mean(X) returns the average, or expected value, of the probabilistic expression «X».' };
    arrHelp['Median'] = { p: 'x : all ContextSamp[I] ; I: optional WarnDynamic Index=Run ; w : named NonNegative ContextSamp[I] = SampleWeighting ; discrete : optional atomic boolean ; domain : optional Unevaluated = x', d: 'Median(X) returns the sample median of «X», which is the value such that «X» has a 50% chance of being less than the value. Median(X,I) find the median of a sample along index «I».' };
    arrHelp['MemoryInUseBy'] = { p: 'v : Variable', d: 'Returns the memory, i.e., number of bytes, currently being used to store the mid and prob values of «v». Also counted are associative indexing structures used for indexes, and record sets structures for DbQuery nodes.' };
    arrHelp['Mid'] = { p: 'X : determ', d: 'Mid(x) returns the deterministic value of expression «x». It is computed by holding probability distributions at their median values and using the mid value of other inputs.' };
    arrHelp['Min'] = { p: 'X ; I : ... recommended Index WarnDynamic ; IgnoreNonNumbers, IgnoreNaN : optional named atomic boolean ; caseInsensitive : optional atomic boolean ; NumImplicit : hidden optional positive atomic', d: 'Min(A,I) returns the smallest element of array «X» along the «I» index. The result has the dimensions of array «X» with the index «I» removed.<br/><br/>Min(X,I,J,K) takes the minimum along all three dimensions «I», «J», and «K».<br/><br/>Min(X,I,IgnoreNonNumerics:True) takes the minimum of numeric values only, ignoring any non-numerics such as textual. Without this, textual values are included in a lexical order. Whether or not «IgnoreNonNumerics» is specified, null values are always ignored. Min(X,I,IgnoreNaN:true) ignores NaN values as well.' };
    arrHelp['MIrr'] = { p: 'values : Numeric OrNull all[I] ; I : WarnDynamic Index ; financeRate,reinvestRate : scalar OrNull', d: 'Computes the modified internal rate of return for a series of periodic cash flows. MIRR is the rate of return of an investment when capital invested must be borrowed at a known finance rate, and intermediate returns are re-invested at a known reinvestment rate for the remaining lifetime of the project. «Values» is an array of cash-flows indexed by «I», «financeRate» is the rate at which money for negative flows is borrowed, and «reinvestRate» is the rate at which positive cash flows are reinvested.' };
    arrHelp['Mod'] = { p: 'X,Y:atom;Pos:optional boolean', d: 'Mod(X,Y) returns the remainder of «X»/«Y». If «X»/«Y» is negative, the remainder is negative. Mod(X,Y,Pos:true) returns the positive remainder, so that 0<=result<abs(Y).' };
    arrHelp['MonoCubicInterp'] = { p: 'D alias xi,R alias yi: Ascending Number OrNull All[I] ; X:Number OrNull Reduced;I:WarnDynamic Index=common', d: 'LinearInterp(D, R, X, I) finds the two values closest to «X» in «D» and returns the linearly interpolated value between the corresponding value of array «R». «D» and «R» must be indexed by «I», and the interpolation occurs along dimension «I».<br/><br/>The optional «extrapolationMethod» parameter can be one of the following:<br/>	1=Use value of nearest point when «X» is outside the min and max of «D».<br/>	2=disallow extrapolation (return null).<br/>	3=disallow extrapolation during optimization, but same as 1 otherwise. <br/>	4=extrapolate using the first or last slope.<br/>	5=diallow extrapolation during optimization, but same as 4 otherwise.<br/><br/>When LinearInterp() appears within a linear or quadratic optimization, it encodes a piecewise-linear relationship. The optimizer can incorporate this into an LP or QP without losing linearity. If «extrapolationMethod» is 2, 3, or 5, an implicit constraint is introduced forcing the solution to be between the min and max of «D». If you can guarantee this, methods 2, 3, or 5, may result in an optimization problem that solves faster and is better-conditioned.' };
    arrHelp['MsgBox'] = { p: 'message:Expression;buttons:optional named scalar;title:optional named text', d: 'MsgBox() displays a standard popup modal dialog with a user-supplied message when it is evaluated. Evaluation ceases until the user presses a button on the message box.<br/><br/>The optional «buttons» parameter can be used to control which buttons are displayed, as follows:<br/>0 = OK only<br/>1 = OK and Cancel<br/>2 = Abort, Retry and Ignore<br/>3 = Yes, No and Cancel<br/>4 = Yes and No<br/>5 = Retry and Cancel<br/>The icon can also be changed by adding the following to the buttons parameter:<br/>16 = Critical<br/>32 = Question<br/>48 = Exclamation<br/>64 = Information<br/><br/>The return value indicates which button was pressed, as follows:<br/>1 = OK<br/>3 = Abort<br/>4 = Retry<br/>5 = Ignore<br/>6 = Yes<br/>7 = No<br/>The Cancel button causes the current computation to abort.<br/><br/>In ADE, MsgBox() displays nothing and returns 0.' };
    arrHelp['MultiTable'] = { p: 'Indexes:Index...', d: 'A MultiTable brings together several source tables into a single edit table display. The sources may be other edit tables or computed results, making it possible to have editable cells and computed cells within the same table.<br/><br/>In a MultiTable, the data resides in the original sources, not in the MultiTable itself. When you view the MultiTable""s cells, you are seeing (and editing) a virtual view of the original data, and when you change the data in a cell, you are changing the value in the original source.<br/><br/>To create a MultiTable, select MultiTable from the Definition / Array menu while your cursor is in the definition field. The index chooser displays where you select the index or indexes over which the data sources should vary. It is common to have a single index that serves as a column index where each column displays data from a different source. In general, you should not include the indexes of your source data here.<br/><br/>In the table display, define the data sources by selecting the ""Meta expressions"" view using the selector with a pencil icon on the top right of the table header. In each cell, enter the identifier of the data source, or an expression for computed data sources. These are ""meta-level"" descriptions of the table contents, since it describes which data appears as opposed to being the data itself. As an example, you might enter A, B and Mid(C) into three cells, where A and B are edit tables and Mid(C) is a computed result. This would allow a user to edit data in tables A and B from the MultiTable, and to view the result of C in the same table.<br/><br/>After you""ve entered the meta-level expressions, select ""Show cells"" using the selector found on the right side of the table header to see the actual data, pull or computed from the source tables. Non-editable computed cells will display with a gray background.<br/><br/>The dimensionality of a MultiTable (in cell view) is the union of dimensions of all the sources and of the table indexes of the MultiTable itself. Thus, the content viewed in a MultiTable usually has more dimensions than the MultiTable description itself. A MultiTable display works best when all sources have the same dimensionality. When one source does not have a dimension present in other sources, then each source cell will map to multiple cells in the MultiTable display, so you will see the same value duplicated within the same table.<br/><br/>Each source of a MultiTable can be:<br/>* A variable identifier: Its (editable) definition or edit table is depicted.<br/>	The variable can even be another MultiTable or SubTable.<br/>* A subscript or slice of a source table: Depicts an editable subset of cells in the source.<br/>* An expression: Displays its computed value, which cannot be edited. For example:<br/>	* Mid(X)      : displays the mid-value of X<br/>	* Mean(X)     : displays the mean-value of X<br/>	* 23.4        : Displays a literal number, non-editable.<br/>	* ""Some text"" : Displays the literal text, unquoted, non-editable.' };
    arrHelp['NegativeBinomial'] = { p: 'r,p : nonNegative[Run] ; over : ... optional named atomic ; singleSampleMethod : optional hidden scalar', d: 'The negative binomial distribution. This is a discrete distribution where the sample values are non-negative integers. It models the number of successes that occur before «r» failures occur in independent trials, where each success has probability «p». Its variance is greater than the mean.' };
    arrHelp['NlpDefine'] = { p: 'vars : recommended named Index;constraints : recommended named Index;x : named lVarType;obj,lhs : recommended named Expression;rhs : recommended named numeric all[Constraints] = 0;sense : recommended named Textual all[Constraints];maximize : optional named Numeric atomic;lb,ub : optional named Numeric[Vars];integerType alias intType ctype: optional named Textual[Vars];guess : optional named Numeric all[Vars];gradient,jacobian : optional named Expression;objnl : optional named textual all[Vars];lhsnl : optional named textual all[Vars,Constraints];itLimit,noImpSeconds,timeLimit,convTolerance: optional named positive atomic;mutate : optional named positive atomic;LinVar : optional named scalar;DerivMethod,EstimMethod,DirecMethod : optional named textual atomic;SampSz: optional named positive atomic;Group : optional named number all[Vars] =1;Engine : optional named atomic text;SettingName alias Parameter : optional named Text Reduced;SettingValue alias Setting: optional named numeric Reduced;TraceFile : optional named textual atomic;SetContext : ... optional named Variable;over : ... optional named atomic=SetContext;hessian,lhsHessian : optional named Expression;Preserve : optional named boolean atomic', d: 'Defines a non-linear optimization problem.' };
    arrHelp['Normal'] = { p: 'mean : recommended atomic numeric[Run] = 0.0; stddev : recommended atomic NonNegative[Run] = 1.0; over : ... optional named atomic ; singleSampleMethod : optional atomic hidden numeric', d: 'Normal(mean,stddev) returns a continuous, normal Gaussian probability distribution with the specified «mean» and the standard deviation, «stddev».<br/><br/>To generate independent samples for each element of one or more indexes, ensure that a parameter contains that index, or use Normal(mean,stddev,over:I,J).' };
    arrHelp['Normalize'] = { p: 'y,x : all Number OrNull[i] ; i : WarnDynamic Index = common', d: 'Normalize(y,x,i) rescales the values in «y» so that the area under the curve described by the points (x,y") is equal to 1, where y" is the result. When either «y» or «x» is an index, you can omit «i», and use just Normalize(y,x).<br/><br/>Be careful! Normalize does *NOT* cause the resulting values to sum to 1, nor does it cause the squares of the resulting values to sum to 1. If you intend one of these types of normalization, use:<br/><br/>  y / Sum(y,i)<br/>or<br/>  y / Sqrt(Sum(y^2,i))' };
    arrHelp['NPer'] = { p: 'Rate,Pmt,Pv : scalar ; Fv : optional scalar ; Type : optional scalar', d: 'Returns the number of periods of an annuity with constant periodic payments and a fixed interest rate.<br/><br/>Parameters:<br/>  «Rate»: Interest rate per period.<br/>  «Pmt»: Payment received per period. If you make payments, this is a<br/>       negative number. If you receive payments, it is a positive number.<br/>  «Pv»: Present value of the annuity. If you receive a loan, this is<br/>       the loan amount as a positive number. If you give a loan, this<br/>       is the loan amount as a negative number.<br/>  «Fv»: (Optional) Future value of the annuity at the end of the annuity.<br/>       If you receive a loan, this is the final balloon payment as a<br/>       negative number. If the receive a final payment at the end, this<br/>       is a positive number.<br/>  «Type»: (Optional) Indicates whether payments are at the beginning of the<br/>        period.<br/>        True  = Payments due at beginning of period, with first payment <br/>                due immediately.<br/>        False = Payments due at end of period. (default)' };
    arrHelp['Npv'] = { p: 'Rate : numeric OrNull[I] ; Values : QuadraticNumber orNull All[I] ; I:WarnDynamic Index ; offset : optional scalar', d: 'Returns the Net Present Value of a series of payments (negative values) and inflows (positive values) at fixed periods, discounted at a fixed discount rate per period.<br/><br/>Parameters:<br/>  «Rate»: The discount rate.<br/>  «Values»: An array of flows indexed by «I».<br/>  «I»: The index of «Values» over which the NPV is computed.<br/>  «offset»: (optional) the period in which the first value occurs.<br/><br/>NPV is the sum from 1..n of Values[i] / (1+rate)^i<br/><br/>A common mistake when using NPV (in both Analytica and Excel) occurs because the first value is assumed to occur one time point in the future. Analytica"s NPV matches Excel"s behavior if you don"t specify offset (defaulting to offset:1). In most cases, to get the correct NPV, you"ll need to specify offset:0, indicating that the first flow occurs in the current, or zeroth, time period.' };
    arrHelp['NumberToText'] = { p: 'x : reduced ; format alias fmt : optional text atom ; digits : optional positive atom ; showZeroes alias showZeros, thousandsSeparators alias separators : optional boolean atom; currency : optional text atom ; dateFormat alias dateFmt : optional text atom ; fullPrecision alias full : optional boolean atom', d: 'Returns a textual representation of «x», coercing any numeric values according to the specified format. The «format» parameter specifies how numbers are coerced and may be given then value of "Suffix", "Exponential", "Fixed Point", "Integer", "Percent", "Boolean", "Date" or "Hex". The «dateFormat» parameter specifies how date-time numbers are coerced using a template such as "m/d/yyyy". The other optional parameters, «digits», «showZeroes», «thousandsSep», and «currency» reflect parameters found on the standard Number Format dialog.' };
    arrHelp['OpenExcelFile'] = { p: 'filename:atomic text; showDialog : optional atomic boolean ; title alias caption : optional named atomic text', d: 'This function is deprecated. It is no longer supported and may be removed from future releases of Analytica. Please use SpreadsheetOpen instead.' };
    arrHelp['OpenURL'] = { p: 'url : atom text ; window : hidden optional atom text ; specs : optional atom text hidden', d: 'Opens a browser to the specified URL.' };
    arrHelp['OptEngineInfo'] = { p: 'engine : text atom ; item : text atom ; asRef : optional named boolean atom', d: 'Returns information about an optimizer engine. «engine» is the name of a solver engine, such as "LP/Quadratic", "Evolutionary", etc. Or, to get information on all engines pass Engine: all". «item» is the item requested. Possible values are: "SettingNames", "MaxSetting", "MinSetting", "Defaults", "Name", "DLL", "TrialPeriod", "ProblemTypes", "MaxVars", "MaxIntVars", "MaxConstraints", "MaxVarBounds", "Millseconds", "Iterations", "Calls", "Jacobians", or "Hessians".<br/><br/>OptEngineInfo(all","Name") returns a list of available engines.' };
    arrHelp['OptFindIIS'] = { p: 'lp:atomic LpType; newLp : optional atomic boolean ; constraintsOnly : hidden optional atomic boolean', d: 'Finds an Irreducibly Infeasible Subset of Constraints for a linear program (LP). When OptStatusNum(opt,true) returns true, it indicates that there are no feasible solutions -- that the set of constraints and variable bounds are contradictory. This function is useful for locating the source of the contradiction. It returns a subset of the scalar constraints that has no feasible solution, but such that if any one scalar constraint is eliminated, the resulting set of constraints will be feasible.<br/>If the optional «newLp» parameter is specified as true, a new LP object is returned in which both constraints and variable bounds have been reduced to a minimal conflicting subset. These can be accessed using the OptInfo() function.' };
    arrHelp['OptGuess'] = { p: 'decision:Variable', d: 'Returns the result of evaluating the «OptInitialGuess» attribute of a decision node.  This is the value used as the initial value when the decision appears in a non-linear optimization problem.' };
    arrHelp['OptInfo'] = { p: 'opt alias prog : Atomic Optimization ; item : atomic Text ; decision,constraint : optional LVarType ; asRef : optional named atomic boolean = false', d: 'Returns information about an optimization problem formulation.<br/><br/>	«prob»: an optimization problem instance returned by DefineOptimization(), LpDefine(), QpDefine() or NlpDefine().<br/>	«item»:Name of item requested. See below.<br/>	«decision»: (optional) A decision variable.<br/>	«constraint»: (optional) A constraint object.<br/><br/>The two parameter form of OptInfo(prob, item) retrieves unstructured information about the full scalar problem. For example, OptInfo(prob, ""c"") returns all objective coefficients, one for every scalar decision variable.<br/><br/>When the optimization is defined with DefineOptimization(), component information can be retrieved for a single decision variable or a single constraint. For example, OptInfo(prob, ""c"", Price) would retrieve the objective coefficients for the decision variable «Price», as an array matching the dimensionality of the «Price» decision.<br/><br/>Items that apply to a named decision include: ""c"", ""Q"", ""lb"", ""ub"", and ""domain"". Items that apply to a single constraint include: ""rhs"", ""constraintLb"", ""constraintUb"", and ""sense"". Items that can apply to a single decision and a single constraint include: ""lhs"" and ""lhsQ"". Finally, items that ignore «decision» and «constraint» include: ""engine"", ""type"", ""setting"". In addition, any «item» accepted by OptEngineInfo() is also recognized.' };
    arrHelp['OptMarginalValue'] = { p: 'opt alias prog : atomic optimization ; decision : optional LVarType', d: 'Computes and returns the marginal value of a decision, which is the amount by which the objective would change if the bounds on the variable were increased by 1. More precisely, it is the partial derivative of the objective with respect to the bound(s) of the variable.' };
    arrHelp['OptObjective'] = { p: 'opt alias prog : Atomic Optimization ; PassNonFeasible alias passInfeasible : optional named boolean atom', d: 'Returns the value of the objective function at the optimum. The first parameter, «opt», is the result of a call to DefineOptimization(). Returns null when no feasible solution is located, unless the optional «PassNonFeasible» parameter is specified as Null.' };
    arrHelp['OptObjectiveSa'] = { p: 'opt alias prog : Atomic LpType ; decision : optional LVarType', d: 'Computes the range over which an objective function coefficient can vary in a linear program without changing the optimal solution.' };
    arrHelp['OptRead'] = { p: 'filename : atomic textual ;DecisionVector alias Vars,ConstraintVector alias Constraints : optional Index ;format : optional named atomic ; Engine : optional named atomic text;SettingName : optional named text Reduced;SettingValue : optional named numeric Reduced;Maximize : optional named atomic boolean;', d: 'Reads in a linear or mixed-integer linear programming problem from a file previously written using OptWrite(). When «filename» is a relative path, it is interpreted relative to the CurrentDataDirectory().<br/><br/>«DecisionVector» and «ConstraintVector» must be of the same size as in the file or may be omitted and a local index will be created to index the scalar decision variables and scalar constraints.<br/><br/>Additional optional parameters:<br/><br/>«format»: the file format, either format: "LP" (default), "MPS", or "LPFML"<br/>«Engine» : The solver engine to use to solve it after it is loaded.<br/><br/>«SettingName», «SettingValue»: Any solver engine control settings to be used when solving it after it is loaded. You can either specify a single name and single value, or you can provide 1-D arrays with a common index for each «SettingNames» and «SettingValues».<br/><br/>«Maximize»: True (maximize) or false (minimize) to specify how the objective is to be treated. The "MPS" format standard does not include a description of whether the problem is a minimization or maximization, so when loading an MPS file from another program, you may need to set this. Note: OptWrite() from Analytica will always write MPS files as minimizations.' };
    arrHelp['OptReducedCost'] = { p: 'opt alias prog : Atomic LpType; decision : optional NoDependency LVarType ; PassNonFeasible alias passInfeasible : optional named boolean atom', d: 'Returns the reduced costs (dual values for the variables) at the optimal solution.' };
    arrHelp['OptRhsSa'] = { p: 'opt alias prog : Atomic LpQpType ; constraint : optional LVarType', d: 'Computes the range over which a right-hand-side coefficient can vary in a linear or quadratic optimization program without changing the dual value (shadow price) of the optimal solution.' };
    arrHelp['OptScalarToConstrain'] = { p: 'opt alias prog : Atomic Optimization ; constraint : LVarType NoDependency; scalarValues : Vector All[constraintVector] ; constraintVector alias constraintIndex scalarIndex: optional WarnDynamic Index', d: 'Maps a vector of values, one scalar value for each scalar constraint in an optimization problem, to a structured constraint array.<br/>	«opt» is the result of a call to DefineOptimization().<br/>	«constraint» is a constraint in «opt».<br/>	«scalarValues» is a vector of values indexed by «constraintVector».<br/>	«constraintVector» is an index with one element per scalar constraint in «opt».<br/><br/>The result will be indexed by the intrinsic indexes of «constraint».' };
    arrHelp['OptScalarToDecision'] = { p: 'opt alias prog : Atomic Optimization ; decision : LVarType NoDependency; scalarValues : Vector All[decisionVector] ; decisionVector alias decisionIndex scalarIndex: optional WarnDynamic Index', d: 'Maps a vector of values, one scalar value for each scalar variable in an optimization problem, to a structured decision variable.<br/>	«opt» is the result of a call to DefineOptimization().<br/>	«decision» is a decision variable in «opt».<br/>	«scalarValues» is a vector of values indexed by «decisionVector».<br/>	«decisionVector» is an index with one element per scalar variable in «opt».<br/><br/>The result will be indexed by the intrinsic indexes of «decision».' };
    arrHelp['OptShadow'] = { p: 'opt alias prog : Atomic LpQpType ; constraint : optional Expression ; PassNonFeasible alias passInfeasible : optional named boolean atom', d: 'Returns the shadow prices, or dual values for the constraints at the optimal solution.' };
    arrHelp['OptSlack'] = { p: 'opt alias prog : Atomic Optimization ; constraint : optional Expression ; PassNonFeasible alias passInfeasible : optional named boolean atom', d: 'Returns the slack or surplus values for the constraints at the optimal solution.' };
    arrHelp['OptSolution'] = { p: 'opt alias prog : Atomic Optimization ; decision : optional LVarType NoDependency ; PassNonFeasible alias passInfeasible : optional named boolean atom', d: 'Returns the optimal solution to an optimization problem. If the solution has not yet been found, the evaluation of this call initiates the search for the solution.<br/><br/>The first parameter, «opt», is the result of a call to DefineOptimization().<br/><br/>The second parameter, «decision», is optional, and is the identifier of a decision variable. When the second parameter is not included, OptSolution() returns the solution vector for all scalar decision variables. When the second parameter is included, it returns the solution for the indicated decision variable, with the same dimensionality as the indicated decision.<br/><br/>When no feasible solution is found, OptSolution() returns Null. You should use OptStatusText(«opt») to obtain more information on why it is infeasible. You can specify an optional parameter, «PassNonFeasible», to be "True" in order to view the closest non-feasible solution found during the search.' };
    arrHelp['OptStatusNum'] = { p: 'opt alias prog : Atomic Optimization ; reportIsFeasible : optional named boolean atom', d: 'Returns a numeric status for the solution process, as defined by Frontline solver.' };
    arrHelp['OptStatusText'] = { p: 'opt alias prog : Atomic Optimization', d: 'Returns a textual description of the solution status.' };
    arrHelp['OptWrite'] = { p: 'lp : Atomic LpType ; filename : atomic Textual ; format : optional named atomic', d: 'Writes a textual description of the «LP» problem to a file. The optional format parameter specifies the file format, either format: "LP" (default), "MPS", or "LPFML".' };
    arrHelp['OptWriteIIS'] = { p: 'lp:atomic LpType ; filename : atomic Textual ; format : optional named atomic textual', d: 'Writes a description of an Irreducibly Infeasible Subset (IIS) of constraints to a file. Only usable for a linear optimization program (an LP). This may be called if OptStatusNum(opt,true) returns true, indicating that there is no feasible solution. An IIS is a subset of the original constraints which also contains no feasible solution, but is such that if any one scalar constraint or variable bound is removed, the remaining set will have feasible solutions.<br/><br/>An optional format parameter controls the file format, and may be one of "LP", "MPS", or "LPFML".' };
    arrHelp['ParseDate'] = { p: 'date:atom;badVal:optional atom', d: 'Parses a text value as a date-time, returning the number corresponding to the number of elapsed days since the date origin. Can parse, e.g., "25-Dec-2009" or "12:15:33 PM".  The parsing occurs independent of the number format setting for the variable being evaluated. The optional second parameter, which defaults to Null, specifies the value returned when the parameter is non-textual, or when the text cannot be parsed as a date.' };
    arrHelp['ParsedExprFunction'] = { p: 'expr : atomic', d: 'When «expr» is a parsed function call, this returns a handle to the function option that is being called. When «expr» is an operator, e.g., +, -, *, ^, /, #, \, If, IfAll, IfOnly, And, Or, Not, <, >, =, <=, >=, etc., this returns a text name of of the operator, e.g., "^". When «expr» is neither a function nor expression, returns null.' };
    arrHelp['ParsedExprParameters'] = { p: 'expr : atomic ; param : optional atomic hidden', d: 'Returns the parsed parameters to a function call or operator expression.<br/><br/>The use of this function is rare. It is only used when you want to access the internals of Analytica"s own internal representation of a parsed expression, such as the parse-tree of the definition that is stored in the «FixedDef»  attribute.<br/><br/>ParsedExprParameters(expr) returns a 1-D array containing the parsed parameters to the function or operator expression in «expr». Note that «expr» is evaluated, so the result of evaluating «expr» must be a parsed function call or operator expression. Thus, in most cases, «expr» is likely to be of the form (fixedDef of Obj).<br/><br/>The result itself is a parsed expression.<br/><br/>When a parameter is passed an explicit list, or for any repeated (ellipsis) parameter, a reference to an unindexed list is returned (this is to ensure that all cells in the result are atomic).' };
    arrHelp['ParseNumber'] = { p: 'text:atom;badVal:optional atom', d: 'Parses a text value as a number. Dates are not parsed by this function. The result is independent of number format setting for the variable being evaluated. The optional second parameter specifies the value to return when the parameter cannot be parsed, and defaults to Null. Values that are already numeric (rather than text) are returned.' };
    arrHelp['Pdf'] = { p: 'x : ContextSamp[I]; I : WarnDynamic Index=Run ; w:named NonNegative ContextSamp[I]=SampleWeighting ; discrete : optional named boolean atomic ; spacingMethod alias binMethod : optional named NonNegative atomic ; samplesPerStep : optional named positive atomic ; numPoints : optional named positive atom ; smoothingMethod : optional named nonNegative atom ; smoothingFactor : optional named scalar ; domain : Hidden Unevaluated=x ; allX : Hidden All = x ; possibleValues : Hidden optional ; possibleValuesIndex : Hidden Index Optional', d: 'Computes a Probability Density Function (PDF) estimate when «x» is a continuous quantity, or a probability mass histogram when «x» is a discrete quantity. The parameter «x» identifies an uncertain quantity, or it may contain historical data that is indexed by the optional index parameter «I».<br/><br/>«w» : You may use «w» to weight points in «x» unequally. When not specified and «I» omitted, the weighting is taken from the system variable SampleWeighting. When specified, «w» should be indexed by «I», or by Run when «I» is omitted.<br/><br/>«discrete» : True forces «x» to be interpreted as a discrete quantity. False forces it to be interpreted as a real-valued continuous uncertain quantity. When this is not explicitly specified, the function makes a best guess based on the domain attribute and values of «x».<br/><br/>--- Continuous Quantities ---<br/><br/>For a continuous quantity, the result is indexed by a local .Step index and DensityIndex. The DensityIndex="X" slice contains values where a probability density estimate is given, and the DensityIndex="Y" slice contains the probability density estimate at that point. To plot the result, press the [XY] button in a result window and check "Use comparison index".<br/><br/>«spacingMethod» : For continuous PDF estimation, this optional parameter determines how the X values are selected: 0=Equal-X, 1=Equal-Sample-points, 2=Equal-Weighted-P.<br/><br/>«samplesPerStep» or «numPoints» may be used to control how many points are in the the PDF estimate (the length of the .Step index). Only one or the other may be specified.<br/><br/>There are two basic techniques available for estimating the probability density of a continuous quantity. When smoothingMethod:0 is specified, a histogram method is used. When smoothingMethod:1 (or 2) is specified, Kernel Density Estimation (KDE) is used.<br/><br/>«smoothingFactor» : Used only when KDE is used, determines how much smoothing should be applied. With smoothingMethod:1, the value should range from -1 to 1 and is relative to an estimated "optimal" level of smoothing, with smoothingFactor:0 being the apparent optimal smoothing factor. -1 shows maximal detail, +1 maximal smoothing. When smoothingMethod:2 is specified, «smoothingFactor» is interpreted as the global bandwidth used by KDE, and is then in the same units as «x».<br/><br/>--- Discrete Quantities ---<br/><br/>When «x» is discrete (e.g., categorical, integer-valued, etc), then the set of possible values is collected and the result is indexed by a local .PossibleValues index. The result reflects the percentage of times each possible value occurs. When «x» is an identifier, the domain of «x» can be used to specify the space and ordering of possible values explicitly.' };
    arrHelp['Permutations'] = { p: 'k,n:scalar OrNull', d: 'Number of different permutations of «k» items taken from a bucket of «n» items.' };
    arrHelp['PlugTermAtom'] = { p: 'termAtom : atom ; v : Number All[I] ; I : WarnDynamic Index ; v2 : optional hidden Number All[I]', d: 'Given a linear or quadratic term atom and a vector containing the values for the scalar variables contained inside the term atom, substitutes the values and returns numeric result. The index must have the same elements as the index used in the call to LinearTermAtom() or QuadraticTermAtom().' };
    arrHelp['Pmt'] = { p: 'Rate,Nper : Scalar ; Pv : QuadraticNumber atomic ; Fv : optional QuadraticNumber atomic ; Type : optional Scalar', d: 'Returns the total payment (interest + principal) received per period on an annuity with constant periodic payments and fixed interest rate.<br/><br/>Parameters:<br/>  «Rate»: The interest rate per period.<br/>  «NPer»: The total number of periods in the annity"s lifetime.<br/>  «Pv»: The present value. If you receive a loan, this is the<br/>        loan amount as a positive number. If you give someone<br/>        a loan, this is a negative number.<br/>  «Fv»: (Optional) Future value of annuity at the end of the «NPer»<br/>        periods. If you receive a loan, this is your final balloon<br/>        payment at the end as a negative number.  If you get money<br/>        back at the end, this is a positive number.<br/>  «Type»: (Optional) Indicates whether payments are at the beginning of the<br/>        period.<br/>        True  = Payments due at beginning of period, with first payment <br/>                due immediately.<br/>        False = Payments due at end of period. (default)' };
    arrHelp['Poisson'] = { p: 'mean:NonNegative[Run] ; over : ... optional named atomic ; singleSampleMethod : optional hidden scalar', d: 'The number of independent events that occur in a time interval of length t follows a Poisson distribution. The parameter, mean, is the mean (or expected) number of events during the given unit of time.' };
    arrHelp['PoissonRegression'] = { p: 'Y : NonNegative orNull all[I] ; B : numeric orNull all[I,K] ; I,K : WarnDynamic Index ; priorType : optional named NonNegative atom ; priorDev : optional named positive atom ; IgnoreNaN : optional named hidden boolean atomic', d: 'Performs a Poisson regression. Given a set of data points and a number of events (non-negative integer) for each data point, the function returns a set of coefficients that enable you to predict a probability distribution for the number of events that occur at other data points.<br/><br/>Given a data point with basis «b» (indexed by «K»), the probability distribution on the number of events that occur is given by <br/><br/>	Poisson(Exp(Sum( c * b, K )) )<br/>	<br/>where «c» are the coefficients returned by PoissonRegression(). Both «c» and «b» are indexed by «K».<br/><br/>The basis for a data point is, in general, an arbitrary transformation from your data point to a vector indexed by «K». You should usually ensure that one element of «K» (usually the first) is the constant 1, to allow for an offset at zero. Without a constant term, the mean will be constrained to 1 when all basis terms are zero.<br/><br/>The coefficients, «c», are obtained by calling PoissonRegression(y,b,I,K), where «y» is the number of events that occurred and is indexed by «I», «b» is the basis for your training data set and is indexed by «I» and «K», «I» indexes your data points, and «K» is your basis index.<br/><br/>To obtain good predictive performance on data points that are not in the training data, you can apply a Bayesian prior over the space of coefficients during the learning process. You can adjust the prior type and strength, or use no prior at all, by specifying the optional parameters «priorType» and «priorDev». Possible values for «priorType» are:<br/><br/>	0 : No prior. Pure maximum likelihood fit. (the default)<br/>	1 : Exponential L1-prior<br/>	2 : Normal L2-prior<br/>	<br/>The maximum likelihood method, priorType:0, returns the best possible fit to the training data, often resulting is an overconfident estimator for new data points.  For maximum likelihood, the «priorDev» parameter is not used.<br/><br/>The «priorDev» parameter specifies strength of the prior bias, which in turn determines the tendency to overfit the data. The value of «priorDev» is the standard deviation of the marginal prior distribution for each coefficient. Smaller values of «priorDev» bias the algorithm towards smaller coefficient values.  For more information on the exact interpretation of «priorDev», see PoissonRegression on the Analytica Wiki. For a specific data set, cross-validation may be used to find the best value for «priorDev».' };
    arrHelp['PositionInIndex'] = { p: 'A:recommended Array[I] ; U : reduced ; I : WarnDynamic Index', d: 'PositionInIndex() is the positional analog to the SubIndex() function. Both find the element «U» in array «A» and return its location along «I». PositionInIndex() returns its numeric position along «I». To get the element in «I», use SubIndex() with the same parameters. If the element is not found, returns 0.' };
    arrHelp['PPmt'] = { p: 'Rate,Per,Nper : scalar ; Pv : QuadraticNumber atomic ; Fv : optional QuadraticNumber atomic ; Type : optional scalar', d: 'Returns the principal portion of a payment received on an annuity, assuming constant periodic payments and a fixed interest rate.<br/><br/>Parameters:<br/>  «Rate»: The interest rate per period.<br/>  «Per»: The period to compute the principal payment for. {1..«NPer»}<br/>  «NPer»: The total number of periods in the annuity"s lifetime.<br/>  «Pv»: The present value. If you receive a loan, this is the<br/>        loan amount as a positive number.  If you give someone<br/>        a loan, this is a negative number.<br/>  «Fv»: (Optional) Future value of annuity at the end of the «NPer»<br/>        periods. If you receive a loan, this is your final balloon<br/>        payment at the end as a negative number. If you get money<br/>        back at the end, this is a positive number.<br/>  «Type»: (Optional) Indicates whether payments are at the beginning of the<br/>        period.<br/>        True  = Payments due at beginning of period, with first payment <br/>                due immediately.<br/>        False = Payments due at end of period. (default)' };
    arrHelp['Probability'] = { p: 'B : numeric ContextSamp[I] ; I : optional WarnDynamic Index = Run ; w: optional named NonNegative ContextSamp[I] = SampleWeighting', d: 'Probability(B) returns the probability that the boolean expression «B» is true.<br/><br/>For example, Probability(Normal(10,5)<10) returns 0.5.' };
    arrHelp['ProbBands'] = { p: 'X : all ContextSamp[I] ; I : optional WarnDynamic Index = Run ; w : NonNegative ContextSamp[I] = SampleWeighting ; discrete : optional atomic boolean ; domainObj : optional Unevaluated = x', d: 'Probbands(X) returns the probability or "confidence" bands for the uncertain expression «X».<br/><br/>For example, the probability band for 5% is the value for which there is a 5% chance that «X» will be less than or equal to the value.<br/><br/>Specify the fractile levels to include in the "Uncertainty Options..." dialog off the "Result" menu.' };
    arrHelp['ProbDist'] = { p: 'P : NonNegative[I,Run] ; R : Numeric[I,Run] ; I : Index=Common ; singleSampleMethod : optional atomic hidden numeric ; over : ... optional named atomic', d: 'Probdist(P,R,I) returns a continuous probability distribution in which array «P» gives the probability density values for the outcomes in array «R». The resulting distribution is normalized so the total probability is 1.' };
    arrHelp['ProbitRegression'] = { p: 'Y : boolean orNull all[I] ; B : numeric orNull all[I,K] ; I,K : WarnDynamic Index ; priorType : optional named NonNegative atom ; priorDev : optional named positive atom ; IgnoreNaN : optional named hidden boolean atomic', d: 'Performs a probit regression. Given a set of data points, and a classification of 0 or 1 for each data point, the function returns a set of coefficients that enable you to predict the classification probability for other data points.<br/><br/>Given a data point with basis «b» (indexed by «K»), the probability that the data point has a classification of 1 is given by:<br/><br/>	p = CumNormalInv( Sum( c * b, K ) )<br/>	<br/>where «c» are the coefficients returned by ProbitRegression(..). Both «c» and «b» are indexed by «K».<br/><br/>The basis for a data point is, in general, an arbitrary transformation from your data point to a vector indexed by «K». You should usually ensure that one element of «K» (usually the first) is the constant 1, to allow for an offset at zero. Without a constant term, the probability will be constrained to 1/2 when all basis terms are zero.<br/><br/>The coefficients, «c», are obtained by calling ProbitRegression(y,b,I,K), where «y» is the 0,1-classification and is indexed by «I», «b» is the basis for your training data set and is indexed by «I» and «K», «I» indexes your data points, and «K» is your basis index.<br/><br/>To obtain good predictive performance on data points that are not in the training data, ProbitRegression() applies a Bayesian prior over the space of coefficients during the learning process. You can adjust the prior type and strength, or use no prior at all, by specifying the optional parameters «priorType» and «priorDev». Possible values for «priorType» are:<br/><br/>	0 : No prior. Pure maximum likelihood fit.(default)<br/>	1 : Exponential L1-prior<br/>	2 : Normal L2-prior<br/>	<br/>The maximum likelihood method, priorType:0, returns the best possible fit to the training data, often resulting is an overconfident estimator for new data points. For maximum likelihood, the «priorDev» parameter is not used.<br/><br/>The «priorDev» parameter specifies strength of the prior bias, which in turn determines the tendency to overfit the data.  Smaller values of «priorDev» bias the algorithm towards smaller coefficient values. For more information on the exact interpretation of «priorDev», see ProbitRegression on the Analytica Wiki. For a specific data set, cross-validation may be used to find the best value for «priorDev».' };
    arrHelp['ProbTable'] = { p: 'Indexes:Index...', d: 'ProbTable(I1, ... In)(p1, ... pm) returns a probability table indexed by «I1», ... «In». Each index lists several possible conditions or outcomes. The second set of parameters, «p1», ... «pm», give the probabilities of each outcome under each condition.' };
    arrHelp['ProbWilcoxon'] = { p: 'u : Number OrNull ; m,n : nonNegative OrNull ; exact : optional boolean OrNull', d: 'The probability of «u» in a Wilcoxon(«m»,«n») distribution. This is the probability of obtaining a particular U-statistic value when comparing two populations of sizes «m» and «n» in a Mann-Whitney-Wilcoxon rank-sum test.<br/><br/>The «exact» parameter controls whether an exact algorithm or a Normal approximation is used. By default, a Normal approximation is used when m+n>100 which has an accuracy within 0.1%.' };
    arrHelp['Product'] = { p: 'X : Vector All[I] ; I : ... recommended index ; IgnoreNaN : optional atomic boolean', d: 'Product(X,I) returns the product of all the elements of «X» along the dimension indexed by «I». The result has the dimensions of «X» with index «I» removed.<br/><br/>Null values within «X» are always ignored. To also ignore NaN values in «X», use: Product(X,I,IgnoreNaN:true). Even when NaN in «X» are ignored, the result can be NaN if 0 and INF are multiplied together.<br/><br/>Product(X,I,J) takes the product of all elements in the two-D slice described by indexes «I» and «J».' };
    arrHelp['ProductLog'] = { p: 'z:CNumber OrNull atom', d: 'ProductLog(z) returns the x value that solves z = x * exp(x).<br/>This is also known as the Lambert W function.<br/><br/>The function is real-valued for a real-valued parameter with z>=-exp(-1). It is also defined for all complex numbers. When the parameter is real but less that -exp(-1), it returns NaN when EnableCompleNumbers is 0.' };
    arrHelp['Pv'] = { p: 'Rate,Nper:scalar ; Pmt : QuadraticNumber atomic ; Fv : optional QuadraticNumber atom; Type : optional scalar', d: 'Returns the present value of an annuity in which you receive (or pay) a constant amount each period for a fixed number of periods, and then receive (or pay) a lump sum after the final payment. The result is positive if you would receive money in exchange for the annuity (for example, if you receive a loan). The result is negative if you would have to pay money to acquire the annuity.<br/><br/>Parameters:<br/>  «Rate»: Interest rate per period.<br/>  «NPer»: Total number of periods for the annuity.<br/>  «Pmt»: Payment made each period. If you make payments, like paying a loan,<br/>        this is a negative number. If you receive payments, this is a<br/>        positive number.<br/>  «Fv»: (Optional) The balance remaining at the end after the last payment is<br/>        received. If you make payments, a negative number indicates the required<br/>        balloon payment at the end of the loan. If you receive payments, a positive.<br/>  «Type»: (Optional) Indicates whether payments are at the beginning of the<br/>        period.<br/>        True  = Payments due at beginning of period, with first payment<br/>                due immediately.<br/>        False = Payments due at end of period. (default)<br/><br/>Example: A lottery winning pays $50,000 per year for 15 years, with the first<br/>        payment occurring immediately. Following the last payment, there is a<br/>        final lump-sum payment of $250,000. Assuming an 8% return, this "million<br/>        dollar" prize is really worth:<br/>              -Pv( 8%, 15, 50000, 250000, 1) = $541,022.28<br/>        Note that the result of Pv() is negative since you would have to pay.<br/>        money to acquire the equivalent of the lottery"s future payments.<br/>Example: You are considering the purchase of an annuity that pays $500 per<br/>        month for 10 years, with the first payment occurring at the end of the first<br/>        month. With a 6% annual yield (0.5% monthly), the value of this annuity is:<br/>              -Pv( 0.5%, 12*10, 500 ) = $45036.73<br/>Example: You can afford $1500 per month on mortgage payments, and are<br/>        considering a 30 year fixed rate loan at 0.565% per month (= 7% APR).<br/>        The size mortgage that you can afford is given by:<br/>              Pv( 0.565%, 30*12, -1500 ) = $230558.71' };
    arrHelp['QpDefine'] = { p: 'vars,vars2,constraints : named Index;c : Recommended named Numeric all[Vars];Q : Numeric named all[Vars,Vars2];lhs : recommended named numeric all[Vars,Constraints];rhs : numeric named all[Constraints];sense : optional named Textual[Constraints];maximize : optional named Numeric atomic;lb,ub : optional named Numeric[Vars];integerType alias intType ctype : optional named Textual[Vars];guess : optional named Numeric all[Vars];lhsQ : optional named numeric all [Vars,Vars2,Constraints];warnIndefinite: optional named numeric atomic;ItLimit,NdLimit,MipLimit,TimeLimit : optional named positive atomic;OptTolerance,PivotTolerance,FeasTolerance,GapTolerance : optional named positive atomic;OptLb,OptUb : optional named scalar;Scaling : optional named scalar;Group : optional named number all[Vars] =1;Engine : optional named atomic text;SettingName alias Parameter : optional named Text Reduced;SettingValue alias Setting: optional named numeric Reduced', d: 'Defines a quadratic programming problem, i.e., an optimization problem with a quadratic objective function and linear or quadratic constraints. The objective function and each constraint have the form: <br/>   c x + xt Q x<br/>where:<br/>  x is the solution vector, xt its transpose<br/>  Q are the quadratic coefficients.' };
    arrHelp['QuadraticTermAtom'] = { p: 'Q:Number All[I,J];I,J:WarnDynamic Index ; c:optional Number All[I] ; c0 : optional scalar', d: 'This is an internal function, used for QAing and Debugging purposes. Creates a linearTerm object from a vector of coefficients. This object is utilized by structured linear programs to deduce the linear coefficients that relate objectives or constraints to decision variables.' };
    arrHelp['Q_SquareInterp'] = { p: 'D alias xi: Ascending Number OrNull All[I] ; R alias yi:Number OrNull All[I];X:Number OrNull Reduced;I:WarnDynamic Index=common', d: 'Q_SquareInterp(D, R, X, I) is a function used internally by Analytica that performs an interpolation between points in such a way so that integration of the interpolated curve is linear between the given points.' };
    arrHelp['Radians'] = { p: 'Degrees:atom', d: 'Converts degrees to radians.' };
    arrHelp['Random'] = { p: 'dist : optional unevaluated ; method:optional named numeric atomic; Over:...optional named atomic', d: 'Random(), with no parameters, returns a single random number from Uniform(0,1). The number is random Monte-Carlo regardless of whether the function is evaluated in Mid or Sample mode, or whether the sampling method setting is Monte Carlo or Latin Hypercube. Random(«dist») generates a number from a specified distribution, e.g., Random(Normal(10,5)) generates a number from a normal distribution with mean 10 and standard deviation 5. The optional second parameter, «method», can be used to select the randomize algorithm (1=Minimal standard, 2=L"Ecuyer, 3=Knuth), e.g., Random(method:2). Finally, you can generate multiple independent samples over one or more indexes using: Random( Over: I,J,K ), etc.' };
    arrHelp['Rank'] = { p: 'X : all Vector[I,KeyIndex] ; I : optional WarnDynamic Index ; type : optional atomic numeric OrNull ; KeyIndex : optional WarnDynamic Index ; descending,caseInsensitive: optional boolean[KeyIndex] ; passNaNs,passNulls : optional boolean atom', d: 'Rank(X,I) returns an array with the rank values of array «X» across index «I». The smallest value will have a rank of 1, the next smallest will have a rank of 2, and so on. When there are duplicate values, the smallest rank is returned unless an optional third parameter, «type», is specified. Type:-1 returns lowest rank, Type:0 returns Mid-rank, and Type:1 returns upper rank. Type:Null gives each tie a different number so that every element ends up with a unique rank.<br/><br/>To perform a multi-key rank, where ties in the first key are resolved using a second key, etc., arrange your keys along a KeyIndex and name the index in the optional «keyIndex» parameter.<br/><br/>Specify descending:true to assign 1 to the largest value, 2 to the second largest, etc.  Specify caseIndensitive:true to ignore upper-lower case in textual comparisons.<br/><br/>Special Nan and Null values are normally assigned an arbitrary numeric rank. Specify passNaNs:true and passNulls:true to pass these through rather than ranking them.' };
    arrHelp['RankCorrel'] = { p: 'X,Y : all ContextSamp[I] ; I : WarnDynamic Index=Run ; rankType : optional scalar orNull ; w : NonNegative ContextSamp[I] = SampleWeighting', d: 'RankCorrel(X,Y) returns the rank order (Spearman"s rank) correlation coefficient between the distributions «X» and «Y», which is a measure of the dependence between the two distributions. Use RankCorrel(X,Y,I)  for an index other than Run. An optional fourth parameter, «rankType», controls how duplicate values are treated. RankType:-1 uses lower-rank, RankType:0 (default) uses mid-rank, and RankType:1 uses upper rank.' };
    arrHelp['Rate'] = { p: 'NPer,Pmt,Pv : numeric atomic ; Fv,Type,Guess : optional numeric atomic', d: 'Returns the interest rate (per period) for an annuity. The value returned is the interest rate that results in equal payments of «Pmt» per period over the «NPer» of the annuity. In general, there may be zero or multiple solutions. Rate() uses an iterative search algorithm. If no solution is found within 30 iterations, it returns NaN.<br/><br/>Parameters:<br/>  «NPer»: The number of periods for the annuity.<br/>  «Pmt»: The payment per period. If you make payments, this is a<br/>       negative number. If you receive payments, this is a positive<br/>       number.<br/>  «Pv»: The present value of the annuity. If you are receiving a loan<br/>      this would be the loan amount as a positive number. If you are<br/>      giving someone a loan, this would be a negative number.<br/>  «Fv»: (Optional)The future value at the completion of «NPer» periods.<br/>      If you received a loan, «Fv» would be your balloon payment as a<br/>      negative number. If you receive money back at the end, this<br/>      would be a positive number.<br/> «Type»: (Optional) Indicates whether payments are at the beginning of the<br/>        period.<br/>        True  = Payments due at beginning of period, with first payment <br/>                   due immediately.<br/>        False = Payments due at end of period. (default)<br/>  «Guess»: (Optional) An estimate of the solution to seed the iteration.<br/>       Remember that this is expressed as a rate per period.<br/>       Defaults to 10%.' };
    arrHelp['ReadExportFile'] = { p: 'filename:atomic text; showDialog : optional named atomic boolean ; title alias caption : optional atomic text ; correspondIndexes : optional hidden named atomic boolean', d: 'Reads in an array from a file that has the import/export data format. This file format is produced when you use the File->Export function with a table, and supports multi-dimensional arrays. Local indexes are created for each dimension that appears in the file. These dimensions are not corresponded to existing indexes.' };
    arrHelp['ReadFromURL'] = { p: 'url: atomic textual; method : optional named atom text ; formValues : optional named Array[formIndex] ; formFields : optional named text[formIndex] ; formIndex : optional named WarnDynamic Index = Common ; httpHeaders : optional named atom text ; httpContent : optional named text atom', d: 'ReadFromURL(url) reads a page (usually in HTML) from a specified URL and returns the contents as text. For most web pages, a single «url» parameter beginning with ""http://"" is usually sufficient. For anonymous FTP retrieval, the «url» begins with ""ftp://"".  When a site requires authentication, the «url» can take the form<br/>	http://user:password@site.com/dir/page.htm<br/>or<br/>	ftp://user:password@site.com/dir/page.htm<br/><br/>If you need to post data to an HTML form and then retrieve the response, use<br/><br/>	ReadFromUrl(url,""POST"",formValues:fv,formFields:ff,formIndex:fi)<br/><br/>where fv and ff are arrays indexed by fi containing the submitted form field values and names respectively. You can use a single parameter, «formValues», if it is 1-D and its index contains the field names. You can add custom HTTP headers and content using the optional textual parameters «httpHeaders» and «httpContent». The use of custom content is useful when retrieving data web services.' };
    arrHelp['ReadImageFile'] = { p: 'filename:atomic text; showDialog : optional named atomic boolean ; title alias caption : optional named atomic text', d: 'ReadImageFile(filename) reads an image file (such as a JPG, BMP or PNG image file) and returns an object containing the image. Such an object can be assigned, for example, to the pict attribute of other objects from a button script.<br/><br/>When the optional «showDialog» controls whether the file selection dialog is displayed. "True" causes it to always display, "false" causes it to never display. When this parameter is omitted, the dialog displays only when the file is not found or is not a valid image file.' };
    arrHelp['ReadTextFile'] = { p: 'filename:atomic text ; showDialog : optional named atomic boolean ; title alias caption : optional named atomic text', d: 'Reads the entire contents of the indicated text file into a text string.<br/><br/>When the optional «showDialog» parameter is specified, controls whether the file selection dialog is displayed. If true, it is always displayed. When false, it is never displayed. When this parameter is omitted, the dialog displays only when the file is not found.' };
    arrHelp['RealPart'] = { p: 'x:atom', d: 'Returns the real part of a complex number.<br/><br/>Example: Re( 3 - 7j ) --> 3' };
    arrHelp['Reform'] = { p: '«null»', d: 'Unsupported and deprecated function. It doesn"t do anything in the current release and might be removed in future releases.' };
    arrHelp['Regression'] = { p: 'Y : numeric OrNull all[I] ; B : numeric OrNull all[I,K] ; I,K : WarnDynamic Index ; IgnoreNaN : optional hidden boolean atomic', d: 'General linear least-squares regression. <br/>X,Y is a list of points indexed by I (where each element of X may be a multi-dimensional vector). B is a set of basis functions, indexed by K, and a function of X (thus also indexed by I).<br/>Returns an array of coefficients, indexed by K.<br/><br/>Data points having Y=null are ignored.  If IgnoreNaN:True is specified, then database where Y is NaN are also ignored, otherwise NaNs are propagated through.  IgnoreNaN does not apply to NaNs occuring within B.' };
    arrHelp['ReThrow'] = { p: '', d: 'ReThrow() must appear with the «catch» parameter of the Try() function. It reissues the error that was caught.' };
    arrHelp['Round'] = { p: 'X:scalar OrNull;digits:optional scalar;dateUnit:optional named text atom', d: 'Round(x) returns the value of «x» rounded to the nearest integer.<br/><br/>   Round(Pi) --> 3<br/><br/>Round(x,digits) returns «x» rounded to «digits» decimal digits, for example:<br/>    Round(Pi,3) --> 3.141000<br/>Using a negative number rounds to the nearest power of ten left of the decimal, e.g.:<br/>    Round(12345,-2) --> 12300<br/><br/>Round(x,dateUnit:unit) rounds a date-time number «x» to the nearest date or time at the «dateUnit» increment.  «dateUnit» must be one of "Y", "Q", "M", "WD", "D", "h", "m", or "s".<br/><br/>   Round( MakeDate(2010,4,17), dateUnit:"Y") --> 2010-Jan-1' };
    arrHelp['RunConsoleProcess'] = { p: 'program:text[],cmdLine:recommended text[]; stdIn : optional named text[]; block : optional named boolean[] ; curDir : optional named text[] ; priority : optional named numeric[] ; showErr : optional named numeric[]', d: 'Executes a remote process. The first parameter is a path the executable file that will be launched. The second parameter is the command line, as you would type from a CMD command prompt. «stdIn» is text passed to the «stdIn» stream of the process. RunConsoleProcess() waits until the program terminates, and returns text the process writes to «stdOut», unless the parameter Block:False is specified, in which case it launches the process and returns immediately, leaving the program running as a separate process. The «ShowErr» parameter controls how text written to «StdErr» is handled. ShowErr:1 (default) reports an error message, ShowErr:2 reports it as a warning, and ShowErr:0 ignores it.' };
    arrHelp['Sample'] = { p: 'X : prob', d: 'Sample(x) returns a sample of «x», which is a list of numbers from the probability distribution of «x». The sample is an array indexed by the system variable Run with a size equal to the system variable Samplesize.' };
    arrHelp['SaveExcelWorkbook'] = { p: 'Workbook : ExcelWorkbookType atom ; filename : optional text', d: 'This function is deprecated. It is no longer supported and may be removed from future releases of Analytica. Please use SpreadsheetSave instead.' };
    arrHelp['ScanAttFromModelFile'] = { p: 'filename : atom text; attribute : reduced', d: 'Scans an Analytica model or module file and returns the textual value of a top-level model/module attribute. Does not load anything into memory.' };
    arrHelp['SDeviation'] = { p: 'x : ContextSamp[I] ; I : optional Index WarnDynamic = Run ; w: optional named NonNegative ContextSamp[I] = SampleWeighting', d: 'Sdeviation(X) returns an estimate of the standard deviation of «X».<br/><br/>The standard deviation is a measure of the spread or dispersion in a distribution. Wider distributions have larger standard deviations.<br/><br/>SDeviation(X,I) computes the standard deviation for a data set along the index «I».' };
    arrHelp['SelectText'] = { p: 'Text:coerce textual OrNull atomic;first : numeric OrNull atomic ; last : optional numeric OrNull atomic', d: 'Returns the substring of Text from «first» to «last» characters (first character is «first»=1). «last» is optional, if omitted or zero, returns the substring starting at «first» to the end.' };
    arrHelp['Sequence'] = { p: 'start ; end ; step : optional number ; strict : optional boolean ; dateUnit : optional text', d: 'Sequence(Start,End,Step) returns a list of numbers from «start» to «end». If «step» is not specified, it returns a list of successive integers. Otherwise, it returns a list of numbers, each differing from the one before by «step».<br/><br/>The optional «strict» flag indicates whether the sign of «step» is honored. When «strict» is omitted or false, «step» must be positive. In this case, a decreasing sequence is returned when «start» is less than «end». When «strict» is true, «step» may be negative, and a zero-length sequence may result.<br/><br/>The optional «dateUnit» specifies the date or time increment when generating date or time sequences between a «start» date and «end» date. Possible «dateUnit» values are: "Y" (year), "Q" (quarter), "M" (month), "D" (day), "WD" (weekday), "h" (hour), "m" (minute), "s" (second).' };
    arrHelp['SetContains'] = { p: 'set : Reference OrNull atom ; element : Reduced', d: 'SetContains(\L,x) returns true (1) when «x» is in the List or 1-D array «L». Note that you must use a reference operator on the list before passing it to the «set» parameter.' };
    arrHelp['SetDifference'] = { p: 'originalSet : Reference OrNull atom; Remove : ...OrNull atom optional; ResultIndex : optional index;keepNull:boolean named atom=false', d: 'SetDifference(s,r1,r2,...) returns the elements of set «s» that do not appear in any of the sets «r1», «r2», ... Each of the sets, «s», «r1», «r2», ..., should be a reference to list or a reference to a 1-D array, and the result is a reference to a list.<br/><br/>This example returns all numbers between 1 and 100 that are not divisible by 10:<br/><br/>  #SetDifference(\Sequence(1,100),\Sequence(0,100,10))<br/><br/>You may optionally specify an optional index using the parameter «resultIndex» to return an array with the indicated index, which will result in an array rather than a reference to a list, e.g.:<br/><br/>  Index I := 1..90 Do SetDifference(\Sequence(1,100),\Sequence(10,100,10),resultIndex:I)<br/><br/>The optional parameter, «keepNull» specifies how Null values should be treated. Since Null often serves as a place holder for a missing value, the default is to ignore Nulls. However, in some cases you may want to treat Null as an actual member of your set. For this treatment, specify "keepNull:true."' };
    arrHelp['SetEvaluationFlag'] = { p: 'flag : text atom ; enable : boolean atom ; expr : Expression', d: 'Sets or clears an evaluation flag while «expr» is evaluated. Flags may control such things as whether certain speed optimizations are used, legacy behaviors, error reporting, etc. Possible values for «flag» are:<br/>	""evaluationcontext"" : Controls whether computations that are not used in the result are avoided for faster evaluation.<br/><br/>To set a flag, pass «enable» as true, to reset it pass «enable» as false.' };
    arrHelp['SetIntersection'] = { p: 'sets : Reference OrNull Vector All[I] ; I : optional WarnDynamic Index; ResultIndex : optional index ; keepNull:boolean named atom=false', d: 'Returns the set of elements in common to every set that is passed into the first parameter of the function. The first parameter should be a list or array of ""sets"", where each set is encoded as a reference to a 1-D array. Each set passed thus acts like an atomic item. The second parameter, which is optional when the first parameter is 1-D, specifies the index that the intersection occurs over. When the «resultIndex» is not specified, the result is a reference to a 1-D array containing the intersection. Since each set is passed as a reference, each set is atomic, so that the function itself array-abstracts.<br/><br/>Examples:<br/><br/>	#SetIntersection([\In1,\In2,\In3])<br/><br/>returns the elements in common in indexes In1, In2 and In3.<br/><br/>When «resultIndex» is specified, the result returned is the actual array, padded by nulls if the result index is longer than necessary.<br/><br/>Example: To find the set of values occurring on every «Row» of array A[Row,Col]:<br/><br/>	SetIntersection( \[Col]A, Row, resultIndex:Col )' };
    arrHelp['SetsAreEqual'] = { p: 'sets : Reference OrNull Vector All[I] ; I : optional WarnDynamic Index ; ignoreNull : boolean named atom=true', d: 'SetsAreEqual(sets,I) returns true (1) if all sets in the array of «sets» along index «I» contain precisely the same unique elements, without regard to ordering, duplicates, or the presence of null values (unless «ignoreNull» is explicitly specified as false).<br/><br/>Example:<br/><br/>  var s1 := \([a","b",null,"b","c"]);<br/>  var s2 := \(["c",a","b"]);<br/>  SetsAreEqual([s1,s2])  --> true' };
    arrHelp['SetUnion'] = { p: 'sets : Reference OrNull Vector All[I] ; I : optional WarnDynamic Index; ResultIndex : optional index ; keepNull:boolean named atom=false', d: 'Returns the set of elements occurring in any of the sets that are passed into the first parameter of the function. The first parameter should be a list or array of ""sets"", where each set is encoded as a reference to a 1-D array. Each set passed thus acts like an atomic item. The second parameter, which is optional when the first parameter is 1-D, specifies the index that the union occurs over. When the «resultIndex» is not specified, the result is a reference to a 1-D array containing the union. Since each set is passed as a reference, each set is atomic, so that the function itself array-abstracts.<br/><br/>Examples:<br/><br/>	#SetUnion([\In1,\In2,\In3])<br/><br/>returns the elements in any of the indexes In1, In2 and In3.<br/><br/>When «resultIndex» is specified, the result returned is the actual array, padded by nulls if the result index is longer than necessary.<br/><br/>Example: To find the set of unique values occurring on any «Row» of array A[Row,Col]:<br/><br/>	SetUnion( \[Col]A, Row )' };
    arrHelp['ShowPdfFile'] = { p: 'filename : atomic textual; bookmark : optional named atomic textual ; search,bookmarks : optional named atomic boolean', d: 'Opens a PDF file (on computers where Adobe Acrobat or Acrobat Reader is installed). If Acrobat Exchange is installed on the computer, optional parameters can be used to specify which bookmark to open to, whether to show a search dialog, and whether to show the bookmark window. In ADE, or if the filename is an empty string, no PDF is opened. Returns 0 if Acrobat is not installed, 1 if Acrobat but not Exchange is installed, and 2 if both are installed.' };
    arrHelp['ShowProgressBar'] = { p: 'title,text:Text atomic; p:number atomic', d: 'Displays or updates a programmable dialog containing a progress bar. The first time it is called with p<1, the dialog appears. When 0<=p<1, a Cancel button is displayed and the progress meter is updated to the indicated proportion, allowing computation to continue while it is visible. If the user presses Cancel, the computation is aborted. When p=1, an OK button is shown and the dialog waits until OK is pressed to return and then disappears. The dialog is also removed when p>1 or a computation completes.' };
    arrHelp['Shuffle'] = { p: 'A : Context[I] ; I : WarnDynamic Index=Run ; over : ... optional named atom', d: 'Shuffle(A,I) randomly rearranges the elements of «A» along «I». If «A» has dimensions other than «I», each slice is shuffled independently. When «I» is omitted, Shuffle(A) shuffles along the Run index, creating independent samples.' };
    arrHelp['Sigmoid'] = { p: 'x:atom', d: 'The logistic function, also known as the inverse logit function, the expit function, and "the" sigmoid function. The Sigmoid function approaches 0 as x goes to -Inf, approaches 1 as x goes to +inf and is 1/2 at x=0. It is equal to 1/(1+exp(-x)).' };
    arrHelp['Sign'] = { p: 'X:atom', d: 'Sign(X) returns -1 when «X» is negative, 1 when «X» is positive, and 0 when «X» is 0.' };
    arrHelp['Sin'] = { p: 'X:atom', d: 'Sin(X) returns the sine of «X», where «X» is assumed to be in degrees.' };
    arrHelp['SingularValueDecomp'] = { p: 'A : CNumber[I,J] ; I,J,J2:WarnDynamic Index', d: 'Singular Value Decomposition.<br/>Matrix A[I,J] is factorized into orthogonal matrices U[I,J] and V[J,J2], and diagonal matrix W[J,J2] such that «A» = U W V^t, or in Analytica syntax<br/>  «A» = sum( sum(U*W,J) * Transpose(V,J,J2),J2 ).<br/>Singular value decomposition is often used with sets of equations or matrices that are singular or ill-conditioned (very close to singular).<br/>Index «I» must be at least as long as index «J», i.e., size(I)>=size(J), and you must provide an index «J2» that is the same length as «J» for the results. SingularValueDecomp(A,I,J,J2) returns a three element array indexed by SvdIndex, each element being a reference to the corresponding array. Each reference must be dereferenced using the # operator. For example:<br/>   J2 := CopyIndex(J)<br/>   MySvdResult := SingularValueDecomp(A,I,J,J2)<br/>   U := #MySvdResult[SvdIndex="U"]<br/>   W := #MySvdResult[SvdIndex="W"]<br/>   V := #MySvdResult[SvdIndex="V"]' };
    arrHelp['SinH'] = { p: 'Degrees:atom', d: 'Returns the hyperbolic sine.' };
    arrHelp['SipDecode'] = { p: 'xml : text atom ; ResultIndex : optional Index ; localIndexName : optional text atom ; useDll : optional named boolean atom', d: 'Decodes an XML-encoded compressed Stochastic Information Packet (SIP) into a 1-D array of sample data. The resulting array is indexed by Run by default, or you can specify your own index as the second parameter, or alternatively a name for a local index in the «localIndexName» parameter. When you specify a local index, the index will be automatically sized to match the number of data points in the encoded SIP.' };
    arrHelp['SipEncode'] = { p: 'X : Numeric ContextSamp[I] ; I : WarnDynamic Index=Run ; name,type,origin : optional named text atom ; version : named scalar=1.1 ; useDll : optional named boolean atom ; Xexpr : hidden unevaluated = X', d: 'Compresses and encodes a Stochastic Information Packet (SIP) as XML. A SIP is a representation of a stochastic sample of values from an uncertain quantity used to represent a distribution, as described by Dr. Sam Savage in OR/MS Today.<br/><br/>Parameters:<br/>  «x» : Data to be encoded.<br/>  «I» : Data index if it is something other than Run.<br/>  «name» : Optional name for dist.<br/>  «type» : Either "Single", "Double" or "Binary", specified encoding precision.<br/>  «origin» : Optional documentation text, where data came from.<br/><br/>Example:<br/>SipEncode( Internal_cost, name:"Internal cost", type:"Single" )<br/><br/>Reference:<br/>* Savage, S., Scholtes, S. and Zweidler, D., "<a href="http://probabilitymanagement.org/Library/Probability_Management_Part1s.pdf">Probability Management</a>" (<a href="http://probabilitymanagement.org/Library/Probability_Management_Part1s.pdf">Part 1</a> and <a href="http://www.lionhrtpub.com/orms/orms-4-06/frprobability.html">Part 2</a>), OR/MS Today, April 2006.' };
    arrHelp['Size'] = { p: 'U ; ListLen : optional boolean atomic', d: 'Size(U) returns the number of elements in «U». When «U» is a multi-dimensional array, this is the total number of cells in the array. When «U» contains a reference, the reference only counts as one element, even if it points to a sub-array.<br/><br/>Size(U,ListLen:true) returns the length of the implicit dimension (aka null- or list-dimension). If «U» has no implicit-dimension, returns Null.' };
    arrHelp['Skewness'] = { p: 'x : ContextSamp[I] ; I : optional WarnDynamic Index = Run ; w: optional named NonNegative ContextSamp[I] = SampleWeighting', d: 'Skewness(X) returns an estimate of the skewness of «X», which is a measure of the asymmetry of the distribution. A distribution whose upper tail is thicker than its lower tail has a positive skew. A symmetrical distribution has a zero skew.<br/><br/>Skewness(X,I) returns the skewness measure for a data set along dimension «I».' };
    arrHelp['Slice'] = { p: 'A : Expression ; I : recommended Index ImpliedDotI ; n : Expression ; defVal alias default : optional', d: 'Slice(A,I,n) returns the element or cross-section of array «A» for which index «I» has position «n». A short-hand operator notation, A[@I=n], is often used for slice. When «N» is a list, this function returns several elements or cross-sections of array «A» along index «I».<br/><br/>You may also use a 2-parameter variation of Slice(): Slice(A,n), when «A» is one-dimensional. You can use this form when slicing from an unindexed list, in which case there is no index to name.<br/><br/>When «n» is out of range, either less than 1 or greater than Size(I), an out-of-range warning may result. You may suppress this warning by turning off the ""Show Result Warnings"" preference (strongly discouraged), by wrapping the call to Slice inside IgnoreWarnings(), or by providing a default value using the optional «defVal» parameter. When warnings are ignored, it is equivalent to:<br/><br/>	Slice(A,I,n,defVal:Null)<br/><br/>You can shift an array to the right using:<br/><br/>	Slice(A,I,I-1)		For simple shift operations of this form (where n is of the form I-expr or I+expr), no warning results and a «defVal» of Null is assumed.' };
    arrHelp['SobolSequence'] = { p: 'n : positive atom ; I : Index = Run ; M : optional positive orNull[J] ; J : optional Index ; nEncodesPolynomial : optional named boolean atom = false', d: 'Returns the nth Sobol sequence along index «I» (which defaults to the Run index).<br/>To generate a sample on a hypercube indexed by D, use SobolSequence(@D).<br/><br/>Optional:<br/>«M»: The starting direction numbers (integers) as an array indexed by «J». The first q of these are used, where q is the degree of the nth primitive polynomial. The M values should be odd and less than 2^j.<br/>«nEncodesPolynomial» : When true, «n» is taken to be the encoding of the primitive polynomial, rather than the index of the nth polynomial. x^4 + x^3 + 1 would be encoded as 0b1100 (the +1 constant is not included).' };
    arrHelp['SolverInfo'] = { p: 'Item : atomic text ; lp:atomic optional Optimization ; Engine : optional named atomic text ; ref : optional atomic boolean = False', d: 'Returns information about a previously defined LP, QP, or NLP, or about an optimizer engine. For example, Solver(lp,"lb") returns the lower bounds on the decision variables in a previously-defined optimization problem. SolverInfo(Item:availEngines") returns a list of available engines. And SolverInfo(Engine:"SOCP Barrier",Item:"Defaults") returns a list of control settings used by the "SOCP" engine.' };
    arrHelp['Sort'] = { p: 'D : array all[I,KeyIndex] ; I : WarnDynamic Index ; KeyIndex : Optional named WarnDynamic Index ; descending,caseInsensitive : optional named boolean[KeyIndex]', d: 'Sorts the elements of an array. Sort(D,I) returns the elements of «D» sorted along «I» (from smallest to largest).<br/><br/>Sort(D,I,KeyIndex) sorts a 2-D array using a multi-key sort, where the sort order is determined by the first slice of «D» along KeyIndex (i.e., D[@KeyIndex=1]), whereas in the event of a tie, the ordering determined by the second column, D[@KeyIndex=2], etc.<br/><br/>SortIndex(D,I,descending:true) sorts from largest to smallest.<br/><br/>SortIndex(D,I,caseInsensitive:true) compares text values in a case-sensitive fashion.<br/><br/>In the case of a multi-key sort, the optional «descending» and  «caseInsenstive» parameters can be indexed by «KeyIndex».' };
    arrHelp['SortIndex'] = { p: 'D : Vector[I,KeyIndex] ; I : Optional WarnDynamic Index ; KeyIndex : Optional named WarnDynamic Index ; descending,caseInsensitive : optional named boolean[KeyIndex] ; position : optional named boolean atom', d: 'SortIndex(D,I) returns a list containing the elements of «I», sorted according to «D»"s values (from smallest to largest). «D» must be indexed by «I». If «I» is omitted, then «D» must be one-dimensional.<br/><br/>SortIndex(D,I,KeyIndex) returns a re-ordering of the elements of «I» resulting from a multi-key sort, where the sort order is determined by the first slice of «D» along «KeyIndex» (i.e., D[@KeyIndex=1]), whereas in the event of a tie, the ordering determined by the second slice, D[@KeyIndex=2] is used, etc.<br/><br/>SortIndex(D,I,descending:true) sorts from largest to smallest.<br/><br/>SortIndex(D,I,caseInsensitive:true) compares text values in a case-insensitive fashion.<br/><br/>In the case of a multi-key sort, the optional «descending» and «caseInsenstive» parameters can be indexed by «KeyIndex».' };
    arrHelp['Split'] = { p: 'Text,Separator : textual OrNull atomic ; caseInsensitive : optional named atom boolean ; re : optional named atom boolean ; subpattern: optional named atom ; resultindex : optional named index', d: 'Splits «text» into a list of text values, cutting «text» at each occurrence of «separator»:<br/><br/>  SplitText("one,two,three,four",",") --> ["one","two","three","four"]<br/><br/>Setting the optional «caseInsensitive» parameter to true causes «separator» to be matched upper/lower-case insensitive fashion. The default matches in a case-sensitive fashion.<br/><br/>«Separator» is interpreted as a regular expression when «re» is specified as true:<br/><br/>  SplitText("one;two  three,,,four:five@!$six", "[;\s,:!\$!@\?]+", re:true)<br/>   --> ["one","two","three","four","five","six"]<br/>   <br/>Surrounding context can also be incorporated to recognize a separator. When using context, a subpattern within the regular expression represents the separator itself, but the surrounding context must match. The «subPattern» parameter is used to indicate which subpattern within a regular expression is used for the separator. The subpattern can be either numbered or named:<br/><br/>  SplitText("one,"two,three","four,five",six", "("[^"]*")*\s*(,)", re:1, subPattern:2 )<br/>    --> ["one",<br/>         ""two,three"",<br/>         ""four,five"",<br/>         "six" ]<br/><br/>Equivalently:<br/><br/>    SplitText("one,"two,three","four,five",six", "("[^"]*")*\s*(?<s>,)", re:1, subPattern:"s" )<br/><br/><br/>Regardless of whether regular expressions are used, the result of SplitText() is an unindexed list. As a result, SplitText() cannot normally be array abstracted, e.g., «text» must be scalar. Suppose «text» were an array of text values -- each value might be split into a different length list, resulting in something that is not an array. When you need to use SplitText() in an array-abstractable fashion, you can provide a «resultIndex» to be used to index the result. When «resultIndex» is specified, then SplitText() is fully array abstractable. To use «resultIndex», you must define the index (and thus determine its length) before you call SplitText(). If the index has more elements than the number of resulting items, the final elements of the result are padded with «null» values. If the index does not have enough elements, the first N-1 elements are split off «text», and then the remainder of the un-split «text» is returned in the final result cell.' };
    arrHelp['SplitText'] = { p: 'Text,Separator : textual OrNull atomic ; caseInsensitive : optional named atom boolean ; re : optional named atom boolean ; subpattern: optional named atom ; resultindex : optional named index', d: 'Splits «text» into a list of text values, cutting «text» at each occurrence of «separator»:<br/><br/>  SplitText("one,two,three,four",",") --> ["one","two","three","four"]<br/><br/>Setting the optional «caseInsensitive» parameter to true causes «separator» to be matched upper/lower-case insensitive fashion. The default matches in a case-sensitive fashion.<br/><br/>«Separator» is interpreted as a regular expression when «re» is specified as true:<br/><br/>  SplitText("one;two  three,,,four:five@!$six", "[;\s,:!\$!@\?]+", re:true)<br/>   --> ["one","two","three","four","five","six"]<br/>   <br/>Surrounding context can also be incorporated to recognize a separator. When using context, a subpattern within the regular expression represents the separator itself, but the surrounding context must match. The «subPattern» parameter is used to indicate which subpattern within a regular expression is used for the separator. The subpattern can be either numbered or named:<br/><br/>  SplitText("one,"two,three","four,five",six", "("[^"]*")*\s*(,)", re:1, subPattern:2 )<br/>    --> ["one",<br/>         ""two,three"",<br/>         ""four,five"",<br/>         "six" ]<br/><br/>Equivalently:<br/><br/>    SplitText("one,"two,three","four,five",six", "("[^"]*")*\s*(?<s>,)", re:1, subPattern:"s" )<br/><br/><br/>Regardless of whether regular expressions are used, the result of SplitText() is an unindexed list. As a result, SplitText() cannot normally be array abstracted, e.g., «text» must be scalar. Suppose «text» were an array of text values -- each value might be split into a different length list, resulting in something that is not an array. When you need to use SplitText() in an array-abstractable fashion, you can provide a «resultIndex» to be used to index the result. When «resultIndex» is specified, then SplitText() is fully array abstractable. To use «resultIndex», you must define the index (and thus determine its length) before you call SplitText(). If the index has more elements than the number of resulting items, the final elements of the result are padded with «null» values. If the index does not have enough elements, the first N-1 elements are split off «text», and then the remainder of the un-split «text» is returned in the final result cell.' };
    arrHelp['SpreadsheetCell'] = { p: 'Workbook : ExcelWorkbookType atom ; sheet : atom ; column : atom ; row : positive atom ; what : optional atom text ; calc : optional boolean atom', d: 'Reads values from an Excel worksheet from the cell coordinates. <br/>Parameters:<br/>«Workbook»:  an object returned from a previous call to SpreadsheetOpen().<br/>«Sheet»: the name or number of the worksheet being queried.<br/>«Column»: a textual or numeric identification of the spreadsheet column.<br/>«Row»: numeric row from spreadsheet.<br/>«What»: (optional) Cell property to retrieve. Can be "Value" (the default),<br/>        "Formula", "RelativeFormula", "NumberFormat", "BackColor", "TextColor",<br/>        "FontName", "FontSize", "WrapText", "DirectPrecedents", "DirectDependents",<br/>        or "Border[Left|Right|Up|Down][Color|Style|Weight]" (e.g., "BorderLeftColor").<br/><br/>A block of cells is read when «column» and/or «row» is array-valued.<br/><br/>Examples:<br/>    SpreadsheetCell(wb,"Sheet1","C",7)   {read cell Sheet1!C7}<br/>    Spreadsheet(wb,"Sheet2",4,2)          {reads Sheet2!D2}<br/>    Spreadsheet(wb,3,2..8,5)                {reads 3rd sheet, B5:H5}' };
    arrHelp['SpreadsheetInfo'] = { p: 'Workbook : ExcelWorkbookType atom ; item : text atom', d: 'Reads a property of a workbook. «workbook» is a workbook object obtained via SpreadsheetOpen. «item» is one of: acceptLabelsInFormulas", activeSheet", author", "CalculationMode", "CodeName", "Date1904", "Filename", "Name", "Names", "ReadOnly", "Saved", "SelectedRange", "SelectedRangeR1C1", "Sheets", "Title", or "Visible".' };
    arrHelp['SpreadsheetOpen'] = { p: 'filename:atomic text; showDialog : optional atomic boolean ; title alias caption : optional named atomic text', d: 'Opens an Excel workbook file and returns a «workbook» object which can then be used as the parameter to other spreadsheet access functions (e.g., SpreadsheetCell, SpreadsheetRange). Evaluation of the function requires Excel to be installed. If the full path is not given in «filename», the filename is interpreted relative to the CurrentDataDirectory(). When «showDialog» is omitted, an open file dialog appears if the file is not found. «ShowDialog» can optionally be set to true (or false) to force the dialog to always (or never) show.' };
    arrHelp['SpreadsheetRange'] = { p: 'Workbook : ExcelWorkbookType atom ; range : optional text atom ; colIndex,rowIndex : optional index ; howToIndex: optional boolean ; sheet : optional atom ; what : optional named atom text ; calc : optional boolean atom', d: 'Reads the values from a region in an Excel worksheet.<br/><br/>Required parameters:<br/>«workbook»: Result returned from a previous call to SpreadsheetOpen().<br/>«range»: Requested range.  <br/><br/>The range can be specified either by coordinate, e.g., "Sheet3!C5:F9", or as the name of a named range.  If using coordinate notation, you must either specify the sheet name in the coordinate ("Sheet3!...") or specify the sheet name or number in the optional «sheet» parameter, e.g.:  SpreadsheetRange(wb,"C5:F9",sheet:"Sheet3").<br/><br/>If the range spans more than one cell, the result will be an array. You can specify indexes for the result in the optional «colIndex» and «rowIndex» parameters. When you omit these, a local index named .Column is created if the range spans more than a single column, and a local named .Row is created if the range spans more than one row. The labels for these indexes will be the column or row coordinates from the original worksheet.<br/><br/>You can further control how the range contents is interpreted and indexed using the optional «howToIndex» parameter. Any of the following values can be added together for the value of «howToIndex»:<br/>1 = Force column index (even if there is only one column).<br/>2 = Force row index (even if there is only one row).<br/>4 = Use first row in range for column labels.<br/>8 = Use first column in range for row labels.<br/>16 = No error when «colIndex» or «rowIndex» is the wrong length.<br/><br/>The optional «what» parameter controls whether the value, formula or other property of the cell is retrieved. Possible values are: "Value" (the default), "Formula", "RelativeFormula", "NumberFormat", "BackColor", "TextColor", "FontName", "FontSize", "WrapText", "DirectPrecedents", "DirectDependents", "Border[Left|Right|Up|Down][Color|Style|Weight]" (e.g., "BorderLeftColor"), "RangeName", "Sheet", address", or addressR1C1".<br/><br/>Examples (these query from the worksheet named Expenses):<br/>  SpreadsheetRange(wb,"Year")<br/>  SpreadsheetRange(wb,"B2:G19",colIndex:Year,rowIndex:Project, sheet:"Expenses")<br/>  SpreadsheetRange(wb,"Expenses!B2:G19")' };
    arrHelp['SpreadsheetSave'] = { p: 'Workbook : ExcelWorkbookType atom ; filename : optional text', d: 'Saves an Excel workbook"s contents to a file. Used after changes have been made by SpreadsheetSetCell() or SpreadsheetSetRange(). Uses the filename provided to SpreadsheetOpen() when the spreadsheet was first opened when «filename» is not specified.' };
    arrHelp['SpreadsheetSetCell'] = { p: 'Workbook : ExcelWorkbookType atom ; sheet : atom ; column : atom ; row : positive atom ; value : atom ; what : optional hidden atom text', d: 'Writes a value to an Excel worksheet cell.<br/><br/>Parameters:<br/>«workbook»: a workbook object obtained from SpreadsheetOpen().<br/>«sheet»: The name or number of the destination worksheet<br/>«column»: Column label or number<br/>«row»: Row number<br/>«value»: Value to write.<br/><br/>The function array abstracts, so that when «value» is an array with indexes shared by «column» and «row», a range of cell values are written.<br/><br/>Examples:<br/><br/>  SpreadsheetSetCell(wb, "Sheet1","C", 7, 11.5)<br/>    { writes the value 11.5 to cell C7 in Sheet1 }<br/>    <br/>  Index C := 5..10 Do SpreadsheetSetCell( wb, 1, C, 10, (C-4)^2 )<br/>    { writes [1,4,9,16,25,36] to cells E10:J10 of the first sheet}.' };
    arrHelp['SpreadsheetSetInfo'] = { p: 'Workbook : ExcelWorkbookType atom ; item : text atom ; value : atom', d: 'Sets a property of a workbook. «workbook» is a workbook object obtained via SpreadsheetOpen. «item» is one of: activeSheet", author", "CalculationMode", "CodeName", "Date1904", "SelectedRange", or "Title".' };
    arrHelp['SpreadsheetSetRange'] = { p: 'Workbook : ExcelWorkbookType atom ; range : text atom ; value : array[colIndex,rowIndex] ; colIndex,rowIndex : recommended WarnDynamic index ; sheet : optional atom ; what : optional hidden named atom text', d: 'Writes a value or an array of values to an Excel worksheet range.<br/><br/>Parameters:<br/>«workbook»: an object obtained by calling SpreadsheetOpen().  <br/>«range»: The destination range.<br/>«value»: The value to be written<br/>«colIndex», «rowIndex»: (optional) The indexes of «value».<br/>«sheet»: (optional) The destination worksheet name or number<br/><br/>The range can be a named range, in which case the sheet does not need to be identified. Alternatively, «range» can specify cell coordinates, such as "F6", "C3:G10" or "Sheet1!C3:G10". When using coordinates, the destination worksheet must be specified, either within «range», or by using the optional «sheet» parameter.<br/><br/>Examples:  Costs is a 2-D Analytica array indexed by I and J:<br/><br/>   SpreadsheetSetRange(wb, "Expenses", Costs, I,J )<br/>     { Writes the array Costs to a named range "Expenses" }<br/>     <br/>   SpreadsheetSetRange(wb, "C5:F8", Costs, I,J, sheet:"Sheet1" )<br/>   SpreadsheetSetRange(wb, "Sheet1!C5:F8", Costs, I, J )<br/>   SpreadsheetSetRange(wb, "C5:F8", I, J, sheet:1 )<br/><br/>      {these all write Costs to Sheet1!C5:F8 }' };
    arrHelp['SqlDriverInfo'] = { p: 'driverName:optional atomic text', d: 'When given a empty string as an argument, returns a list of names of all SQL drivers available on the current computer system. When given the name of an SQL driver, returns a list of the attributes of that driver.' };
    arrHelp['Sqr'] = { p: 'X:atom', d: 'Sqr(X) return the square of «X», which is «X»*«X».' };
    arrHelp['Sqrt'] = { p: 'X:atom', d: 'Sqrt(X) returns the square root of «X». «X» must be positive or zero.' };
    arrHelp['Statistics'] = { p: 'X : all ContextSamp[I] ; I : WarnDynamic Index = Run ; w : NonNegative ContextSamp[I] = SampleWeighting ; domainObj : optional Unevaluated = x', d: 'Statistics(X) returns an array of statistical results for probabilistic variable «X».<br/><br/>Specify the statistics to include with the "Uncertainty Options..." dialog off the "Result" menu.' };
    arrHelp['StepInterp'] = { p: 'D alias xi : Ascending Number OrNull All[I] ; R alias yi:All[I];X:Number OrNull Reduced;I:WarnDynamic Index=common;LeftLookup:optional boolean atom', d: 'StepInterp(D, R, X, I) finds the smallest value in array «D» which is greater than or equal to «X» and returns the corresponding value of array «R». «D» and «A» must be indexed by «I», and the interpolation occurs along dimension «I».' };
    arrHelp['StringLength'] = { p: 'Text : coerce Textual OrNull atomic', d: 'Returns the number of characters in «Text».' };
    arrHelp['StringLowerCase'] = { p: 'Text:coerce textual OrNull atomic', d: 'Returns a string with all upper case letters replaced by their lower case equivalents.' };
    arrHelp['StringMixedCase'] = { p: 'Text:coerce textual OrNull atomic ; preserveUC : optional named numeric atomic', d: 'Returns a string where the first letter of each sentence is upper case, and all other letters are lower case. If the optional second parameter is "True", then upper case letters are not converted to lower case (i.e., preserves proper nouns).' };
    arrHelp['StringReplace'] = { p: 'text,pattern,subst:coerce textual OrNull atomic;all,caseInsensitive:optional named numeric atomic ; re:optional named atom boolean', d: 'Replaces the occurrence of «pattern» in «text» by «subst».<br/>If «all» is "true", replaces every occurrence of «pattern».<br/>If «all» is "false", replaces only the first occurrence (default).<br/>If «caseInsensitive» is "true", matches to «pattern» in a case-insensitive fashion.<br/>If «re» is "true", treats pattern as a regular expression.<br/><br/> TextReplace("One more, one less, or none", "one", "two") <br/>   → "One more, two less, or none"<br/> TextReplace("One more, one less, or none", "one", "two", all:true) <br/>   → "One more, two less, or ntwo"<br/> TextReplace("One more, one less, or none", "one", "two", caseInsensitive:true, all:true) <br/>   → "two more, two less, or ntwo"<br/><br/>When using a regular expression, escape sequences can be used to substituted the matched text or text matched by sub-patterns within the regular expression:<br/><br/> \0 = The matched text<br/> \ 1, \ 2,...,\ 9 = Text matching numbered sub-patterns<br/> <name> = text matching a named sub-pattern<br/> <br/>TextReplace("153, "742,123", "3,234", 903", ""(?<e3>\d{1,3}),(?<e0>\d{3})"", "<e3><e0>", all:true, re:true)<br/>   → "153, 742123, 3234, 903"' };
    arrHelp['StringUpperCase'] = { p: 'Text:coerce textual OrNull atomic', d: 'Returns a string with all lower case letters replaced by their upper case equivalents.' };
    arrHelp['StudentT'] = { p: 'dof:positive[Run] ; over : ... optional named atomic ; singleSampleMethod : optional hidden scalar', d: 'The Student-T distribution describes the deviation of a sample mean from the true mean when the samples are generated by a normally distributed process. The statistic <br/>    t = ( m - u ) / (s * sqrt(n))<br/>where m is the sample mean, u the actual mean, s the sample standard deviation, and n the sample size, is distributed according to the Student-T distribution with n-1 degrees of freedom. The parameter, «dof», is the degrees of freedom. Student-T distributions are bell-shaped, much like a normal distribution, but with heavier tails, especially for smaller degrees of freedom. When n=1, it is known as the Cauchy distribution. For efficiency reasons, when a Latin Hypercube sampling method is selected, psuedo-Latin Hypercube method is used to sample the Student-T, which samples from the T-distribution, but does not guarantee a perfect Latin spread of the samples.' };
    arrHelp['SubFindString'] = { p: 'substr,text:coerce textual OrNull atomic;start,caseInsensitive:optional named numeric atomic ; re:atom optional named boolean ; return : optional named text reduced ; subpattern:optional named reduced; repeat:optional named atomic boolean; repeatSubpattern: optional named atomic; repeatIndex : optional named index', d: 'FindInText(substr,text) returns the position of the first occurrence of «substr» in «text». If «substr» does not occur in text, returns 0.<br/><br/>Optional parameters:<br/>«start»: position to start searching.<br/>«caseInsensitive»: If true, match «substr» in a lower/upper-case insensitive fashion.<br/>«re»: When true, treat «substr» as a regular expression<br/>«return»: What to return:<br/>   "P" = position of match<br/>   "L" = length of match<br/>   "S" = sub-pattern text that matches<br/>   "#" = number of regular expression subpattern groups<br/>«subPattern»: A named or numbered regular expression subpattern to return information for.<br/>«repeat»: When true, finds all matches. The result is indexed by a local index named .Repeat.<br/>«repeatSubpattern»: Find all matches and use the named or numbered regular expression subpattern matches for the index labels. With a named subpattern, uses the subpattern name as the local index name.<br/>«repeatIndex»: An pre-existing index for the result. Finds the first Size(«repeatIndex») matches.' };
    arrHelp['SubIndex'] = { p: 'A : Vector[I] ; U : reduced ; I : recommended index', d: 'Subindex(A,U,I) returns the value from index «I» corresponding to value «U» in array «A». For each value of «U», the result is an element of «I», unless the value «U» does not occur in «A», in which case NULL is returned.' };
    arrHelp['Subscript'] = { p: 'A : Expression ; I : Index ImpliedDotI ; x : Expression ; defVal alias default : optional', d: 'Subscript(A,I,x) returns the element or cross-section of array «A» for which index «I» has the value «x». When «x» is a list or array, Subscript returns several elements or cross-sections of array «A» along index «I». This can be used to re-index an array, swapping the index «I» for another index «J» having the same elements using Subscript(A,I,J), or to re-order the array when J is a permutation of «I».<br/><br/>Because Subscript is one of, if not the most commonly used operation in Analytica expressions, the shorthand operator notation for Subscript, A[I=x], is usually employed.<br/><br/>When the element «x» does not exist in «I», an out-of-range warning may occur (provided that the ""Show Result Warnings"" preference is enabled). The warning will not occur when «x» as the form of a shift-operation, i.e., I-expr or I+expr. You can avoid the warning either by wrapping the call to Subscript() inside a call to IgnoreWarnings(), or by providing the optional «defVal» parameter to supply the value for out-of-range slices. Ignoring warnings is equivalent to:<br/><br/>	Subscript(A,I,x,defVal:Null)<br/><br/>Subscript uses constant-time associative lookup for very fast performance.' };
    arrHelp['Subset'] = { p: 'D:vector[I];position:optional boolean atom;I:optional WarnDynamic index;ResultIndex : optional named index; warnEmpty alias warn: optional named boolean atom ; origD : hidden = D', d: 'When «D» is a one-dimensional array, Subset(D) returns a list containing the elements of «D»"s index for which «D» has a true (non-zero and non-null) value. Subset(D,position:true) returns the position of the true elements in the array, rather than the index value.<br/><br/>When «D» has (or may have) two or more dimensions, then then you should also use the index parameters «I» and «resultIndex». Use «I» to indicate which index the subset should be taken over -- the result will be elements of this index. You should also use the «resultIndex» parameter to specify an index for the result. When the «resultIndex» is longer than the number of items in the subset, it is padded with Nulls. If it is shorter, then only the number of items that fit are retained.<br/><br/>When you use Subset(D) on a one-dimensional array, the result is a list and thus can be used to define an index. However, this usage does not array-abstract, since if a dimension is ever added to «D», you would logically have an array of lists of varying sizes, which is not allowed. In contrast, the result of Subset(D,I:I,resultIndex:J) is an array indexed by «resultIndex», rather than a list, and seamlessly array-abstracts. While not appropriate for the definition of an index, it can be more flexible.<br/><br/>You can specify warnEmpty:true if you want Subset() to issue a warning when the no elements satisfy the criteria. The warning will only show if the Show Result Warnings preference is on and warnings are not currently being ignored.' };
    arrHelp['SubString'] = { p: 'Text:coerce textual OrNull atomic;first : numeric OrNull atomic ; last : optional numeric OrNull atomic', d: 'Returns the substring of Text from «first» to «last» characters (first character is «first»=1). «last» is optional, if omitted or zero, returns the substring starting at «first» to the end.' };
    arrHelp['SubTable'] = { p: 'subscriptExpr : Unevaluated ; rawProbs, fullDeterm : optional boolean atomic', d: 'SubTable(A[I=x]) is usually used with a single parameter, which should be a subscript or slice operation applied to a variable A containing an Edit table. When it is a top-level function and A is an Edit table, it provides an Edit table style view of a subset of the Edit table for A, such that the original table A gets updated when the SubTable entries are changed. The Edit table, A, must have index I. You may zero in on a particular rectangular subset of a table using SubTable(A[I1=J1,I2=J2], where I1 and I2 are indexes of A, J1 and J2 are subsets of I1 and I2 respectively.<br/><br/>When evaluated, Subtable returns the evaluation of its parameter. When the original table, A, is a DetermTable or ProbTable, setting an optional parameter, fullDeterm:true, evaluates and returns all cells of A without applying the DetermTable"s parent selectors. For a ProbTable, specifying rawProbs:true returns the computed probabilities rather than a Monte-Carlo sample or mid-value.' };
    arrHelp['Sum'] = { p: 'X ; I : ... recommended WarnDynamic Index ; IgnoreNonNumbers, IgnoreNaN : optional atomic boolean ; NumImplicit:hidden optional positive atomic', d: 'Sum(X,I) returns the sum(s) of all the elements of «X» along the dimension indexed by «I». The result has the same dimensions of array «X» with index «I» removed.<br/><br/>More than one index may be specified, e.g., Sum(X,I,J,K), in which case «X» is summed along all given dimensions.<br/><br/>Sum(X) sums over the implicit dimension, if there is one, or will sum the elements of a 1-D array. It is always better to specify the index if possible.<br/><br/>Sum(A,I,IgnoreNonNumerics:True) ignores non-numeric values like text, references, handles, etc., and Sum(A,I,IgnoreNaN:True) ignores indeterminate numeric values.' };
    arrHelp['Sys_AllInModule'] = { p: 'module:Object;objects:optional ...', d: 'Sys_AllInModule() is a function used internally by Analytica. It should not be called in your own expressions.' };
    arrHelp['Sys_CoordIndex'] = { p: 'X:atomic', d: 'Used internally to indicate that a role is a comparison index value. May not be evaluated.' };
    arrHelp['Sys_LocalIndex'] = { p: 'S:atomic text;instance:optional positive;slice:optional positive', d: 'Used internally to indicate that a role is a local index. May not be evaluated.' };
    arrHelp['Table'] = { p: 'Indexes:Index...', d: 'Table(I1, I2, ... In)(u1, u2, ... um) returns an n-dimensional array indexed by «I1», «I2», ... «In», with index «In» varying the most rapidly. The second set of parameters, «u1», «u2», ... «um», give the values in the array.' };
    arrHelp['Tan'] = { p: 'degrees:atom', d: 'Returns the tangent of the parameter, where the parameter is given in degrees.' };
    arrHelp['TanH'] = { p: 'Degrees:atom', d: 'Returns the hyperbolic tangent.' };
    arrHelp['TestHeapConsistency'] = { p: 'showErr : boolean atomic = false', d: 'ShowHeapConsistency() scans and performs various consistency checks on Analytica"s internal memory heap. It returns "True" unless evidence of memory corruption is detected, in which case it returns false. ShowHeapConsistency(true) also reports an error message.  Analytica will be unresponsive while the memory tests are being performed.' };
    arrHelp['TextLength'] = { p: 'Text : coerce Textual OrNull atomic', d: 'Returns the number of characters in «Text».' };
    arrHelp['TextLowerCase'] = { p: 'Text:coerce textual OrNull atomic', d: 'Returns a string with all upper case letters replaced by their lower case equivalents.' };
    arrHelp['TextReplace'] = { p: 'text,pattern,subst:coerce textual OrNull atomic;all,caseInsensitive:optional named numeric atomic ; re:optional named atom boolean', d: 'Replaces the occurrence of «pattern» in «text» by «subst».<br/>If «all» is "true", replaces every occurrence of «pattern».<br/>If «all» is "false", replaces only the first occurrence (default).<br/>If «caseInsensitive» is "true", matches to «pattern» in a case-insensitive fashion.<br/>If «re» is "true", treats pattern as a regular expression.<br/><br/> TextReplace("One more, one less, or none", "one", "two") <br/>   → "One more, two less, or none"<br/> TextReplace("One more, one less, or none", "one", "two", all:true) <br/>   → "One more, two less, or ntwo"<br/> TextReplace("One more, one less, or none", "one", "two", caseInsensitive:true, all:true) <br/>   → "two more, two less, or ntwo"<br/><br/>When using a regular expression, escape sequences can be used to substituted the matched text or text matched by sub-patterns within the regular expression:<br/><br/>\0 = The matched text<br/> \ 1,\ 2,...,\9 = Text matching numbered sub-patterns<br/> <name> =text matching a named sub-pattern<br/> <br/>TextReplace("153, "742,123", "3,234", 903", ""(?<e3>\d{1,3}),(?<e0>\d{3})"", "<e3><e0>", all:true, re:true)<br/>   → "153, 742123, 3234, 903"' };
    arrHelp['TextSentenceCase'] = { p: 'Text:coerce textual OrNull atomic ; preserveUC : optional named numeric atomic', d: 'Returns a string where the first letter of each sentence is upper case, and all other letters are lower case. If the optional second parameter is "True", then upper case letters are not converted to lower case (i.e., preserves proper nouns).' };
    arrHelp['TextTrim'] = { p: 'Text:coerce textual OrNull atomic; leftOnly : optional named boolean atomic ; rightOnly : optional named boolean atomic ; trimChars : optional named atomic text', d: 'TextTrim(Text) removes leading and trailing whitespace characters from «Text». Both leading and trailing spaces, tabs and newline characters are removed.<br/><br/>To remove spaces from just one side, use TextTrim(text,leftOnly:True) or TextTrim(text,rigthOnly:true). To alter the set of characters that are trimmed, use TextTrim(text,trimChars:chars), where chars is a text string containing the characters to be trimmed.' };
    arrHelp['TextUpperCase'] = { p: 'Text:coerce textual OrNull atomic', d: 'Returns a string with all lower case letters replaced by their upper case equivalents.' };
    arrHelp['Today'] = { p: 'withTime,utc : optional named atomic boolean orNull', d: 'Returns today"s date as the number of days elapsed since Jan 1, 1904. Be aware that when you evaluate this function, your result will probably be cached, and the cached result may eventually become out-of-date if the date changes.' };
    arrHelp['Transpose'] = { p: 'C ; I,J : recommended WarnDynamic Index ; R : hidden optional All[I,J]', d: 'Transpose(C,I,J) returns the matrix transpose of «C», swapping dimensions «I» and «J». The two dimensions must have the same length.' };
    arrHelp['Triangular'] = { p: 'min,mode,max:numeric[Run] ; over : ... optional named atomic ; singleSampleMethod : optional hidden scalar', d: 'Triangular(mid,mod,max) returns a continuous, triangular probability distribution bounded by «min» and «max», and with the specified «mode».' };
    arrHelp['Truncate'] = { p: 'Dist : Numeric OrNull Samp[Run] ; Min: recommended Numeric[Run] ; Max : Optional Numeric[Run] ; singleSampleMethod : optional hidden scalar ; sortedSamp : optional hidden[Run]', d: 'Truncate(Dist, Min, Max) returns the continuous probability distribution «Dist» truncated below the «Min» and above the «Max» parameter values. You may specify one or both of the threshold values. For example; Truncate( Normal(10,5), min:0 ). ' };
    arrHelp['Try'] = { p: 'expr : unevaluated ; catch : named unevaluated ; errorNum : ... named optional positive', d: 'Evaluates «expr», but if an evaluation error occurs in the same definition, or in a UDF called directly from the expression, it evaluates «catch» without reporting the error.<br/><br/>Example:<br/><br/>	Try(DbQuery(conn,sql),<br/>	catch: null<br/>	)<br/><br/>You can optionally specify specific error numbers to catch:<br/><br/>	Try( DbQuery(conn,sql),<br/>	ErrorNum:41076,41077,<br/>	catch: null<br/>	)<br/><br/>Inside the «catch» parameter, the following local variables can be used:<br/>	ErrorText: Text of the error message.<br/>	ErrorNumber: The error number.<br/>	ErrorLocation: A handle to the object where the error occurred.' };
    arrHelp['TypeOf'] = { p: 'x : atomic ; shallow: optional named atomic Boolean', d: 'TypeOf(x) returns a textual string indicating the type of the underlying atomic value «x». Common return values include: "Undefined", "Null", "Numeric", "Text", and "Reference". When applied to a variable type, possible return values include "Decision", "Variable", "Chance", "Objective", "Index", "Constant", and "Function". In these cases, a second optional parameter, «shallow», can be specified, so that TypeOf(x,true) returns "Object". In esoteric cases, the function can be applied to internal data types, resulting return values of "ObjectSet", "Data", "Expression", "LP", "QP", "NLP", "Custom".' };
    arrHelp['Uncumulate'] = { p: 'X : all QuadraticNumeric OrNull Vector[I] ; I : recommended WarnDynamic Index ; firstElement : optional atom; passNull : optional boolean atom', d: 'Uncumulate(X,I) returns an array with each element being the difference between the corresponding element of «X» and the previous element of «X»v along dimension «» added.  The first element is the first element of «X». Uncumulate(X,I,a) sets the first element to «a».' };
    arrHelp['Uniform'] = { p: 'min,max:recommended numeric[Run] ; integer : optional named boolean[Run] ; over : ... optional named atomic ; singleSampleMethod : optional named atomic hidden numeric', d: 'Uniform(min,max) returns a continuous probability distribution such that every value between «min» and «max» has an equal chance of occurring. Uniform(min,max,integer:true) returns a discrete distribution in which every integer between «min» and «max» inclusive has an equal chance of occurring.' };
    arrHelp['Unique'] = { p: 'A : Reduced ; I : WarnDynamic Index ; Position : optional named boolean atom; CaseInsensitive : optional named boolean atom ; ResultIndex : hidden optional index', d: 'Given an array, «A», indexed by «I», returns a subset «J» of «I» such that each slice of A[J] is unique. To get the unique elements of A, use A[I=J], where index J is defined as Unique(A,I).<br/><br/>When an optional parameter, «position», is "true", returns the position in «I» of unique elements.' };
    arrHelp['UsingLocal'] = { p: '«null»', d: '""Var «x» := «expr» Do «body»"" returns the value of evaluating the expression «body» after substituting the value of «expr» for the identifier «x».<br/><br/>You may declare explicit indexes for «x» using the syntax:<br/>	Var «x»[I,J,...] := «expr» Do «body»<br/>Analytica will then ensure that the value substituted for «x» contains only those indexes -- if there are others, «body» will be evaluated multiple times to ensure that at each iteration spurious indexes aren""t present. To specify that «x» is assumed to be atomic inside «body», you may list zero indexes between the brackets:<br/>	Var «x»[ ] := «expr» Do «body»<br/>or alternatively make use:<br/>Atomic «x»:=«expr» Do «body»' };
    arrHelp['Variance'] = { p: 'x : ContextSamp[I] ; I : optional Index WarnDynamic = Run ; w : optional named NonNegative ContextSamp[I] = SampleWeighting', d: 'Variance(X) returns an estimate of the variance of «X».<br/><br/>The variance is a measure of the spread or dispersion of a distribution. It is equal to the square of the standard deviation.<br/><br/>Variance(X,I) computes the variance of a data set along index «I».' };
    arrHelp['VarTerm'] = { p: 'X : Object Atom ; AsIndex : optional boolean atomic', d: 'Returns a handle to an object. This function has been deprecated, use the synonymous function Handle(A) instead.' };
    arrHelp['Weibull'] = { p: 'shape : positive[Run] ; scale : recommended positive[Run] ; over : ... optional named atomic ; singleSampleMethod : optional hidden scalar', d: 'The Weibull distribution is often used to represent failure time in reliability models. It is similar in shape to the gamma distribution, but tends to be less skewed and tail-heavy.' };
    arrHelp['WhatIf'] = { p: 'Expr:Unevaluated;V:Variable;X:Context;Preserve:optional named boolean atom', d: 'WhatIf(Y,X,v) returns the result of evaluating «Y» when variable «X» is temporarily replaced with «v». «Y» should be dependent on «X» for this to produce different results from the simple evaluation of «Y».' };
    arrHelp['WhatIfAll'] = { p: 'Expr:Unevaluated;Vars:Unevaluated;NewVals:Context;Preserve:boolean named atom=true', d: 'WhatIfAll(Expr, Vars, NewVals) returns the mid value of «Expr» when the variables in «Vars» are each assigned the values in «NewVals», one variable at a time, while the other variables are held at their nominal values. «Vars» may be an index whose definition is a list of identifiers. By doing so, and having «NewVals» indexed by «Vars», a different value can be assigned to each variable.<br/><br/>WhatIfAll() is useful for computing the data for a tornado diagram. For example, suppose Z is a function of A,B, and C, and one wishes to examine the effect on Z when each input is varied, one at a time, by 10% from its nominal value. Define:<br/>  L := [90%,110%]<br/>  V := [A,B,C]<br/>Then the effects of varying one input at a time is given by:<br/>  WhatIfAll(Z,V,L*V)' };
    arrHelp['While'] = { p: 'cond,body:Expression;modifier:optional hidden Unevaluated', d: 'While() evaluates «body» repeatedly while «test» evaluates to non-zero. For this to terminate, «body» must produce a side-effect on a local variable that is used by «test». «test» must evaluate to be an atomic (non-array) value; therefore, it is a good idea to force any local variable used in «test» to be atomic (non-array) valued. While() returns the final evaluation of body (in the last iteration), or null if no iterations occur. Usage of While() often follows the following pattern:<br/><br/>  Var x[] := ...;<br/>  While( FunctionOf(x) ) Do (<br/>    ...<br/>    x := «expr»<br/>  ) ;<br/>  «return value»' };
    arrHelp['Wilcoxon'] = { p: 'm,n : nonNegative OrNull atom[run] ; exact : optional boolean OrNull[run] ; over : ... optional named atomic ; singleSampleMethod: optional hidden atomic numeric', d: 'The Wilcoxon distribution characterizes the distribution of the Wilcoxon rank-sum statistic, also known as the U-statistic, that is obtained when comparing two populations with unpaired samples having sizes «m» and «n». The distribution is non-negative and discrete, and approaches a Normal distribution for large «m»+«n».<br/><br/>The «exact» parameter controls whether an exact algorithm or a Normal approximation is used. By default, a Normal approximation is used when m+n>100 which has an accuracy within 0.1%.' };
    arrHelp['WorksheetCell'] = { p: 'Workbook : ExcelWorkbookType atom ; sheet : atom ; column : atom ; row : positive atom ; what : optional atom text ; calc : optional boolean atom', d: 'This function is deprecated. It is no longer supported and may be removed from future releases of Analytica. Please use SpreadsheetCell instead.' };
    arrHelp['WorksheetRange'] = { p: 'Workbook : ExcelWorkbookType atom ; sheet : text atom ; range : atomic text ; colIndex,rowIndex : recommended index ; howToIndex: optional named boolean ; what : optional named atom text ; calc : optional boolean atom', d: 'This function is deprecated. It is no longer supported and may be removed from future releases of Analytica. Please use SpreadsheetRange instead.' };
    arrHelp['WriteTextFile'] = { p: 'filename : text atom; text : coerce text reduced ; append,warn : optional named boolean atom; sep : optional named text atom ; showDialog : optional named boolean atom ; encoding : optional text atom ; title alias caption : optional named atomic text', d: 'Writes text to a file.<br/><br/>Parameters:<br/>«filename»:	The name of the file, relative to CurrentDataDirectory().<br/>«text»:	The text to be written.<br/>«append»:	(optional) When set to True, the text is appended to the end of the file if it exists.<br/>«warn»: (optional) When set to True, a warning is issued if the file already exists.<br/>«sep»:	(optional) When «text» is an array, each item is written separated by «sep». The default is a new line.<br/>«showDialog»:	(optional) When set to True, a file open dialog is displayed before creating the file, so the user can change the name or select the folder. When False, the dialog is suppressed in all cases.<br/>«encoding»:	(optional) The character encoding used. Possible values are: "aNSI"", ""UTF-8"", ""-UTF-8"" (without BOM), ""UTF-16"", or ""UTF-16le"".<br/><br/>If the write is successful, the function returns the path of the file.' };
    arrHelp['WriteWorksheetCell'] = { p: 'Workbook : ExcelWorkbookType atom ; sheet : atom ; column : atom ; row : positive atom ; value : atom ; what : optional hidden atom text', d: 'This function is deprecated. It is no longer supported and may be removed from future releases of Analytica. Please use SpreadsheetSetCell instead.' };
    arrHelp['WriteWorksheetRange'] = { p: 'Workbook : ExcelWorkbookType atom ; sheet : text atom ; range : text atom ; value : array[colIndex,rowIndex] ; colIndex,rowIndex : recommended WarnDynamic Index ; what : optional hidden atom text', d: 'This function is deprecated. It is no longer supported and may be removed from future releases of Analytica. Please use SpreadsheetSetRange instead.' };
    arrHelp['XIrr'] = { p: 'Values : numeric all[I] ; dates : Array all[I] ; I : WarnDynamic Index ; guess : optional numeric atomic', d: 'Returns the Internal Rate of Return (for a 365 day period) of a series of payments (negative values) and inflows (positive values). Unlike the IRR function, the payments may be at arbitrary date intervals. The IRR is the discount rate at which the Net Present Value (NPV) of the flows is zero.<br/><br/>Parameters:<br/>  «Values»: An array of values indexed by «I».  All values must be<br/>      numeric.  Under normal usage, some values will be positive<br/>      and some will be negative.<br/>  «Dates»: An array of dates indexed by «I».  The first date in the<br/>       series is taken as the reference (present) date.<br/>  «I»: The index of «Values» over which the NPV/IRR is computed.<br/>  «Guess»: (Optional)  A guess to seed the search (defaults to 10%).<br/><br/>' };
    arrHelp['XMIrr'] = { p: 'values, dates : Numeric OrNull all[I] ; I : WarnDynamic Index ; financeRate,reinvestRate : OrNull[I]', d: 'Computes the modified internal rate of return for a series of non-periodic cash flows occurring on arbitrary dates.<br/><br/>The parameters «values» and «dates» should share index «I», where the dates are expressed as the number of days elapsed since the date origin. The «financeRate» and «reinvestRate» parameters are based on a 365-day year.' };
    arrHelp['XNpv'] = { p: 'Rate : numeric OrNull atomic ; Values : QuadraticNumber OrNull all[I] ; Dates : Numeric OrNull all[I] ; I : WarnDynamic Index', d: 'Returns the Net Present Value of a schedule of cash flows that is not necessarily periodic. For periodic payments, the Npv() function is more convenient.<br/><br/>Parameters:<br/>  «Rate»: The discount rate. Daily rate is taken to be Rate/365<br/>  «Values»: An array of cash flows indexed by «I».<br/>  «Dates»:  An array of dates for cash flows, indexed by «I».<br/>          Each date is the # of days since Jan 1, 1904.<br/>  «I»: The index of values for which the NPV is computed.' };
    arrHelp['YearFrac'] = { p: 'startDate,endDate : scalar ; basis : named scalar=0', d: 'Returns the fraction of the year represented by the number of whole days between two dates, «startDate» and «endDate», for the purpose of identifying the proportion of a whole year as utilized by certain financial instruments.<br/><br/>The optional parameter «basis» selects the type of day counting system to use:<br/>0 or omitted = US (NASD) 30/360<br/>1 = Actual/actual<br/>2 = Actual/360<br/>3 = Actual/365<br/>4 = European 30/360<br/><br/>The function duplicates Excel"s YearFrac function.' };
    arrHelp['_InvokeMethod'] = { p: 'obj : atom COMObject ; name : text ;parameters : ... optional NoListSyntax atom ; rhs:optional atom', d: 'Access the property of, or call a method of a COM object. Examples:<br/><br/>	obj->property<br/>	obj->method(«params»)<br/>	obj->property := «expr»' };
    arrHelp['_OptSetContextWrap'] = { p: 'opt:unevaluated optimization ; expr', d: 'Internal function used by DefineOptimization() when handling SetContext variables that are downstream from decision variables.' };

    // end complete

    var oop = require("../lib/oop");
    var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

    var AdeHighlightRules = function () {
      this.$rules = {
        start:
          [
            {
              caseInsensitive: true,
              token: 'class.activex',
              regex: '\\b(?:(' + classActiveX + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.alias',
              regex: '\\b(?:(' + classAlias + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.attribute',
              regex: '\\b(?:(' + classAttribute + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.button',
              regex: '\\b(?:(' + classButton + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.chance',
              regex: '\\b(?:(' + classChance + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.command',
              regex: '\\b(?:(' + classCommand + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.constant',
              regex: '\\b(?:(' + classConstant + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.constraint',
              regex: '\\b(?:(' + classConstraint + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.decision',
              regex: '\\b(?:(' + classDecision + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.determ',
              regex: '\\b(?:(' + classDeterm + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.excelworkbook',
              regex: '\\b(?:(' + classExcelWorkbook + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.form',
              regex: '\\b(?:(' + classForm + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.formnode',
              regex: '\\b(?:(' + classFormNode + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.function',
              regex: '\\b(?:(' + classFunction + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.graphstyletemplate',
              regex: '\\b(?:(' + classGraphStyleTemplate + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.index',
              regex: '\\b(?:(' + classIndex + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.keyword',
              regex: '\\b(?:(' + classKeyword + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.library',
              regex: '\\b(?:(' + classLibrary + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.linklibrary',
              regex: '\\b(?:(' + classLinkLibrary + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.linkmodule',
              regex: '\\b(?:(' + classLinkModule + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.localvar',
              regex: '\\b(?:(' + classLocalVar + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.model',
              regex: '\\b(?:(' + classModel + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.module',
              regex: '\\b(?:(' + classModule + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.object',
              regex: '\\b(?:(' + classObject + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.objective',
              regex: '\\b(?:(' + classObjective + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.picture',
              regex: '\\b(?:(' + classPicture + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.pluginfunction',
              regex: '\\b(?:(' + classPluginFunction + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.pluginlibrary',
              regex: '\\b(?:(' + classPluginLibrary + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.sysfunction',
              regex: '\\b(?:(' + classSysFunction + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.syslibrary',
              regex: '\\b(?:(' + classSysLibrary + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.sysvar',
              regex: '\\b(?:(' + classSysVar + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.text',
              regex: '\\b(?:(' + classText + '))\\b'
            },
            {
              caseInsensitive: true,
              token: 'class.variable',
              regex: '\\b(?:(' + classVariable + '))\\b'
            },
            {
              token: 'constant.numeric',
              regex: '\\b((0(x|X)[0-9a-fA-F]*)|(([0-9]+\\.?[0-9]*)|(\\.[0-9]+))((e|E)(\\+|-)?[0-9]+)?)(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\\b'
            },
            {
              token: 'punctuation.definition.comment',
              regex: '--.*$',
              push_:
                [{
                  token: 'comment.line.double-dash.one',
                  regex: '$',
                  next: 'pop'
                },
                { defaultToken: 'comment.line.double-dash.one' }]
            },
            {
              token: 'punctuation.definition.comment',
              regex: '//.*$',
              push_:
                [{
                  token: 'comment.line.double-slash.two',
                  regex: '$',
                  next: 'pop'
                },
                { defaultToken: 'comment.line.double-slash.two' }]
            },
            {
              token: 'punctuation.definition.comment',
              regex: '\\/\\*',
              push:
                [{
                  token: 'punctuation.definition.comment',
                  regex: '\\*\\/',
                  next: 'pop'
                },
                { defaultToken: 'comment.block.one' }]
            },
            {
              token: 'punctuation.definition.comment',
              regex: '\\{',
              push:
                [{
                  token: 'punctuation.definition.comment',
                  regex: '\\}',
                  next: 'pop'
                },
                { defaultToken: 'comment.block.two' }]
            },
            {
              token: 'punctuation.definition.string.begin',
              regex: '"',
              push:
                [{ token: 'constant.character.escape', regex: '\\\\.' },
                {
                  token: 'punctuation.definition.string.end',
                  regex: '"',
                  next: 'pop'
                },
                { defaultToken: 'string.quoted.double' }]
            },
            {
              token: 'punctuation.definition.string.begin',
              regex: '\'',
              push:
                [{
                  token: 'constant.character.escape.apostrophe',
                  regex: '\'\''
                },
                {
                  token: 'punctuation.definition.string.end',
                  regex: '\'',
                  next: 'pop'
                },
                { defaultToken: 'string.quoted.single' }]
            },
            {
              token: 'keyword.operator',
              regex: '[+\\-;,/*%]|:=|='
            }]
      }

      this.normalizeRules();

      var completions = [];
      var addCompletions = function (arr, meta, help) {
        arr.forEach(function (v) {

          var docHTML = null;
          var params = null;
          if (meta == "SysFunction") {
            if (help[v]) {
              if (help[v].p) {
                docHTML = "<b>" + help[v].p + "</b>";
                params = help[v].p;
              }
              else {
                docHTML = "<b>" + v + "</b>";
              }

              if (help[v].d) {
                docHTML += "<hr>" + help[v].d;
              }
            }

          }

          completions.push({
            name: v,
            value: v,
            score: 0,
            meta: meta,
            docHTML: docHTML,
            params: params
          });
        });
      };
      addCompletions(classAttribute.split('|'), 'Attribute');
      addCompletions(classCommand.split('|'), 'Command');
      addCompletions(classKeyword.split('|'), 'Keyword');
      addCompletions(classObject.split('|'), 'Object');
      addCompletions(classSysFunction.split('|'), 'SysFunction', arrHelp);
      addCompletions(classSysLibrary.split('|'), 'SysLibrary');
      addCompletions(classSysVar.split('|'), 'SysVar');

      this.completions = completions;
      this.nodeDictionary = [];
    };

    oop.inherits(AdeHighlightRules, TextHighlightRules);

    exports.AdeHighlightRules = AdeHighlightRules;
  });

ace.define("ace/mode/ade",
  ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/ade_highlight_rules"],
  function (require, exports, module) {
    "use strict";

    var oop = require("../lib/oop");
    var TextMode = require("./text").Mode;
    var AdeHighlightRules = require("./ade_highlight_rules").AdeHighlightRules;

    var Mode = function () {
      this.HighlightRules = AdeHighlightRules;
    };
    oop.inherits(Mode, TextMode);

    (function () {
      //this.lineCommentStart = ["{", "}"];
      this.blockComment = [
        { start: "/*", end: "*/" },
        { start: "{", end: "}" }
      ];

      /*
      this.getCompletions = function (state, session, pos, prefix) {
          //return session.$mode.$highlightRules.completions.concat(session.$mode.$highlightRules.nodeDictionary);
          return session.$mode.$highlightRules.completions;
      };
      */

      this.$id = "ace/mode/ade";
    }).call(Mode.prototype);
    exports.Mode = Mode;
  });
